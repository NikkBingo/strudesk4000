// src/components/StrudelVisualizer.tsx
import { useEffect as useEffect2, useRef as useRef2 } from "react";

// src/hooks/use-strudel-visualizer.ts
import { useEffect, useState, useRef } from "react";

// src/lib/strudel-lexer.ts
function tokenize(code) {
  const tokens = [];
  let position = 0;
  let line = 1;
  let column = 1;
  const keywords = /* @__PURE__ */ new Set([
    "sound",
    "s",
    "stack",
    "cat",
    "slowcat",
    "fastcat",
    "append",
    "fastAppend",
    "slowAppend",
    "overlay",
    "layer",
    "superimpose",
    "add",
    "sub",
    "mul",
    "div",
    "scale",
    "chord",
    "arp",
    "arpeggiate",
    "note",
    "n",
    "freq",
    "legato",
    "sustain",
    "hold",
    "cut",
    "orbit",
    "struct",
    "mask",
    "euclid",
    "euclidLegato",
    "euclidRot",
    "inside",
    "outside",
    "compress",
    "focus",
    "zoom",
    "fastGap",
    "range",
    "rangex",
    "saw",
    "sine",
    "square",
    "tri",
    "rand",
    "irand",
    "perlin",
    "choose",
    "wchoose",
    "shuffle",
    "scramble",
    "rot",
    "swingBy",
    "swing",
    "ghost",
    "press",
    "fit",
    "quantize",
    "inhabit",
    "splice",
    "weave",
    "fast",
    "slow",
    "cpm",
    "bpm",
    "every",
    "whenmod",
    "stut",
    "echo",
    "ply",
    "hurry",
    "sometimes",
    "often",
    "rarely",
    "almostNever",
    "almostAlways",
    "never",
    "always",
    "someCycles",
    "someCyclesBy",
    "off",
    "jux",
    "juxBy",
    "rev",
    "palindrome",
    "iter",
    "degrade",
    "degradeBy",
    "chunk",
    "segment",
    "bite",
    "chop",
    "gain",
    "velocity",
    "lpf",
    "hpf",
    "bandf",
    "crush",
    "distort",
    "coarse",
    "room",
    "delay",
    "tremolo",
    "phaser",
    "chorus",
    "djf",
    "vowel",
    "cutoff",
    "resonance",
    "hcutoff",
    "lcutoff",
    "speed",
    "accelerate",
    "pitch",
    "octave",
    "pan"
  ]);
  while (position < code.length) {
    const char = code[position];
    if (char === "\n") {
      line++;
      column = 1;
      position++;
      continue;
    }
    if (char === " " || char === "	") {
      column++;
      position++;
      continue;
    }
    if (char === "/" && code[position + 1] === "/") {
      while (position < code.length && code[position] !== "\n") {
        position++;
      }
      continue;
    }
    if (char === "(") {
      tokens.push({
        type: "PAREN_START",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === ")") {
      tokens.push({
        type: "PAREN_END",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === "[") {
      tokens.push({
        type: "BRACKET_START",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === "]") {
      tokens.push({
        type: "BRACKET_END",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === "<") {
      tokens.push({
        type: "ANGLE_START",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === ">") {
      tokens.push({
        type: "ANGLE_END",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === ",") {
      tokens.push({
        type: "COMMA",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === ".") {
      tokens.push({
        type: "DOT",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === ":") {
      tokens.push({
        type: "COLON",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === "*") {
      tokens.push({
        type: "ASTERISK",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === "@") {
      tokens.push({
        type: "AT",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === "!") {
      tokens.push({
        type: "OPERATOR",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === "/") {
      tokens.push({
        type: "OPERATOR",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === "~") {
      tokens.push({
        type: "TILDE",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === "_") {
      tokens.push({
        type: "UNDERSCORE",
        value: char,
        position,
        line,
        column
      });
      position++;
      column++;
      continue;
    }
    if (char === '"' || char === "'" || char === "`") {
      const startQuote = char;
      const startPos = position;
      const startCol = column;
      position++;
      column++;
      let value = "";
      while (position < code.length && code[position] !== startQuote) {
        if (code[position] === "\\" && position + 1 < code.length) {
          value += code[position + 1];
          position += 2;
          column += 2;
        } else {
          value += code[position];
          position++;
          column++;
        }
      }
      if (position < code.length) {
        position++;
        column++;
      }
      tokens.push({
        type: "STRING",
        value,
        position: startPos,
        line,
        column: startCol
      });
      continue;
    }
    if (/\d/.test(char) || char === "-" && /\d/.test(code[position + 1] || "")) {
      const startPos = position;
      const startCol = column;
      let value = "";
      if (char === "-") {
        value += char;
        position++;
        column++;
      }
      while (position < code.length && /[\d.]/.test(code[position] || "")) {
        value += code[position];
        position++;
        column++;
      }
      tokens.push({
        type: "NUMBER",
        value,
        position: startPos,
        line,
        column: startCol
      });
      continue;
    }
    if (/[a-zA-Z_]/.test(char)) {
      const startPos = position;
      const startCol = column;
      let value = "";
      while (position < code.length && /[a-zA-Z0-9_]/.test(code[position] || "")) {
        value += code[position];
        position++;
        column++;
      }
      const type = keywords.has(value) ? "FUNCTION" : "SOUND";
      tokens.push({
        type,
        value,
        position: startPos,
        line,
        column: startCol
      });
      continue;
    }
    position++;
    column++;
  }
  tokens.push({
    type: "EOF",
    value: "",
    position,
    line,
    column
  });
  return tokens;
}

// src/lib/strudel-parser.ts
var Parser = class {
  constructor(tokens) {
    this.context = {
      tokens,
      position: 0,
      errors: []
    };
  }
  currentToken() {
    const token = this.context.tokens[this.context.position] || this.context.tokens[this.context.tokens.length - 1];
    if (!token) {
      return { type: "EOF", value: "", position: 0, line: 0, column: 0 };
    }
    return token;
  }
  advance() {
    if (this.context.position < this.context.tokens.length - 1) {
      this.context.position++;
    }
  }
  expect(type) {
    const token = this.currentToken();
    if (token.type === type) {
      this.advance();
      return token;
    }
    this.addError(`Expected ${type}, got ${token.type}`, token);
    return null;
  }
  addError(message, token) {
    this.context.errors.push({
      message,
      token,
      position: token.position
    });
  }
  parse() {
    try {
      const ast = this.parseExpression();
      return {
        ast,
        errors: this.context.errors,
        success: this.context.errors.length === 0
      };
    } catch {
      return {
        ast: null,
        errors: this.context.errors,
        success: false
      };
    }
  }
  parseExpression() {
    const token = this.currentToken();
    if (token.type === "FUNCTION" && token.value === "stack") {
      return this.parseStack();
    }
    if (token.type === "FUNCTION" && (token.value === "cat" || token.value === "slowcat" || token.value === "fastcat")) {
      return this.parseCat();
    }
    if (token.type === "FUNCTION" && (token.value === "sound" || token.value === "s")) {
      return this.parseSound();
    }
    if (token.type === "STRING") {
      return this.parseMiniNotation();
    }
    return null;
  }
  parseStack() {
    this.expect("FUNCTION");
    this.expect("PAREN_START");
    const children = [];
    while (this.currentToken().type !== "PAREN_END" && this.currentToken().type !== "EOF") {
      const child = this.parseExpression();
      if (child) {
        children.push(child);
      }
      if (this.currentToken().type === "COMMA") {
        this.advance();
      }
    }
    this.expect("PAREN_END");
    return {
      type: "stack",
      children,
      position: 0,
      duration: 1,
      modifiers: this.parseModifiers()
    };
  }
  parseCat() {
    const funcToken = this.expect("FUNCTION");
    if (!funcToken) return null;
    const catType = funcToken.value;
    this.expect("PAREN_START");
    const children = [];
    while (this.currentToken().type !== "PAREN_END" && this.currentToken().type !== "EOF") {
      const child = this.parseExpression();
      if (child) {
        children.push(child);
      }
      if (this.currentToken().type === "COMMA") {
        this.advance();
      }
    }
    this.expect("PAREN_END");
    return {
      type: catType,
      children,
      position: 0,
      duration: 1,
      modifiers: this.parseModifiers()
    };
  }
  parseSound() {
    this.expect("FUNCTION");
    this.expect("PAREN_START");
    const stringToken = this.expect("STRING");
    if (!stringToken) return null;
    this.expect("PAREN_END");
    const pattern = stringToken.value;
    const tokens = pattern.split(/\s+/).filter((t) => t.length > 0);
    const children = [];
    let position = 0;
    const step = 1 / tokens.length;
    for (const token of tokens) {
      const child = this.parseMiniToken(token, position, step);
      if (child) {
        children.push(child);
      }
      position += step;
    }
    const modifiers = this.parseModifiers();
    if (children.length === 0) {
      return null;
    }
    if (children.length === 1) {
      const singleChild = children[0];
      if (singleChild) {
        singleChild.modifiers = [...singleChild.modifiers || [], ...modifiers];
        return singleChild;
      }
      return null;
    }
    return {
      type: "sequence",
      children,
      position: 0,
      duration: 1,
      modifiers
    };
  }
  parseFunctionReference() {
    const funcToken = this.currentToken();
    if (funcToken.type !== "FUNCTION") return null;
    const name = funcToken.value;
    this.advance();
    if (this.currentToken().type !== "PAREN_START") {
      return { name, args: [] };
    }
    this.advance();
    const args = [];
    while (this.currentToken().type !== "PAREN_END" && this.currentToken().type !== "EOF") {
      const token = this.currentToken();
      if (token.type === "NUMBER") {
        args.push(parseFloat(token.value));
        this.advance();
      } else if (token.type === "STRING") {
        args.push(token.value);
        this.advance();
      } else {
        this.advance();
      }
      if (this.currentToken().type === "COMMA") {
        this.advance();
      }
    }
    if (this.currentToken().type !== "PAREN_END") return null;
    this.advance();
    return { name, args };
  }
  parseModifiers() {
    const modifiers = [];
    while (this.currentToken().type === "DOT") {
      this.advance();
      const funcToken = this.currentToken();
      if (funcToken.type !== "FUNCTION") break;
      const modifierName = funcToken.value;
      this.advance();
      this.expect("PAREN_START");
      const args = [];
      while (this.currentToken().type !== "PAREN_END" && this.currentToken().type !== "EOF") {
        const token = this.currentToken();
        if (token.type === "FUNCTION") {
          const savePos = this.context.position;
          this.advance();
          if (this.currentToken().type === "PAREN_START") {
            this.context.position = savePos;
            const maybeFunctionRef = this.parseFunctionReference();
            if (maybeFunctionRef) {
              args.push(maybeFunctionRef);
            } else {
              this.context.position = savePos;
              const pattern = this.parseExpression();
              if (pattern) {
                args.push(pattern);
              }
            }
          } else {
            this.context.position = savePos;
            const pattern = this.parseExpression();
            if (pattern) {
              args.push(pattern);
            }
          }
        } else if (token.type === "NUMBER") {
          args.push(parseFloat(token.value));
          this.advance();
        } else if (token.type === "STRING") {
          args.push(token.value);
          this.advance();
        } else if (token.type === "OPERATOR" && token.value === "/") {
          this.advance();
        } else {
          this.advance();
        }
        if (this.currentToken().type === "COMMA") {
          this.advance();
        }
      }
      this.expect("PAREN_END");
      modifiers.push({
        name: modifierName,
        args
      });
    }
    return modifiers;
  }
  parseMiniNotation() {
    const stringToken = this.expect("STRING");
    if (!stringToken) return null;
    const pattern = stringToken.value;
    const tokens = pattern.split(/\s+/).filter((t) => t.length > 0);
    const children = [];
    let position = 0;
    const step = 1 / tokens.length;
    for (const token of tokens) {
      const child = this.parseMiniToken(token, position, step);
      if (child) {
        children.push(child);
      }
      position += step;
    }
    if (children.length === 1) {
      return children[0] || null;
    }
    return {
      type: "sequence",
      children,
      position: 0,
      duration: 1
    };
  }
  parseMiniToken(token, position, duration) {
    if (token === "~" || token === "_") {
      return {
        type: "silence",
        position,
        duration
      };
    }
    const repeatHoldMatch = token.match(/^(.+?)!(\d+)$/);
    if (repeatHoldMatch) {
      const sound = repeatHoldMatch[1] || "";
      const repeats = parseInt(repeatHoldMatch[2] || "1");
      const totalDuration = duration * repeats;
      return {
        type: "sound",
        value: sound.toLowerCase(),
        position,
        duration: totalDuration,
        repetitions: repeats
      };
    }
    const repeatMatch = token.match(/^(.+?)\*(\d+)$/);
    if (repeatMatch) {
      const sound = repeatMatch[1] || "";
      const repeats = parseInt(repeatMatch[2] || "1");
      const substep = duration / repeats;
      const children = [];
      for (let i = 0; i < repeats; i++) {
        children.push({
          type: "sound",
          value: sound.toLowerCase(),
          position: position + substep * i,
          duration: substep
        });
      }
      return {
        type: "repetition",
        children,
        position,
        duration,
        repetitions: repeats
      };
    }
    const sampleMatch = token.match(/^([^:]+):(\d+)(?::(\d+))?$/);
    if (sampleMatch) {
      return {
        type: "sample_select",
        value: sampleMatch[1]?.toLowerCase() || "",
        sampleIndex: parseInt(sampleMatch[2] || "0"),
        position,
        duration
      };
    }
    const euclideanMatch = token.match(/^([^(]+)\((\d+),(\d+)\)$/);
    if (euclideanMatch) {
      return {
        type: "euclidean",
        value: euclideanMatch[1]?.toLowerCase() || "",
        euclidean: {
          pulses: parseInt(euclideanMatch[2] || "0"),
          steps: parseInt(euclideanMatch[3] || "0")
        },
        position,
        duration
      };
    }
    const weightMatch = token.match(/^(.+?)@(\d+)$/);
    if (weightMatch) {
      return {
        type: "sound",
        value: weightMatch[1]?.toLowerCase() || "",
        weight: parseInt(weightMatch[2] || "1"),
        position,
        duration
      };
    }
    if (token.startsWith("[") && token.endsWith("]")) {
      const inner = token.slice(1, -1);
      const subtokens = inner.split(/\s+/).filter((t) => t.length > 0);
      const children = [];
      const substep = duration / subtokens.length;
      let subpos = 0;
      for (const subtoken of subtokens) {
        const child = this.parseMiniToken(subtoken, position + subpos, substep);
        if (child) {
          children.push(child);
        }
        subpos += substep;
      }
      return {
        type: "subgroup",
        children,
        position,
        duration
      };
    }
    if (token.startsWith("<") && token.endsWith(">")) {
      const inner = token.slice(1, -1);
      const options = inner.split(/\s+/).filter((t) => t.length > 0);
      const children = [];
      for (const option of options) {
        const child = this.parseMiniToken(option, position, duration);
        if (child) {
          children.push(child);
        }
      }
      return {
        type: "alternation",
        children,
        position,
        duration
      };
    }
    return {
      type: "sound",
      value: token.toLowerCase(),
      position,
      duration
    };
  }
};
function parse(code) {
  const tokens = tokenize(code);
  const parser = new Parser(tokens);
  return parser.parse();
}

// src/lib/strudel-interpreter.ts
function detectSoundType(sound) {
  const s = sound.toLowerCase();
  if (s.includes("bd") || s.includes("kick")) return "kick";
  if (s.includes("sd") || s.includes("snare") || s.includes("cp")) return "snare";
  if (s.includes("hh") || s.includes("hat") || s.includes("oh") || s.includes("ch")) return "hihat";
  if (s.includes("bass")) return "bass";
  if (s.includes("sawtooth") || s.includes("square") || s.includes("sine") || s.includes("triangle")) return "synth";
  if (s.includes("perc") || s.includes("tom") || s.includes("rim")) return "perc";
  if (s.includes("crash") || s.includes("ride") || s.includes("bell")) return "fx";
  return "other";
}
function generateEuclideanRhythm(pulses, steps) {
  if (pulses >= steps) {
    return new Array(steps).fill(true);
  }
  const pattern = new Array(steps).fill(false);
  const bucket = new Array(steps).fill(0);
  for (let i = 0; i < steps; i++) {
    bucket[i] = Math.floor(i * pulses / steps);
  }
  let prev = -1;
  for (let i = 0; i < steps; i++) {
    const currentBucket = bucket[i];
    if (currentBucket !== void 0 && currentBucket !== prev) {
      pattern[i] = true;
      prev = currentBucket;
    }
  }
  return pattern;
}
function applyFunctionReference(funcRef, effects) {
  switch (funcRef.name) {
    case "fast": {
      const factor = typeof funcRef.args[0] === "number" ? funcRef.args[0] : 1;
      effects.fastFactor *= factor;
      break;
    }
    case "slow": {
      const factor = typeof funcRef.args[0] === "number" ? funcRef.args[0] : 1;
      effects.slowFactor *= factor;
      break;
    }
    case "gain":
    case "velocity": {
      const value = typeof funcRef.args[0] === "number" ? funcRef.args[0] : 1;
      effects.gain *= value;
      break;
    }
    case "speed": {
      const value = typeof funcRef.args[0] === "number" ? funcRef.args[0] : 1;
      effects.speed *= value;
      break;
    }
    case "lpf":
    case "hpf":
    case "bandf":
    case "crush":
    case "distort":
    case "coarse": {
      const value = typeof funcRef.args[0] === "number" ? funcRef.args[0] : 0;
      effects[funcRef.name] = value;
      break;
    }
    case "rev":
      effects.rev = true;
      break;
    case "palindrome":
      effects.palindrome = true;
      break;
    case "degrade":
      effects.degrade = 0.5;
      break;
    case "degradeBy": {
      const prob = typeof funcRef.args[0] === "number" ? funcRef.args[0] : 0.5;
      effects.degrade = prob;
      break;
    }
  }
}
function interpret(ast, _cps = 0.5) {
  if (!ast) return [];
  const events = [];
  function traverseNode(node, baseTime = 0, baseDuration = 1, modifiers = {}, transformations = {}) {
    let gain = 1;
    let speed = 1;
    let fastFactor = 1;
    let slowFactor = 1;
    let plyFactor = 1;
    const effects = { ...modifiers };
    const transforms = { ...transformations };
    if (node.modifiers) {
      for (const modifier of node.modifiers) {
        switch (modifier.name) {
          case "cpm":
          case "bpm":
            break;
          case "gain":
          case "velocity":
            gain *= typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            break;
          case "speed":
          case "hurry":
          case "accelerate":
            speed *= typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            break;
          case "pitch":
            effects.pitch = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "octave":
            effects.octave = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "delay":
          case "echo":
            effects.delay = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "room":
            effects.reverb = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "tremolo":
            effects.tremolo = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "phaser":
            effects.phaser = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "chorus":
            effects.chorus = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "cut":
            effects.cut = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "lpf":
          case "lcutoff":
            effects.lpf = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "hpf":
          case "hcutoff":
            effects.hpf = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "bandf":
          case "cutoff":
            effects.bandf = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "resonance":
            effects.resonance = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "djf":
            effects.djf = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "vowel":
            effects.vowel = typeof modifier.args[0] === "string" ? modifier.args[0] : "a";
            break;
          case "crush":
            effects.crush = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "distort":
            effects.distort = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "coarse":
            effects.coarse = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "pan":
            effects.pan = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            break;
          case "fast": {
            const factor = typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            fastFactor *= factor;
            break;
          }
          case "slow": {
            const factor = typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            slowFactor *= factor;
            break;
          }
          case "ply": {
            const repeats = typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            plyFactor *= repeats;
            break;
          }
          case "rev":
            transforms.rev = true;
            break;
          case "palindrome":
            transforms.palindrome = true;
            break;
          case "iter": {
            const n = typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            transforms.iter = n;
            break;
          }
          case "degrade":
            transforms.degrade = 0.5;
            break;
          case "degradeBy": {
            const prob = typeof modifier.args[0] === "number" ? modifier.args[0] : 0.5;
            transforms.degrade = prob;
            break;
          }
          case "append":
          case "fastAppend":
          case "slowAppend":
          case "overlay":
          case "layer":
          case "superimpose": {
            const patternArg = modifier.args[0];
            if (patternArg && typeof patternArg === "object" && "type" in patternArg) {
              const additionalEvents = [];
              const tempEvents = events;
              traverseNode(patternArg, baseTime, baseDuration, effects, {});
              const newEvents = events.slice(tempEvents.length);
              if (modifier.name === "append" || modifier.name === "fastAppend" || modifier.name === "slowAppend") {
                const maxTime = Math.max(...events.map((e) => e.time + e.duration), 0);
                for (const evt of newEvents) {
                  additionalEvents.push({
                    ...evt,
                    time: evt.time + maxTime
                  });
                }
              } else {
                additionalEvents.push(...newEvents);
              }
              events.push(...additionalEvents);
            }
            break;
          }
          case "sometimes": {
            const funcRef = modifier.args[0];
            if (funcRef && typeof funcRef === "object" && "name" in funcRef && Math.random() < 0.5) {
              const tempEffects = { fastFactor, slowFactor, gain, speed };
              applyFunctionReference(funcRef, tempEffects);
              fastFactor = tempEffects.fastFactor;
              slowFactor = tempEffects.slowFactor;
              gain = tempEffects.gain;
              speed = tempEffects.speed;
              Object.assign(effects, tempEffects);
            }
            break;
          }
          case "often": {
            const funcRef = modifier.args[0];
            if (funcRef && typeof funcRef === "object" && "name" in funcRef && Math.random() < 0.75) {
              const tempEffects = { fastFactor, slowFactor, gain, speed };
              applyFunctionReference(funcRef, tempEffects);
              fastFactor = tempEffects.fastFactor;
              slowFactor = tempEffects.slowFactor;
              gain = tempEffects.gain;
              speed = tempEffects.speed;
              Object.assign(effects, tempEffects);
            }
            break;
          }
          case "rarely": {
            const funcRef = modifier.args[0];
            if (funcRef && typeof funcRef === "object" && "name" in funcRef && Math.random() < 0.25) {
              const tempEffects = { fastFactor, slowFactor, gain, speed };
              applyFunctionReference(funcRef, tempEffects);
              fastFactor = tempEffects.fastFactor;
              slowFactor = tempEffects.slowFactor;
              gain = tempEffects.gain;
              speed = tempEffects.speed;
              Object.assign(effects, tempEffects);
            }
            break;
          }
          case "almostNever": {
            const funcRef = modifier.args[0];
            if (funcRef && typeof funcRef === "object" && "name" in funcRef && Math.random() < 0.1) {
              const tempEffects = { fastFactor, slowFactor, gain, speed };
              applyFunctionReference(funcRef, tempEffects);
              fastFactor = tempEffects.fastFactor;
              slowFactor = tempEffects.slowFactor;
              gain = tempEffects.gain;
              speed = tempEffects.speed;
              Object.assign(effects, tempEffects);
            }
            break;
          }
          case "almostAlways": {
            const funcRef = modifier.args[0];
            if (funcRef && typeof funcRef === "object" && "name" in funcRef && Math.random() < 0.9) {
              const tempEffects = { fastFactor, slowFactor, gain, speed };
              applyFunctionReference(funcRef, tempEffects);
              fastFactor = tempEffects.fastFactor;
              slowFactor = tempEffects.slowFactor;
              gain = tempEffects.gain;
              speed = tempEffects.speed;
              Object.assign(effects, tempEffects);
            }
            break;
          }
          case "never":
            break;
          case "always": {
            const funcRef = modifier.args[0];
            if (funcRef && typeof funcRef === "object" && "name" in funcRef) {
              const tempEffects = { fastFactor, slowFactor, gain, speed };
              applyFunctionReference(funcRef, tempEffects);
              fastFactor = tempEffects.fastFactor;
              slowFactor = tempEffects.slowFactor;
              gain = tempEffects.gain;
              speed = tempEffects.speed;
              Object.assign(effects, tempEffects);
            }
            break;
          }
          case "stut":
          case "every":
          case "whenmod":
          case "someCycles":
          case "someCyclesBy":
          case "off":
          case "jux":
          case "juxBy":
          case "note":
          case "n": {
            const noteValue = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            effects.note = noteValue;
            break;
          }
          case "freq": {
            const freqValue = typeof modifier.args[0] === "number" ? modifier.args[0] : 440;
            effects.freq = freqValue;
            break;
          }
          case "scale": {
            const scaleName = typeof modifier.args[0] === "string" ? modifier.args[0] : "major";
            effects.scale = scaleName;
            break;
          }
          case "chord": {
            const chordName = typeof modifier.args[0] === "string" ? modifier.args[0] : "major";
            effects.chord = chordName;
            break;
          }
          case "arp":
          case "arpeggiate": {
            effects.arp = true;
            break;
          }
          case "add": {
            const value = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            effects.add = value;
            break;
          }
          case "sub": {
            const value = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            effects.sub = value;
            break;
          }
          case "mul": {
            const value = typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            effects.mul = value;
            break;
          }
          case "div": {
            const value = typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            effects.div = value;
            break;
          }
          case "legato":
          case "sustain":
          case "hold": {
            const value = typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            effects.legato = value;
            break;
          }
          case "orbit": {
            const value = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            effects.orbit = value;
            break;
          }
          case "struct":
          case "mask": {
            const pattern = typeof modifier.args[0] === "string" ? modifier.args[0] : "";
            effects.struct = pattern;
            break;
          }
          case "shuffle": {
            const n = typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            effects.shuffle = n;
            break;
          }
          case "scramble": {
            const n = typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            effects.scramble = n;
            break;
          }
          case "rot": {
            const n = typeof modifier.args[0] === "number" ? modifier.args[0] : 0;
            effects.rot = n;
            break;
          }
          case "swingBy":
          case "swing": {
            const amount = modifier.name === "swingBy" && typeof modifier.args[0] === "number" ? modifier.args[0] : 0.5;
            effects.swing = amount;
            break;
          }
          case "ghost": {
            effects.ghost = true;
            break;
          }
          case "quantize": {
            const n = typeof modifier.args[0] === "number" ? modifier.args[0] : 1;
            effects.quantize = n;
            break;
          }
          case "chunk":
          case "segment":
          case "bite":
          case "chop":
          case "euclid":
          case "euclidLegato":
          case "euclidRot":
          case "inside":
          case "outside":
          case "compress":
          case "focus":
          case "zoom":
          case "fastGap":
          case "range":
          case "rangex":
          case "saw":
          case "sine":
          case "square":
          case "tri":
          case "rand":
          case "irand":
          case "perlin":
          case "choose":
          case "wchoose":
          case "press":
          case "fit":
          case "inhabit":
          case "splice":
          case "weave":
            break;
        }
      }
    }
    const timingMultiplier = fastFactor / slowFactor * plyFactor;
    const adjustedDuration = baseDuration / (fastFactor / slowFactor);
    switch (node.type) {
      case "sound":
      case "sample_select": {
        if (!node.value) break;
        if (timingMultiplier > 1) {
          for (let i = 0; i < timingMultiplier; i++) {
            events.push({
              sound: node.value,
              time: baseTime + node.position + i * adjustedDuration * node.duration,
              duration: node.duration * adjustedDuration,
              type: detectSoundType(node.value),
              gain,
              speed,
              effects,
              probability: node.weight ? node.weight / 10 : 1,
              sampleIndex: node.sampleIndex
            });
          }
        } else {
          events.push({
            sound: node.value,
            time: baseTime + node.position,
            duration: node.duration * adjustedDuration,
            type: detectSoundType(node.value),
            gain,
            speed,
            effects,
            probability: node.weight ? node.weight / 10 : 1,
            sampleIndex: node.sampleIndex
          });
        }
        break;
      }
      case "silence":
        break;
      case "sequence":
      case "subgroup":
      case "repetition": {
        if (node.children) {
          let children = [...node.children];
          if (transforms.rev) {
            children = children.reverse();
          }
          if (transforms.palindrome) {
            children = [...children, ...children.slice().reverse()];
          }
          if (transforms.iter && transforms.iter > 1) {
            const original = [...node.children];
            children = [];
            for (let i = 0; i < transforms.iter; i++) {
              const rotated = [...original.slice(i), ...original.slice(0, i)];
              children.push(...rotated);
            }
          }
          if (timingMultiplier > 1) {
            const originalChildren = [...children];
            children = [];
            for (let i = 0; i < timingMultiplier; i++) {
              children.push(...originalChildren);
            }
          }
          let timeOffset = 0;
          const childDuration = adjustedDuration / (timingMultiplier > 1 ? timingMultiplier : 1);
          for (const child of children) {
            if (transforms.degrade && Math.random() < (transforms.degrade || 0)) {
              timeOffset += childDuration;
              continue;
            }
            traverseNode(child, baseTime + timeOffset, childDuration, effects, {});
            timeOffset += childDuration;
          }
        }
        break;
      }
      case "alternation": {
        if (node.children && node.children.length > 0) {
          const cycleIndex = Math.floor(baseTime / adjustedDuration) % node.children.length;
          const selectedChild = node.children[cycleIndex];
          if (selectedChild) {
            traverseNode(selectedChild, baseTime, adjustedDuration, effects, {});
          }
        }
        break;
      }
      case "euclidean": {
        if (!node.value || !node.euclidean) break;
        const { pulses, steps } = node.euclidean;
        const rhythm = generateEuclideanRhythm(pulses, steps);
        const stepDuration = node.duration / steps;
        for (let i = 0; i < steps; i++) {
          if (rhythm[i]) {
            events.push({
              sound: node.value,
              time: baseTime + node.position + i * stepDuration,
              duration: stepDuration * adjustedDuration,
              type: detectSoundType(node.value),
              gain,
              speed,
              effects,
              probability: 1
            });
          }
        }
        break;
      }
      case "stack": {
        if (node.children) {
          for (const child of node.children) {
            traverseNode(child, baseTime, adjustedDuration, effects, {});
          }
        }
        break;
      }
      case "cat": {
        if (node.children) {
          const stepDuration = adjustedDuration / node.children.length;
          let currentTime = baseTime;
          for (const child of node.children) {
            traverseNode(child, currentTime, stepDuration, effects, {});
            currentTime += stepDuration;
          }
        }
        break;
      }
      case "slowcat": {
        if (node.children) {
          const cycleIndex = Math.floor(baseTime / adjustedDuration) % node.children.length;
          const selectedChild = node.children[cycleIndex];
          if (selectedChild) {
            traverseNode(selectedChild, baseTime, adjustedDuration, effects, {});
          }
        }
        break;
      }
      case "fastcat": {
        if (node.children) {
          const stepDuration = adjustedDuration / node.children.length;
          let currentTime = baseTime;
          for (const child of node.children) {
            traverseNode(child, currentTime, stepDuration, effects, {});
            currentTime += stepDuration;
          }
        }
        break;
      }
    }
  }
  traverseNode(ast);
  return events.sort((a, b) => a.time - b.time);
}

// src/hooks/use-strudel-visualizer.ts
function useStrudelVisualizer(options) {
  const {
    code,
    isPlaying,
    cps = 0.5,
    fftSize = 128,
    smoothingFactor = 0.85,
    decayRate = 2.5
  } = options;
  const [frequencyData, setFrequencyData] = useState(null);
  const [parseResult, setParseResult] = useState(null);
  const [events, setEvents] = useState([]);
  const animationFrameRef = useRef(void 0);
  const eventsRef = useRef([]);
  const timeRef = useRef(0);
  useEffect(() => {
    try {
      const result = parse(code);
      setParseResult(result);
      if (result.success && result.ast) {
        const parsedEvents = interpret(result.ast, cps);
        setEvents(parsedEvents);
      } else {
        setEvents([]);
      }
    } catch (error) {
      console.error("[StrudelVisualizer] Parse error:", error);
      setEvents([]);
      setParseResult({
        ast: null,
        errors: [{
          message: error instanceof Error ? error.message : "Unknown error",
          token: { type: "EOF", value: "", position: 0, line: 0, column: 0 },
          position: 0
        }],
        success: false
      });
    }
  }, [code, cps]);
  useEffect(() => {
    if (!isPlaying) {
      setFrequencyData(null);
      return;
    }
    const dataArray = new Uint8Array(fftSize);
    const updateFrequencyData = () => {
      if (isPlaying) {
        const currentTime = timeRef.current;
        const cycle = currentTime * cps;
        const cycleFrac = cycle % 1;
        for (const parsedEvent of events) {
          const eventStart = parsedEvent.time;
          const eventEnd = parsedEvent.time + parsedEvent.duration;
          if (cycleFrac >= eventStart && cycleFrac < eventEnd) {
            const isNewTrigger = !eventsRef.current.some(
              (e) => Math.abs(e.time - currentTime) < 0.05
            );
            if (isNewTrigger) {
              const impactStrength = parsedEvent.type === "kick" ? 1 : parsedEvent.type === "snare" ? 0.8 : parsedEvent.type === "hihat" ? 0.6 : 0.7;
              eventsRef.current.push({
                time: currentTime,
                type: parsedEvent.type,
                decay: impactStrength,
                gain: parsedEvent.gain,
                effects: parsedEvent.effects
              });
              if (eventsRef.current.length > 20) {
                eventsRef.current.shift();
              }
            }
          }
        }
        timeRef.current += 0.016;
        const now = currentTime;
        eventsRef.current = eventsRef.current.filter((e) => now - e.time < 0.4);
        for (let i = 0; i < dataArray.length; i++) {
          const freq = i / dataArray.length;
          let eventEnergy = 0;
          for (const event of eventsRef.current) {
            const age = now - event.time;
            const decayFactor = Math.max(0, 1 - age * decayRate);
            const gainMultiplier = event.gain;
            const effectsMultiplier = 1 + (event.effects.delay || 0) * 0.3 + (event.effects.reverb || 0) * 0.2;
            if (event.type === "kick") {
              eventEnergy += freq < 0.25 ? decayFactor * event.decay * gainMultiplier * 200 : freq < 0.5 ? decayFactor * event.decay * gainMultiplier * 80 : 0;
            } else if (event.type === "snare") {
              eventEnergy += freq > 0.2 && freq < 0.7 ? decayFactor * event.decay * gainMultiplier * 160 : 0;
            } else if (event.type === "hihat") {
              eventEnergy += freq > 0.55 ? decayFactor * event.decay * gainMultiplier * 140 : 0;
            } else if (event.type === "bass") {
              eventEnergy += freq < 0.35 ? decayFactor * event.decay * gainMultiplier * 150 : 0;
            } else if (event.type === "synth") {
              eventEnergy += freq > 0.35 && freq < 0.8 ? decayFactor * event.decay * gainMultiplier * 140 : 0;
            } else if (event.type === "perc") {
              eventEnergy += freq > 0.3 && freq < 0.7 ? decayFactor * event.decay * gainMultiplier * 130 : 0;
            } else if (event.type === "fx") {
              eventEnergy += freq > 0.4 ? decayFactor * event.decay * gainMultiplier * 120 : 0;
            } else {
              eventEnergy += decayFactor * event.decay * gainMultiplier * 110;
            }
            eventEnergy *= effectsMultiplier;
          }
          const time = timeRef.current;
          const bass = Math.sin(time * 1.2 + freq * Math.PI) * 0.25 + 0.35;
          const mid = Math.sin(time * 2.5 + freq * Math.PI * 2) * 0.2 + 0.25;
          const high = Math.sin(time * 4 + freq * Math.PI * 3) * 0.15 + 0.2;
          const freqRolloff = Math.pow(1 - freq, 0.6);
          const baseEnergy = (bass * 0.35 + mid * 0.3 + high * 0.2) * freqRolloff * 100;
          const combined = baseEnergy + eventEnergy;
          const variation = Math.random() * 12;
          dataArray[i] = Math.min(255, Math.max(0, combined + variation));
        }
        setFrequencyData(new Uint8Array(dataArray));
      }
      animationFrameRef.current = requestAnimationFrame(updateFrequencyData);
    };
    updateFrequencyData();
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [isPlaying, events, cps, fftSize, decayRate, smoothingFactor]);
  return {
    frequencyData,
    parseResult,
    events,
    hasErrors: parseResult ? !parseResult.success : false,
    errorCount: parseResult?.errors.length || 0
  };
}

// src/components/StrudelVisualizer.tsx
import { jsx, jsxs } from "react/jsx-runtime";
function StrudelVisualizer(props) {
  const {
    width = "100%",
    height = "100%",
    barCount = 64,
    barColor = "#334155",
    barColorPlaying = "#00ff88",
    backgroundColor = "#0a0e1a",
    className,
    style,
    ...visualizerOptions
  } = props;
  const canvasRef = useRef2(null);
  const animationRef = useRef2(void 0);
  const barsRef = useRef2(new Array(barCount).fill(0));
  const { frequencyData, hasErrors, errorCount } = useStrudelVisualizer(visualizerOptions);
  useEffect2(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const resize = () => {
      const w = canvas.offsetWidth;
      const h = canvas.offsetHeight;
      canvas.width = w * window.devicePixelRatio;
      canvas.height = h * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    };
    resize();
    window.addEventListener("resize", resize);
    const draw = () => {
      const w = canvas.offsetWidth;
      const h = canvas.offsetHeight;
      ctx.fillStyle = `${backgroundColor}33`;
      ctx.fillRect(0, 0, w, h);
      const bars = barsRef.current;
      if (visualizerOptions.isPlaying && frequencyData) {
        for (let i = 0; i < bars.length; i++) {
          const dataIndex = Math.floor(i / bars.length * frequencyData.length);
          const value = (frequencyData[dataIndex] || 0) / 255;
          bars[i] = Math.max(value, (bars[i] || 0) * 0.85);
        }
      } else {
        for (let i = 0; i < bars.length; i++) {
          bars[i] = (bars[i] || 0) * 0.92;
        }
      }
      const barWidth = w / bars.length;
      const gradient = ctx.createLinearGradient(0, 0, 0, h);
      if (visualizerOptions.isPlaying) {
        const colors = barColorPlaying.split(",");
        if (colors.length > 1) {
          gradient.addColorStop(0, colors[0]?.trim() || barColorPlaying);
          gradient.addColorStop(1, colors[1]?.trim() || barColorPlaying);
        } else {
          gradient.addColorStop(0, barColorPlaying);
          gradient.addColorStop(1, barColorPlaying);
        }
      } else {
        const colors = barColor.split(",");
        if (colors.length > 1) {
          gradient.addColorStop(0, colors[0]?.trim() || barColor);
          gradient.addColorStop(1, colors[1]?.trim() || barColor);
        } else {
          gradient.addColorStop(0, barColor);
          gradient.addColorStop(1, barColor);
        }
      }
      for (let i = 0; i < bars.length; i++) {
        const value = bars[i] || 0;
        const minBarHeight = visualizerOptions.isPlaying ? 2 : 1;
        const barHeight = Math.max(minBarHeight, value * h * 0.8);
        const x = i * barWidth;
        const y = h - barHeight;
        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, barWidth - 2, barHeight);
      }
      animationRef.current = requestAnimationFrame(draw);
    };
    draw();
    return () => {
      window.removeEventListener("resize", resize);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [
    visualizerOptions.isPlaying,
    frequencyData,
    barCount,
    barColor,
    barColorPlaying,
    backgroundColor
  ]);
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className,
      style: {
        width,
        height,
        backgroundColor,
        position: "relative",
        ...style
      },
      children: [
        /* @__PURE__ */ jsx(
          "canvas",
          {
            ref: canvasRef,
            style: {
              width: "100%",
              height: "100%",
              display: "block"
            }
          }
        ),
        hasErrors && /* @__PURE__ */ jsxs(
          "div",
          {
            style: {
              position: "absolute",
              top: 8,
              right: 8,
              padding: "4px 8px",
              backgroundColor: "rgba(239, 68, 68, 0.9)",
              color: "white",
              borderRadius: 4,
              fontSize: 12,
              fontWeight: 500
            },
            children: [
              errorCount,
              " parse error",
              errorCount !== 1 ? "s" : ""
            ]
          }
        )
      ]
    }
  );
}
export {
  StrudelVisualizer,
  interpret,
  parse,
  tokenize,
  useStrudelVisualizer
};
