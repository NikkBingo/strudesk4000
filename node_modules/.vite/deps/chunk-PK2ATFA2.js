import {
  __export,
  __publicField
} from "./chunk-EWTE5DHJ.js";

// node_modules/@strudel/core/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  ClockCollator: () => tn,
  Cyclist: () => Pa,
  Fraction: () => h,
  Hap: () => C,
  Pattern: () => f,
  State: () => st,
  TimeSpan: () => x,
  __chooseWith: () => we,
  _brandBy: () => me,
  _fitslice: () => _n,
  _irand: () => ye,
  _keyDown: () => _e,
  _match: () => vn,
  _mod: () => ft,
  _morph: () => ee,
  _polymeterListSteps: () => qn,
  _retime: () => Lt,
  _slices: () => It,
  accelerate: () => Os,
  activeLabel: () => xi,
  ad: () => ju,
  add: () => Al,
  adsr: () => Ju,
  almostAlways: () => Lh,
  almostNever: () => Rh,
  always: () => Hh,
  amp: () => Ps,
  analyze: () => Us,
  anchor: () => Zi,
  and: () => Hl,
  apply: () => _p,
  applyN: () => bn,
  ar: () => Wu,
  arp: () => rl,
  arpWith: () => sl,
  arrange: () => al,
  as: () => ra,
  att: () => js,
  attack: () => Js,
  averageArray: () => Ne,
  backgroundImage: () => ud,
  band: () => Ol,
  bandf: () => rr,
  bandq: () => cr,
  bank: () => Gs,
  base64ToUnicode: () => Ye,
  bbexpr: () => Or,
  bbst: () => Er,
  beat: () => Df,
  begin: () => ar,
  berlin: () => xh,
  berlinWith: () => Aa,
  binary: () => mh,
  binaryN: () => ma,
  bind: () => ml,
  binshift: () => ru,
  bite: () => Tp,
  bjork: () => oe,
  blshift: () => Ml,
  bor: () => zl,
  bp: () => ir,
  bpa: () => po,
  bpattack: () => lo,
  bpd: () => go,
  bpdecay: () => wo,
  bpe: () => oo,
  bpenv: () => ro,
  bpf: () => or,
  bpq: () => ur,
  bpr: () => Oo,
  bprelease: () => Bo,
  bps: () => Ao,
  bpsustain: () => qo,
  brak: () => jp,
  brand: () => _h,
  brandBy: () => bh,
  brshift: () => Pl,
  bxor: () => El,
  bypass: () => hf,
  byteBeatExpression: () => Br,
  byteBeatStartTime: () => zr,
  calculateSteps: () => el,
  cat: () => at,
  ccn: () => Vu,
  ccv: () => Fu,
  ceil: () => Ql,
  ch: () => Pr,
  channel: () => Qr,
  channels: () => Mr,
  choose: () => wa,
  chooseCycles: () => ga,
  chooseIn: () => kh,
  chooseInWith: () => ge,
  chooseOut: () => qh,
  chooseWith: () => Mt,
  chop: () => Nf,
  chord: () => Ki,
  chorus: () => Qs,
  chunk: () => ef,
  chunkBack: () => rf,
  chunkBackInto: () => ff,
  chunkInto: () => lf,
  chunkback: () => of,
  chunkbackinto: () => pf,
  chunkinto: () => af,
  clamp: () => He,
  cleanupUi: () => ad,
  clip: () => yu,
  coarse: () => wr,
  code2hash: () => Ya,
  color: () => Eu,
  colour: () => Mu,
  comb: () => eu,
  compose: () => Da,
  compress: () => ep,
  compressSpan: () => np,
  compressor: () => qc,
  compressorAttack: () => Tc,
  compressorKnee: () => Ac,
  compressorRatio: () => Sc,
  compressorRelease: () => Cc,
  compressspan: () => sp,
  constant: () => Ga,
  contract: () => Bn,
  control: () => Hu,
  controls: () => Qf,
  cosine: () => rh,
  cosine2: () => oh,
  cpm: () => vp,
  cps: () => mu,
  createClock: () => ua,
  createParam: () => Bt,
  createParams: () => Pu,
  crush: () => yr,
  ctf: () => Xr,
  ctlNum: () => Du,
  ctranspose: () => Ei,
  curry: () => w,
  curve: () => vu,
  cut: () => Ur,
  cutoff: () => Kr,
  cycleToSeconds: () => Rt,
  dec: () => Ys,
  decay: () => Xs,
  degrade: () => zh,
  degradeBy: () => Oh,
  degradeByWith: () => Bh,
  degree: () => Oi,
  delay: () => Go,
  delayfb: () => Uo,
  delayfeedback: () => Qo,
  delayspeed: () => Xo,
  delaysync: () => ei,
  delayt: () => Zo,
  delaytime: () => Yo,
  deltaSlide: () => ku,
  det: () => ri,
  detune: () => si,
  dfb: () => Ko,
  dict: () => Yi,
  dictionary: () => Xi,
  dist: () => _c,
  distort: () => bc,
  distorttype: () => kc,
  distortvol: () => vc,
  div: () => Cl,
  djf: () => Do,
  drawLine: () => un,
  drive: () => Ar,
  drop: () => Tn,
  dry: () => ci,
  ds: () => Nu,
  dt: () => ti,
  duck: () => Sr,
  duckattack: () => xr,
  duckdepth: () => Tr,
  duckonset: () => Cr,
  dur: () => bu,
  duration: () => gu,
  e: () => Kf,
  early: () => kp,
  echo: () => Gp,
  echoWith: () => Hp,
  echowith: () => Vp,
  eish: () => nh,
  end: () => lr,
  enhance: () => Zc,
  eq: () => $l,
  eqt: () => Rl,
  errorLogger: () => Gt,
  euclid: () => Uf,
  euclidLegato: () => Zf,
  euclidLegatoRot: () => th,
  euclidRot: () => Yf,
  euclidish: () => eh,
  euclidrot: () => Xf,
  evalScope: () => Oa,
  evaluate: () => Ea,
  every: () => bp,
  expand: () => xn,
  expression: () => Pc,
  extend: () => Cn,
  fadeInTime: () => li,
  fadeOutTime: () => ai,
  fadeTime: () => ui,
  fanchor: () => Eo,
  fast: () => lp,
  fastChunk: () => uf,
  fastGap: () => rp,
  fastcat: () => W,
  fastchunk: () => cf,
  fastgap: () => op,
  fft: () => Ks,
  filter: () => gf,
  filterWhen: () => bf,
  firstOf: () => gp,
  fit: () => If,
  flatten: () => D,
  floor: () => Gl,
  fm: () => $s,
  fmattack: () => Ls,
  fmdecay: () => Hs,
  fmenv: () => Rs,
  fmh: () => Ns,
  fmi: () => Ws,
  fmrelease: () => Fs,
  fmsustain: () => Vs,
  fmvelocity: () => Ds,
  fmwave: () => Is,
  focus: () => ip,
  focusSpan: () => cp,
  focusspan: () => up,
  fractionalArgs: () => Qa,
  frameRate: () => cu,
  frames: () => uu,
  freeze: () => Qc,
  freq: () => pi,
  freqToMidi: () => Pe,
  fromBipolar: () => Kl,
  fshift: () => jc,
  fshiftnote: () => Nc,
  fshiftphase: () => Wc,
  ftype: () => zo,
  func: () => Fl,
  gain: () => Es,
  gap: () => ct,
  gat: () => Ai,
  gate: () => qi,
  getControlName: () => se,
  getCurrentKeyboardState: () => sn,
  getEventOffsetMs: () => La,
  getFreq: () => Je,
  getFrequency: () => Fa,
  getPerformanceTimeSeconds: () => tl,
  getPlayableNoteValue: () => Va,
  getSoundIndex: () => Ha,
  getTime: () => id,
  getTrigger: () => Ja,
  grow: () => kf,
  gt: () => jl,
  gte: () => Wl,
  harmonic: () => Mi,
  hash2code: () => Za,
  hbrick: () => ou,
  hcutoff: () => $o,
  hold: () => sr,
  hours: () => au,
  hp: () => Lo,
  hpa: () => ao,
  hpattack: () => uo,
  hpd: () => yo,
  hpdecay: () => mo,
  hpe: () => so,
  hpenv: () => no,
  hpf: () => Ro,
  hpq: () => Ho,
  hpr: () => xo,
  hprelease: () => Co,
  hps: () => ko,
  hpsustain: () => vo,
  hresonance: () => Io,
  hsl: () => wf,
  hsla: () => yf,
  hurry: () => fp,
  id: () => et,
  imag: () => Yc,
  inhabit: () => td,
  inhabitmod: () => nd,
  innerBind: () => yl,
  inside: () => mp,
  inv: () => Mp,
  invert: () => Ep,
  ir: () => lc,
  irand: () => vh,
  irbegin: () => hc,
  iresponse: () => pc,
  irspeed: () => fc,
  isControlName: () => $n,
  isNote: () => qt,
  isNoteWithOctave: () => $a,
  isPattern: () => Yt,
  isaw: () => Ot,
  isaw2: () => ue,
  iter: () => Xp,
  iterBack: () => Yp,
  iterback: () => Zp,
  itri: () => ah,
  itri2: () => lh,
  jux: () => Ip,
  juxBy: () => Rp,
  juxby: () => Lp,
  kcutoff: () => Lc,
  keep: () => kl,
  keepif: () => ql,
  keyAlias: () => nn,
  keyDown: () => Fh,
  krush: () => Rc,
  label: () => Bi,
  lastOf: () => wp,
  late: () => wn,
  lbrick: () => iu,
  legato: () => wu,
  leslie: () => Si,
  lfo: () => Su,
  linger: () => Cp,
  listRange: () => ht,
  lock: () => ni,
  logKey: () => Dt,
  logger: () => E,
  loop: () => pr,
  loopAt: () => Rf,
  loopAtCps: () => Hf,
  loopBegin: () => fr,
  loopEnd: () => dr,
  loopat: () => Lf,
  loopatcps: () => Vf,
  loopb: () => hr,
  loope: () => mr,
  lp: () => Zr,
  lpa: () => co,
  lpattack: () => io,
  lpd: () => ho,
  lpdecay: () => fo,
  lpe: () => eo,
  lpenv: () => to,
  lpf: () => Yr,
  lpq: () => Fo,
  lpr: () => To,
  lprelease: () => So,
  lps: () => _o,
  lpsustain: () => bo,
  lrate: () => Ti,
  lsize: () => Ci,
  lt: () => Jl,
  lte: () => Nl,
  mapArgs: () => Ut,
  mask: () => pl,
  midi2note: () => Ia,
  midiToFreq: () => nt,
  midibend: () => Zu,
  midichan: () => $u,
  midicmd: () => Iu,
  midimap: () => Ru,
  midiport: () => Lu,
  miditouch: () => ta,
  minutes: () => lu,
  mod: () => xl,
  mode: () => nc,
  morph: () => Gf,
  mouseX: () => dh,
  mouseY: () => fh,
  mousex: () => hh,
  mousey: () => ph,
  mtranspose: () => zi,
  mul: () => Tl,
  n: () => xs,
  nanFallback: () => We,
  ne: () => Ll,
  net: () => Il,
  never: () => Ih,
  noise: () => jo,
  note: () => Bs,
  noteToMidi: () => pt,
  nothing: () => R,
  nrpnn: () => Gu,
  nrpv: () => Qu,
  nudge: () => ji,
  numeralArgs: () => $,
  objectMap: () => Ze,
  octave: () => Ni,
  octaveR: () => Ji,
  octaves: () => ec,
  octer: () => Ic,
  octersub: () => Hc,
  octersubsub: () => Vc,
  off: () => Jp,
  offset: () => tc,
  often: () => Wh,
  or: () => Vl,
  orbit: () => Wi,
  oschost: () => na,
  oscport: () => sa,
  outerBind: () => wl,
  outside: () => yp,
  overgain: () => $i,
  overshape: () => Ri,
  pace: () => kn,
  pairs: () => Ie,
  palindrome: () => $p,
  pan: () => Li,
  panchor: () => ki,
  panorient: () => Fi,
  panspan: () => Ii,
  pansplay: () => Hi,
  panwidth: () => Vi,
  parseFractional: () => Le,
  parseNumeral: () => Qt,
  partials: () => tu,
  patt: () => hi,
  pattack: () => fi,
  pcurve: () => vi,
  pdec: () => mi,
  pdecay: () => di,
  penv: () => _i,
  perlin: () => Ch,
  perlinWith: () => ka,
  ph: () => $r,
  phasdp: () => Gr,
  phaser: () => Rr,
  phasercenter: () => Hr,
  phaserdepth: () => Fr,
  phaserrate: () => Wr,
  phasersweep: () => Lr,
  phc: () => Vr,
  phd: () => Dr,
  phs: () => Ir,
  pick: () => Sa,
  pickF: () => Dh,
  pickOut: () => Qh,
  pickReset: () => Yh,
  pickRestart: () => Kh,
  pickSqueeze: () => ed,
  pickmod: () => Ca,
  pickmodF: () => Gh,
  pickmodOut: () => Uh,
  pickmodReset: () => Zh,
  pickmodRestart: () => Xh,
  pickmodSqueeze: () => sd,
  pipe: () => Re,
  pitchJump: () => qu,
  pitchJumpTime: () => Au,
  ply: () => ap,
  plyForEach: () => Kp,
  plyWith: () => Up,
  pm: () => cl,
  polyBind: () => _l,
  polyTouch: () => ea,
  polymeter: () => xt,
  polyrhythm: () => ol,
  postgain: () => Ms,
  pow: () => Bl,
  pr: () => il,
  prel: () => bi,
  prelease: () => gi,
  press: () => Wp,
  pressBy: () => Np,
  progNum: () => Uu,
  psus: () => wi,
  psustain: () => yi,
  pure: () => z,
  pw: () => Jr,
  pwrate: () => jr,
  pwsweep: () => Nr,
  rand: () => L,
  rand2: () => gh,
  randcat: () => Ah,
  randrun: () => ya,
  range: () => Xl,
  range2: () => Zl,
  rangex: () => Yl,
  rarely: () => $h,
  rate: () => Di,
  ratio: () => tp,
  rdim: () => cc,
  real: () => Xc,
  ref: () => Ff,
  register: () => l,
  registerControl: () => i,
  reify: () => d,
  rel: () => nr,
  release: () => er,
  removeUndefineds: () => it,
  repeatCycles: () => tf,
  repeatTime: () => Tu,
  repl: () => cd,
  replicate: () => vf,
  resonance: () => Vo,
  rev: () => gn,
  rfade: () => ac,
  rib: () => mf,
  ribbon: () => df,
  ring: () => Fc,
  ringdf: () => Gc,
  ringf: () => Dc,
  rlp: () => oc,
  room: () => sc,
  roomdim: () => ic,
  roomfade: () => uc,
  roomlp: () => rc,
  roomsize: () => dc,
  rotate: () => $e,
  round: () => Dl,
  rsize: () => wc,
  run: () => da,
  s: () => Rn,
  s_add: () => Bf,
  s_alt: () => Sf,
  s_cat: () => Af,
  s_contract: () => Mf,
  s_expand: () => zf,
  s_extend: () => Ef,
  s_polymeter: () => Tf,
  s_sub: () => Of,
  s_taper: () => Cf,
  s_taperlist: () => xf,
  s_tour: () => Pf,
  s_zip: () => Jf,
  saw: () => mt,
  saw2: () => ce,
  scram: () => su,
  scramble: () => wh,
  scrub: () => oa,
  seconds: () => pu,
  seg: () => Bp,
  segment: () => xp,
  semitone: () => Qi,
  seq: () => yn,
  seqPLoop: () => ll,
  sequence: () => G,
  sequenceP: () => fn,
  set: () => vl,
  setStringParser: () => nl,
  setTime: () => Ft,
  shape: () => gc,
  shrink: () => zn,
  shrinklist: () => On,
  shuffle: () => yh,
  signal: () => I,
  silence: () => v,
  sine: () => aa,
  sine2: () => ae,
  size: () => mc,
  slice: () => Jn,
  slide: () => Gi,
  slow: () => hp,
  slowChunk: () => sf,
  slowcat: () => K,
  slowcatPrime: () => Zt,
  slowchunk: () => nf,
  smear: () => nu,
  sol2note: () => Ua,
  someCycles: () => Nh,
  someCyclesBy: () => jh,
  sometimes: () => Jh,
  sometimesBy: () => Ph,
  songPtr: () => fu,
  sound: () => Ln,
  source: () => Ts,
  sparsity: () => dp,
  speak: () => od,
  speed: () => ne,
  splice: () => $f,
  splitAt: () => Kt,
  spread: () => ii,
  square: () => la,
  square2: () => ih,
  squeeze: () => rd,
  squeezeBind: () => gl,
  squiz: () => Oc,
  src: () => Cs,
  stack: () => B,
  stackBy: () => ul,
  stackCentre: () => mn,
  stackLeft: () => hn,
  stackRight: () => dn,
  steady: () => sh,
  stepBind: () => bl,
  stepalt: () => An,
  stepcat: () => N,
  steps: () => jf,
  stepsPerOctave: () => Pi,
  stretch: () => xc,
  striate: () => Wf,
  stringifyValues: () => Xt,
  struct: () => fl,
  strudelScope: () => Ba,
  stut: () => Qp,
  stutWith: () => Fp,
  stutwith: () => Dp,
  sub: () => Sl,
  superimpose: () => hl,
  sus: () => tr,
  sustain: () => Zs,
  sustainpedal: () => Jc,
  swing: () => zp,
  swingBy: () => Op,
  sysex: () => Ku,
  sysexdata: () => Yu,
  sysexid: () => Xu,
  sz: () => yc,
  take: () => Sn,
  time: () => le,
  timeCat: () => Pn,
  timecat: () => qf,
  toBipolar: () => Ul,
  tokenizeNote: () => ze,
  tour: () => En,
  tremolo: () => gr,
  tremolodepth: () => _r,
  tremolophase: () => kr,
  tremoloshape: () => qr,
  tremoloskew: () => vr,
  tremolosync: () => br,
  tri: () => ch,
  tri2: () => uh,
  triode: () => $c,
  tsdelay: () => Kc,
  uid: () => hu,
  undegrade: () => Mh,
  undegradeBy: () => Eh,
  unicodeToBase64: () => Xe,
  uniq: () => Ka,
  uniqsort: () => Xa,
  uniqsortr: () => Ke,
  unison: () => oi,
  unit: () => Bc,
  v: () => Jo,
  val: () => du,
  valueToMidi: () => Ra,
  velocity: () => zs,
  vib: () => Mo,
  vibmod: () => No,
  vibrato: () => Po,
  vmod: () => Wo,
  voice: () => Ui,
  vowel: () => zc,
  warp: () => os,
  warpatt: () => us,
  warpattack: () => cs,
  warpdc: () => gs,
  warpdec: () => ls,
  warpdecay: () => as,
  warpdepth: () => ys,
  warpenv: () => As,
  warpmode: () => _s,
  warprate: () => ms,
  warprel: () => ds,
  warprelease: () => hs,
  warpshape: () => ws,
  warpskew: () => bs,
  warpsus: () => fs,
  warpsustain: () => ps,
  warpsync: () => Ss,
  waveloss: () => Ec,
  wavetablePhaseRand: () => qs,
  wavetablePosition: () => Hn,
  wavetableWarp: () => is,
  wavetableWarpMode: () => vs,
  wchoose: () => Sh,
  wchooseCycles: () => _a,
  when: () => Pp,
  whenKey: () => Vh,
  withValue: () => dl,
  within: () => _f,
  wrandcat: () => Th,
  wt: () => In,
  wtatt: () => Dn,
  wtattack: () => Fn,
  wtdc: () => ss,
  wtdec: () => Qn,
  wtdecay: () => Gn,
  wtdepth: () => es,
  wtenv: () => Vn,
  wtphaserand: () => ks,
  wtrate: () => Zn,
  wtrel: () => Yn,
  wtrelease: () => Xn,
  wtshape: () => ns,
  wtskew: () => rs,
  wtsus: () => Kn,
  wtsustain: () => Un,
  wtsync: () => ts,
  xfade: () => jn,
  xsdelay: () => Uc,
  zcrush: () => Bu,
  zdelay: () => Ou,
  zip: () => Mn,
  zipWith: () => At,
  zmod: () => xu,
  znoise: () => Cu,
  zoom: () => qp,
  zoomArc: () => Ap,
  zoomarc: () => Sp,
  zrand: () => _u,
  zzfx: () => zu
});

// node_modules/fraction.js/dist/fraction.mjs
if (typeof BigInt === "undefined") BigInt = function(n) {
  if (isNaN(n)) throw new Error("");
  return n;
};
var C_ZERO = BigInt(0);
var C_ONE = BigInt(1);
var C_TWO = BigInt(2);
var C_THREE = BigInt(3);
var C_FIVE = BigInt(5);
var C_TEN = BigInt(10);
var MAX_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
var MAX_CYCLE_LEN = 2e3;
var P = {
  "s": C_ONE,
  "n": C_ZERO,
  "d": C_ONE
};
function assign(n, s) {
  try {
    n = BigInt(n);
  } catch (e) {
    throw InvalidParameter();
  }
  return n * s;
}
function ifloor(x2) {
  return typeof x2 === "bigint" ? x2 : Math.floor(x2);
}
function newFraction(n, d2) {
  if (d2 === C_ZERO) {
    throw DivisionByZero();
  }
  const f2 = Object.create(Fraction.prototype);
  f2["s"] = n < C_ZERO ? -C_ONE : C_ONE;
  n = n < C_ZERO ? -n : n;
  const a = gcd(n, d2);
  f2["n"] = n / a;
  f2["d"] = d2 / a;
  return f2;
}
var FACTORSTEPS = [C_TWO * C_TWO, C_TWO, C_TWO * C_TWO, C_TWO, C_TWO * C_TWO, C_TWO * C_THREE, C_TWO, C_TWO * C_THREE];
function factorize(n) {
  const factors = /* @__PURE__ */ Object.create(null);
  if (n <= C_ONE) {
    factors[n] = C_ONE;
    return factors;
  }
  const add = (p) => {
    factors[p] = (factors[p] || C_ZERO) + C_ONE;
  };
  while (n % C_TWO === C_ZERO) {
    add(C_TWO);
    n /= C_TWO;
  }
  while (n % C_THREE === C_ZERO) {
    add(C_THREE);
    n /= C_THREE;
  }
  while (n % C_FIVE === C_ZERO) {
    add(C_FIVE);
    n /= C_FIVE;
  }
  for (let si2 = 0, p = C_TWO + C_FIVE; p * p <= n; ) {
    while (n % p === C_ZERO) {
      add(p);
      n /= p;
    }
    p += FACTORSTEPS[si2];
    si2 = si2 + 1 & 7;
  }
  if (n > C_ONE) add(n);
  return factors;
}
var parse = function(p1, p2) {
  let n = C_ZERO, d2 = C_ONE, s = C_ONE;
  if (p1 === void 0 || p1 === null) {
  } else if (p2 !== void 0) {
    if (typeof p1 === "bigint") {
      n = p1;
    } else if (isNaN(p1)) {
      throw InvalidParameter();
    } else if (p1 % 1 !== 0) {
      throw NonIntegerParameter();
    } else {
      n = BigInt(p1);
    }
    if (typeof p2 === "bigint") {
      d2 = p2;
    } else if (isNaN(p2)) {
      throw InvalidParameter();
    } else if (p2 % 1 !== 0) {
      throw NonIntegerParameter();
    } else {
      d2 = BigInt(p2);
    }
    s = n * d2;
  } else if (typeof p1 === "object") {
    if ("d" in p1 && "n" in p1) {
      n = BigInt(p1["n"]);
      d2 = BigInt(p1["d"]);
      if ("s" in p1)
        n *= BigInt(p1["s"]);
    } else if (0 in p1) {
      n = BigInt(p1[0]);
      if (1 in p1)
        d2 = BigInt(p1[1]);
    } else if (typeof p1 === "bigint") {
      n = p1;
    } else {
      throw InvalidParameter();
    }
    s = n * d2;
  } else if (typeof p1 === "number") {
    if (isNaN(p1)) {
      throw InvalidParameter();
    }
    if (p1 < 0) {
      s = -C_ONE;
      p1 = -p1;
    }
    if (p1 % 1 === 0) {
      n = BigInt(p1);
    } else {
      let z2 = 1;
      let A = 0, B2 = 1;
      let C2 = 1, D2 = 1;
      let N2 = 1e7;
      if (p1 >= 1) {
        z2 = 10 ** Math.floor(1 + Math.log10(p1));
        p1 /= z2;
      }
      while (B2 <= N2 && D2 <= N2) {
        let M = (A + C2) / (B2 + D2);
        if (p1 === M) {
          if (B2 + D2 <= N2) {
            n = A + C2;
            d2 = B2 + D2;
          } else if (D2 > B2) {
            n = C2;
            d2 = D2;
          } else {
            n = A;
            d2 = B2;
          }
          break;
        } else {
          if (p1 > M) {
            A += C2;
            B2 += D2;
          } else {
            C2 += A;
            D2 += B2;
          }
          if (B2 > N2) {
            n = C2;
            d2 = D2;
          } else {
            n = A;
            d2 = B2;
          }
        }
      }
      n = BigInt(n) * BigInt(z2);
      d2 = BigInt(d2);
    }
  } else if (typeof p1 === "string") {
    let ndx = 0;
    let v2 = C_ZERO, w2 = C_ZERO, x2 = C_ZERO, y = C_ONE, z2 = C_ONE;
    let match = p1.replace(/_/g, "").match(/\d+|./g);
    if (match === null)
      throw InvalidParameter();
    if (match[ndx] === "-") {
      s = -C_ONE;
      ndx++;
    } else if (match[ndx] === "+") {
      ndx++;
    }
    if (match.length === ndx + 1) {
      w2 = assign(match[ndx++], s);
    } else if (match[ndx + 1] === "." || match[ndx] === ".") {
      if (match[ndx] !== ".") {
        v2 = assign(match[ndx++], s);
      }
      ndx++;
      if (ndx + 1 === match.length || match[ndx + 1] === "(" && match[ndx + 3] === ")" || match[ndx + 1] === "'" && match[ndx + 3] === "'") {
        w2 = assign(match[ndx], s);
        y = C_TEN ** BigInt(match[ndx].length);
        ndx++;
      }
      if (match[ndx] === "(" && match[ndx + 2] === ")" || match[ndx] === "'" && match[ndx + 2] === "'") {
        x2 = assign(match[ndx + 1], s);
        z2 = C_TEN ** BigInt(match[ndx + 1].length) - C_ONE;
        ndx += 3;
      }
    } else if (match[ndx + 1] === "/" || match[ndx + 1] === ":") {
      w2 = assign(match[ndx], s);
      y = assign(match[ndx + 2], C_ONE);
      ndx += 3;
    } else if (match[ndx + 3] === "/" && match[ndx + 1] === " ") {
      v2 = assign(match[ndx], s);
      w2 = assign(match[ndx + 2], s);
      y = assign(match[ndx + 4], C_ONE);
      ndx += 5;
    }
    if (match.length <= ndx) {
      d2 = y * z2;
      s = /* void */
      n = x2 + d2 * v2 + z2 * w2;
    } else {
      throw InvalidParameter();
    }
  } else if (typeof p1 === "bigint") {
    n = p1;
    s = p1;
    d2 = C_ONE;
  } else {
    throw InvalidParameter();
  }
  if (d2 === C_ZERO) {
    throw DivisionByZero();
  }
  P["s"] = s < C_ZERO ? -C_ONE : C_ONE;
  P["n"] = n < C_ZERO ? -n : n;
  P["d"] = d2 < C_ZERO ? -d2 : d2;
};
function modpow(b, e, m) {
  let r = C_ONE;
  for (; e > C_ZERO; b = b * b % m, e >>= C_ONE) {
    if (e & C_ONE) {
      r = r * b % m;
    }
  }
  return r;
}
function cycleLen(n, d2) {
  for (; d2 % C_TWO === C_ZERO; d2 /= C_TWO) {
  }
  for (; d2 % C_FIVE === C_ZERO; d2 /= C_FIVE) {
  }
  if (d2 === C_ONE)
    return C_ZERO;
  let rem = C_TEN % d2;
  let t = 1;
  for (; rem !== C_ONE; t++) {
    rem = rem * C_TEN % d2;
    if (t > MAX_CYCLE_LEN)
      return C_ZERO;
  }
  return BigInt(t);
}
function cycleStart(n, d2, len) {
  let rem1 = C_ONE;
  let rem2 = modpow(C_TEN, len, d2);
  for (let t = 0; t < 300; t++) {
    if (rem1 === rem2)
      return BigInt(t);
    rem1 = rem1 * C_TEN % d2;
    rem2 = rem2 * C_TEN % d2;
  }
  return 0;
}
function gcd(a, b) {
  if (!a)
    return b;
  if (!b)
    return a;
  while (1) {
    a %= b;
    if (!a)
      return b;
    b %= a;
    if (!b)
      return a;
  }
}
function Fraction(a, b) {
  parse(a, b);
  if (this instanceof Fraction) {
    a = gcd(P["d"], P["n"]);
    this["s"] = P["s"];
    this["n"] = P["n"] / a;
    this["d"] = P["d"] / a;
  } else {
    return newFraction(P["s"] * P["n"], P["d"]);
  }
}
var DivisionByZero = function() {
  return new Error("Division by Zero");
};
var InvalidParameter = function() {
  return new Error("Invalid argument");
};
var NonIntegerParameter = function() {
  return new Error("Parameters must be integer");
};
Fraction.prototype = {
  "s": C_ONE,
  "n": C_ZERO,
  "d": C_ONE,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  "abs": function() {
    return newFraction(this["n"], this["d"]);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  "neg": function() {
    return newFraction(-this["s"] * this["n"], this["d"]);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  "add": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  "sub": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  "mul": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * P["s"] * this["n"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  "div": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * P["s"] * this["n"] * P["d"],
      this["d"] * P["n"]
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  "clone": function() {
    return newFraction(this["s"] * this["n"], this["d"]);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   * Ex: new Fraction(20, 10).mod().equals(0) ? "is Integer"
   **/
  "mod": function(a, b) {
    if (a === void 0) {
      return newFraction(this["s"] * this["n"] % this["d"], C_ONE);
    }
    parse(a, b);
    if (C_ZERO === P["n"] * this["d"]) {
      throw DivisionByZero();
    }
    return newFraction(
      this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
      P["d"] * this["d"]
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  "gcd": function(a, b) {
    parse(a, b);
    return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  "lcm": function(a, b) {
    parse(a, b);
    if (P["n"] === C_ZERO && this["n"] === C_ZERO) {
      return newFraction(C_ZERO, C_ONE);
    }
    return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  "inverse": function() {
    return newFraction(this["s"] * this["d"], this["n"]);
  },
  /**
   * Calculates the fraction to some integer exponent
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  "pow": function(a, b) {
    parse(a, b);
    if (P["d"] === C_ONE) {
      if (P["s"] < C_ZERO) {
        return newFraction((this["s"] * this["d"]) ** P["n"], this["n"] ** P["n"]);
      } else {
        return newFraction((this["s"] * this["n"]) ** P["n"], this["d"] ** P["n"]);
      }
    }
    if (this["s"] < C_ZERO) return null;
    let N2 = factorize(this["n"]);
    let D2 = factorize(this["d"]);
    let n = C_ONE;
    let d2 = C_ONE;
    for (let k in N2) {
      if (k === "1") continue;
      if (k === "0") {
        n = C_ZERO;
        break;
      }
      N2[k] *= P["n"];
      if (N2[k] % P["d"] === C_ZERO) {
        N2[k] /= P["d"];
      } else return null;
      n *= BigInt(k) ** N2[k];
    }
    for (let k in D2) {
      if (k === "1") continue;
      D2[k] *= P["n"];
      if (D2[k] % P["d"] === C_ZERO) {
        D2[k] /= P["d"];
      } else return null;
      d2 *= BigInt(k) ** D2[k];
    }
    if (P["s"] < C_ZERO) {
      return newFraction(d2, n);
    }
    return newFraction(n, d2);
  },
  /**
   * Calculates the logarithm of a fraction to a given rational base
   *
   * Ex: new Fraction(27, 8).log(9, 4) => 3/2
   */
  "log": function(a, b) {
    parse(a, b);
    if (this["s"] <= C_ZERO || P["s"] <= C_ZERO) return null;
    const allPrimes = /* @__PURE__ */ Object.create(null);
    const baseFactors = factorize(P["n"]);
    const T1 = factorize(P["d"]);
    const numberFactors = factorize(this["n"]);
    const T2 = factorize(this["d"]);
    for (const prime in T1) {
      baseFactors[prime] = (baseFactors[prime] || C_ZERO) - T1[prime];
    }
    for (const prime in T2) {
      numberFactors[prime] = (numberFactors[prime] || C_ZERO) - T2[prime];
    }
    for (const prime in baseFactors) {
      if (prime === "1") continue;
      allPrimes[prime] = true;
    }
    for (const prime in numberFactors) {
      if (prime === "1") continue;
      allPrimes[prime] = true;
    }
    let retN = null;
    let retD = null;
    for (const prime in allPrimes) {
      const baseExponent = baseFactors[prime] || C_ZERO;
      const numberExponent = numberFactors[prime] || C_ZERO;
      if (baseExponent === C_ZERO) {
        if (numberExponent !== C_ZERO) {
          return null;
        }
        continue;
      }
      let curN = numberExponent;
      let curD = baseExponent;
      const gcdValue = gcd(curN, curD);
      curN /= gcdValue;
      curD /= gcdValue;
      if (retN === null && retD === null) {
        retN = curN;
        retD = curD;
      } else if (curN * retD !== retN * curD) {
        return null;
      }
    }
    return retN !== null && retD !== null ? newFraction(retN, retD) : null;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "equals": function(a, b) {
    parse(a, b);
    return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"];
  },
  /**
   * Check if this rational number is less than another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  "lt": function(a, b) {
    parse(a, b);
    return this["s"] * this["n"] * P["d"] < P["s"] * P["n"] * this["d"];
  },
  /**
   * Check if this rational number is less than or equal another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  "lte": function(a, b) {
    parse(a, b);
    return this["s"] * this["n"] * P["d"] <= P["s"] * P["n"] * this["d"];
  },
  /**
   * Check if this rational number is greater than another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  "gt": function(a, b) {
    parse(a, b);
    return this["s"] * this["n"] * P["d"] > P["s"] * P["n"] * this["d"];
  },
  /**
   * Check if this rational number is greater than or equal another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  "gte": function(a, b) {
    parse(a, b);
    return this["s"] * this["n"] * P["d"] >= P["s"] * P["n"] * this["d"];
  },
  /**
   * Compare two rational numbers
   * < 0 iff this < that
   * > 0 iff this > that
   * = 0 iff this = that
   *
   * Ex: new Fraction(19.6).compare([98, 5]);
   **/
  "compare": function(a, b) {
    parse(a, b);
    let t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
    return (C_ZERO < t) - (t < C_ZERO);
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  "ceil": function(places) {
    places = C_TEN ** BigInt(places || 0);
    return newFraction(
      ifloor(this["s"] * places * this["n"] / this["d"]) + (places * this["n"] % this["d"] > C_ZERO && this["s"] >= C_ZERO ? C_ONE : C_ZERO),
      places
    );
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  "floor": function(places) {
    places = C_TEN ** BigInt(places || 0);
    return newFraction(
      ifloor(this["s"] * places * this["n"] / this["d"]) - (places * this["n"] % this["d"] > C_ZERO && this["s"] < C_ZERO ? C_ONE : C_ZERO),
      places
    );
  },
  /**
   * Rounds a rational numbers
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  "round": function(places) {
    places = C_TEN ** BigInt(places || 0);
    return newFraction(
      ifloor(this["s"] * places * this["n"] / this["d"]) + this["s"] * ((this["s"] >= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * this["n"] % this["d"]) > this["d"] ? C_ONE : C_ZERO),
      places
    );
  },
  /**
    * Rounds a rational number to a multiple of another rational number
    *
    * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
    **/
  "roundTo": function(a, b) {
    parse(a, b);
    const n = this["n"] * P["d"];
    const d2 = this["d"] * P["n"];
    const r = n % d2;
    let k = ifloor(n / d2);
    if (r + r >= d2) {
      k++;
    }
    return newFraction(this["s"] * k * P["n"], P["d"]);
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  "divisible": function(a, b) {
    parse(a, b);
    if (P["n"] === C_ZERO) return false;
    return this["n"] * P["d"] % (P["n"] * this["d"]) === C_ZERO;
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  "valueOf": function() {
    return Number(this["s"] * this["n"]) / Number(this["d"]);
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  "toString": function(dec = 15) {
    let N2 = this["n"];
    let D2 = this["d"];
    let cycLen = cycleLen(N2, D2);
    let cycOff = cycleStart(N2, D2, cycLen);
    let str = this["s"] < C_ZERO ? "-" : "";
    str += ifloor(N2 / D2);
    N2 %= D2;
    N2 *= C_TEN;
    if (N2)
      str += ".";
    if (cycLen) {
      for (let i2 = cycOff; i2--; ) {
        str += ifloor(N2 / D2);
        N2 %= D2;
        N2 *= C_TEN;
      }
      str += "(";
      for (let i2 = cycLen; i2--; ) {
        str += ifloor(N2 / D2);
        N2 %= D2;
        N2 *= C_TEN;
      }
      str += ")";
    } else {
      for (let i2 = dec; N2 && i2--; ) {
        str += ifloor(N2 / D2);
        N2 %= D2;
        N2 *= C_TEN;
      }
    }
    return str;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
   **/
  "toFraction": function(showMixed = false) {
    let n = this["n"];
    let d2 = this["d"];
    let str = this["s"] < C_ZERO ? "-" : "";
    if (d2 === C_ONE) {
      str += n;
    } else {
      const whole = ifloor(n / d2);
      if (showMixed && whole > C_ZERO) {
        str += whole;
        str += " ";
        n %= d2;
      }
      str += n;
      str += "/";
      str += d2;
    }
    return str;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  "toLatex": function(showMixed = false) {
    let n = this["n"];
    let d2 = this["d"];
    let str = this["s"] < C_ZERO ? "-" : "";
    if (d2 === C_ONE) {
      str += n;
    } else {
      const whole = ifloor(n / d2);
      if (showMixed && whole > C_ZERO) {
        str += whole;
        n %= d2;
      }
      str += "\\frac{";
      str += n;
      str += "}{";
      str += d2;
      str += "}";
    }
    return str;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  "toContinued": function() {
    let a = this["n"];
    let b = this["d"];
    const res = [];
    while (b) {
      res.push(ifloor(a / b));
      const t = a % b;
      a = b;
      b = t;
    }
    return res;
  },
  "simplify": function(eps = 1e-3) {
    const ieps = BigInt(Math.ceil(1 / eps));
    const thisABS = this["abs"]();
    const cont = thisABS["toContinued"]();
    for (let i2 = 1; i2 < cont.length; i2++) {
      let s = newFraction(cont[i2 - 1], C_ONE);
      for (let k = i2 - 2; k >= 0; k--) {
        s = s["inverse"]()["add"](cont[k]);
      }
      let t = s["sub"](thisABS);
      if (t["n"] * ieps < t["d"]) {
        return s["mul"](this["s"]);
      }
    }
    return this;
  }
};

// node_modules/@strudel/core/dist/index.mjs
var Dt = "strudel.log";
var Oe = 1e3;
var Wt;
var $t;
function Gt(t, e = "cyclist") {
  console.error(t), E(`[${e}] error: ${t.message}`);
}
function E(t, e, n = {}) {
  let s = performance.now();
  Wt === t && s - $t < Oe || (Wt = t, $t = s, console.log(`%c${t}`, "background-color: black;color:white;border-radius:15px"), typeof document < "u" && typeof CustomEvent < "u" && document.dispatchEvent(
    new CustomEvent(Dt, {
      detail: {
        message: t,
        type: e,
        data: n
      }
    })
  ));
}
E.key = Dt;
var $a = (t) => /^[a-gA-G][#bs]*[0-9]$/.test(t);
var qt = (t) => /^[a-gA-G][#bsf]*-?[0-9]?$/.test(t);
var ze = (t) => {
  var _a2;
  if (typeof t != "string")
    return [];
  const [e, n = "", s] = ((_a2 = t.match(/^([a-gA-G])([#bsf]*)(-?[0-9]*)$/)) == null ? void 0 : _a2.slice(1)) || [];
  return e ? [e, n, s ? Number(s) : void 0] : [];
};
var Ee = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 };
var Me = { "#": 1, b: -1, s: 1, f: -1 };
var pt = (t, e = 3) => {
  const [n, s, r = e] = ze(t);
  if (!n)
    throw new Error('not a note: "' + t + '"');
  const o = Ee[n.toLowerCase()], c = (s == null ? void 0 : s.split("").reduce((u, a) => u + Me[a], 0)) || 0;
  return (Number(r) + 1) * 12 + o + c;
};
var nt = (t) => Math.pow(2, (t - 69) / 12) * 440;
var Pe = (t) => 12 * Math.log(t / 440) / Math.LN2 + 69;
var Ra = (t, e) => {
  if (typeof t != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: s } = t;
  if (typeof n == "number")
    return Pe(n);
  if (typeof s == "string")
    return pt(s);
  if (typeof s == "number")
    return s;
  if (!e)
    throw new Error("valueToMidi: expected freq or note to be set");
  return e;
};
var La = (t, e) => (t - e) * 1e3;
var Je = (t) => nt(typeof t == "number" ? t : pt(t));
var je = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
var Ia = (t) => {
  const e = Math.floor(t / 12) - 1;
  return je[t % 12] + e;
};
var ft = (t, e) => (t % e + e) % e;
var Ne = (t) => t.reduce((e, n) => e + n) / t.length;
function We(t, e = 0) {
  return isNaN(Number(t)) ? (E(`"${t}" is not a number, falling back to ${e}`, "warning"), e) : t;
}
var Ha = (t, e) => ft(Math.round(We(t ?? 0, 0)), e);
var Va = (t) => {
  let { value: e, context: n } = t, s = e;
  if (typeof s == "object" && !Array.isArray(s) && (s = s.note || s.n || s.value, s === void 0))
    throw new Error(`cannot find a playable note for ${JSON.stringify(e)}`);
  if (typeof s == "number" && n.type !== "frequency")
    s = nt(t.value);
  else if (typeof s == "number" && n.type === "frequency")
    s = t.value;
  else if (typeof s != "string" || !qt(s))
    throw new Error("not a note: " + JSON.stringify(s));
  return s;
};
var Fa = (t) => {
  let { value: e, context: n } = t;
  if (typeof e == "object")
    return e.freq ? e.freq : Je(e.note || e.n || e.value);
  if (typeof e == "number" && n.type !== "frequency")
    e = nt(t.value);
  else if (typeof e == "string" && qt(e))
    e = nt(pt(t.value));
  else if (typeof e != "number")
    throw new Error("not a note or frequency: " + e);
  return e;
};
var $e = (t, e) => t.slice(e).concat(t.slice(0, e));
var Re = (...t) => t.reduce(
  (e, n) => (...s) => e(n(...s)),
  (e) => e
);
var Da = (...t) => Re(...t.reverse());
var it = (t) => t.filter((e) => e != null);
var D = (t) => [].concat(...t);
var et = (t) => t;
var Ga = (t, e) => t;
var ht = (t, e) => Array.from({ length: e - t + 1 }, (n, s) => s + t);
function w(t, e, n = t.length) {
  const s = function r(...o) {
    if (o.length >= n)
      return t.apply(this, o);
    {
      const c = function(...u) {
        return r.apply(this, o.concat(u));
      };
      return e && e(c, o), c;
    }
  };
  return e && e(s, []), s;
}
function Qt(t) {
  const e = Number(t);
  if (!isNaN(e))
    return e;
  if (qt(t))
    return pt(t);
  throw new Error(`cannot parse as numeral: "${t}"`);
}
function Ut(t, e) {
  return (...n) => t(...n.map(e));
}
function $(t) {
  return Ut(t, Qt);
}
function Le(t) {
  const e = Number(t);
  if (!isNaN(e))
    return e;
  const n = {
    pi: Math.PI,
    w: 1,
    h: 0.5,
    q: 0.25,
    e: 0.125,
    s: 0.0625,
    t: 1 / 3,
    f: 0.2,
    x: 1 / 6
  }[t];
  if (typeof n < "u")
    return n;
  throw new Error(`cannot parse as fractional: "${t}"`);
}
var Qa = (t) => Ut(t, Le);
var Kt = function(t, e) {
  return [e.slice(0, t), e.slice(t)];
};
var At = (t, e, n) => e.map((s, r) => t(s, n[r]));
var Ie = function(t) {
  const e = [];
  for (let n = 0; n < t.length - 1; ++n)
    e.push([t[n], t[n + 1]]);
  return e;
};
var He = (t, e, n) => Math.min(Math.max(t, e), n);
var Ve = ["Do", "Reb", "Re", "Mib", "Mi", "Fa", "Solb", "Sol", "Lab", "La", "Sib", "Si"];
var Fe = [
  "Sa",
  "Re",
  "Ga",
  "Ma",
  "Pa",
  "Dha",
  "Ni"
];
var De = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Hb", "H"];
var Ge = [
  "Ni",
  "Pab",
  "Pa",
  "Voub",
  "Vou",
  "Ga",
  "Dib",
  "Di",
  "Keb",
  "Ke",
  "Zob",
  "Zo"
];
var Qe = [
  "I",
  "Ro",
  "Ha",
  "Ni",
  "Ho",
  "He",
  "To"
];
var Ue = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
var Ua = (t, e = "letters") => {
  const s = (e === "solfeggio" ? Ve : e === "indian" ? Fe : e === "german" ? De : e === "byzantine" ? Ge : e === "japanese" ? Qe : Ue)[t % 12], r = Math.floor(t / 12) - 1;
  return s + r;
};
function Ka(t) {
  var e = {};
  return t.filter(function(n) {
    return e.hasOwn(n) ? false : e[n] = true;
  });
}
function Xa(t) {
  return t.sort().filter(function(e, n, s) {
    return !n || e != s[n - 1];
  });
}
function Ke(t) {
  return t.sort((e, n) => e.compare(n)).filter(function(e, n, s) {
    return !n || e.ne(s[n - 1]);
  });
}
function Xe(t) {
  const e = new TextEncoder().encode(t);
  return btoa(String.fromCharCode(...e));
}
function Ye(t) {
  const e = new Uint8Array(
    atob(t).split("").map((s) => s.charCodeAt(0))
  );
  return new TextDecoder().decode(e);
}
function Ya(t) {
  return encodeURIComponent(Xe(t));
}
function Za(t) {
  return Ye(decodeURIComponent(t));
}
function Ze(t, e) {
  return Array.isArray(t) ? t.map(e) : Object.fromEntries(Object.entries(t).map(([n, s], r) => [n, e(s, n, r)]));
}
function Rt(t, e) {
  return t / e;
}
var tn = class {
  constructor({
    getTargetClockTime: e = en,
    weight: n = 16,
    offsetDelta: s = 5e-3,
    checkAfterTime: r = 2,
    resetAfterTime: o = 8
  }) {
    this.offsetTime, this.timeAtPrevOffsetSample, this.prevOffsetTimes = [], this.getTargetClockTime = e, this.weight = n, this.offsetDelta = s, this.checkAfterTime = r, this.resetAfterTime = o, this.reset = () => {
      this.prevOffsetTimes = [], this.offsetTime = null, this.timeAtPrevOffsetSample = null;
    };
  }
  calculateOffset(e) {
    const n = this.getTargetClockTime(), s = n - this.timeAtPrevOffsetSample, r = n - e;
    if (s > this.resetAfterTime && this.reset(), this.offsetTime == null && (this.offsetTime = r), this.prevOffsetTimes.push(r), this.prevOffsetTimes.length > this.weight && this.prevOffsetTimes.shift(), this.timeAtPrevOffsetSample == null || s > this.checkAfterTime) {
      this.timeAtPrevOffsetSample = n;
      const o = Ne(this.prevOffsetTimes);
      Math.abs(o - this.offsetTime) > this.offsetDelta && (this.offsetTime = o);
    }
    return this.offsetTime;
  }
  calculateTimestamp(e, n) {
    return this.calculateOffset(e) + n;
  }
};
function tl() {
  return performance.now() * 1e-3;
}
function en() {
  return Date.now() * 1e-3;
}
var nn = /* @__PURE__ */ new Map([
  ["control", "Control"],
  ["ctrl", "Control"],
  ["alt", "Alt"],
  ["shift", "Shift"],
  ["down", "ArrowDown"],
  ["up", "ArrowUp"],
  ["left", "ArrowLeft"],
  ["right", "ArrowRight"]
]);
var tt;
function sn() {
  if (tt == null) {
    if (typeof window > "u")
      return;
    tt = {}, window.addEventListener("keydown", (t) => {
      tt[t.key] = true;
    }), window.addEventListener("keyup", (t) => {
      tt[t.key] = false;
    });
  }
  return { ...tt };
}
function Xt(t, e = false) {
  return typeof t == "object" ? e ? JSON.stringify(t).slice(1, -1).replaceAll('"', "").replaceAll(",", " ") : JSON.stringify(t) : t;
}
Fraction.prototype.sam = function() {
  return this.floor();
};
Fraction.prototype.nextSam = function() {
  return this.sam().add(1);
};
Fraction.prototype.wholeCycle = function() {
  return new x(this.sam(), this.nextSam());
};
Fraction.prototype.cyclePos = function() {
  return this.sub(this.sam());
};
Fraction.prototype.lt = function(t) {
  return this.compare(t) < 0;
};
Fraction.prototype.gt = function(t) {
  return this.compare(t) > 0;
};
Fraction.prototype.lte = function(t) {
  return this.compare(t) <= 0;
};
Fraction.prototype.gte = function(t) {
  return this.compare(t) >= 0;
};
Fraction.prototype.eq = function(t) {
  return this.compare(t) == 0;
};
Fraction.prototype.ne = function(t) {
  return this.compare(t) != 0;
};
Fraction.prototype.max = function(t) {
  return this.gt(t) ? this : t;
};
Fraction.prototype.maximum = function(...t) {
  return t = t.map((e) => new Fraction(e)), t.reduce((e, n) => n.max(e), this);
};
Fraction.prototype.min = function(t) {
  return this.lt(t) ? this : t;
};
Fraction.prototype.mulmaybe = function(t) {
  return t !== void 0 ? this.mul(t) : void 0;
};
Fraction.prototype.divmaybe = function(t) {
  return t !== void 0 ? this.div(t) : void 0;
};
Fraction.prototype.addmaybe = function(t) {
  return t !== void 0 ? this.add(t) : void 0;
};
Fraction.prototype.submaybe = function(t) {
  return t !== void 0 ? this.sub(t) : void 0;
};
Fraction.prototype.show = function() {
  return this.s * this.n + "/" + this.d;
};
Fraction.prototype.or = function(t) {
  return this.eq(0) ? t : this;
};
var h = (t) => Fraction(t);
var rn = (...t) => {
  if (t = it(t), t.length !== 0)
    return t.reduce((e, n) => e.gcd(n), h(1));
};
var U = (...t) => {
  if (t = it(t), t.length === 0)
    return;
  const e = t.pop();
  return t.reduce(
    (n, s) => n === void 0 || s === void 0 ? void 0 : n.lcm(s),
    e
  );
};
var on = (t) => t instanceof Fraction;
h._original = Fraction;
var x = class _x {
  constructor(e, n) {
    this.begin = h(e), this.end = h(n);
  }
  get spanCycles() {
    const e = [];
    var n = this.begin;
    const s = this.end, r = s.sam();
    if (n.equals(s))
      return [new _x(n, s)];
    for (; s.gt(n); ) {
      if (n.sam().equals(r)) {
        e.push(new _x(n, this.end));
        break;
      }
      const o = n.nextSam();
      e.push(new _x(n, o)), n = o;
    }
    return e;
  }
  get duration() {
    return this.end.sub(this.begin);
  }
  cycleArc() {
    const e = this.begin.cyclePos(), n = e.add(this.duration);
    return new _x(e, n);
  }
  withTime(e) {
    return new _x(e(this.begin), e(this.end));
  }
  withEnd(e) {
    return new _x(this.begin, e(this.end));
  }
  withCycle(e) {
    const n = this.begin.sam(), s = n.add(e(this.begin.sub(n))), r = n.add(e(this.end.sub(n)));
    return new _x(s, r);
  }
  intersection(e) {
    const n = this.begin.max(e.begin), s = this.end.min(e.end);
    if (!n.gt(s) && !(n.equals(s) && (n.equals(this.end) && this.begin.lt(this.end) || n.equals(e.end) && e.begin.lt(e.end))))
      return new _x(n, s);
  }
  intersection_e(e) {
    const n = this.intersection(e);
    if (n == null)
      throw "TimeSpans do not intersect";
    return n;
  }
  midpoint() {
    return this.begin.add(this.duration.div(h(2)));
  }
  equals(e) {
    return this.begin.equals(e.begin) && this.end.equals(e.end);
  }
  show() {
    return this.begin.show() + " → " + this.end.show();
  }
};
var C = class _C {
  /*
        Event class, representing a value active during the timespan
        'part'. This might be a fragment of an event, in which case the
        timespan will be smaller than the 'whole' timespan, otherwise the
        two timespans will be the same. The 'part' must never extend outside of the
        'whole'. If the event represents a continuously changing value
        then the whole will be returned as None, in which case the given
        value will have been sampled from the point halfway between the
        start and end of the 'part' timespan.
        The context is to store a list of source code locations causing the event.
  
        The word 'Event' is more or less a reserved word in javascript, hence this
        class is named called 'Hap'.
        */
  constructor(e, n, s, r = {}, o = false) {
    this.whole = e, this.part = n, this.value = s, this.context = r, this.stateful = o, o && console.assert(typeof this.value == "function", "Stateful values must be functions");
  }
  get duration() {
    var _a2, _b;
    let e;
    return typeof ((_a2 = this.value) == null ? void 0 : _a2.duration) == "number" ? e = h(this.value.duration) : e = this.whole.end.sub(this.whole.begin), typeof ((_b = this.value) == null ? void 0 : _b.clip) == "number" ? e.mul(this.value.clip) : e;
  }
  get endClipped() {
    return this.whole.begin.add(this.duration);
  }
  isActive(e) {
    return this.whole.begin <= e && this.endClipped >= e;
  }
  isInPast(e) {
    return e > this.endClipped;
  }
  isInNearPast(e, n) {
    return n - e <= this.endClipped;
  }
  isInFuture(e) {
    return e < this.whole.begin;
  }
  isInNearFuture(e, n) {
    return n < this.whole.begin && n > this.whole.begin - e;
  }
  isWithinTime(e, n) {
    return this.whole.begin <= n && this.endClipped >= e;
  }
  wholeOrPart() {
    return this.whole ? this.whole : this.part;
  }
  withSpan(e) {
    const n = this.whole ? e(this.whole) : void 0;
    return new _C(n, e(this.part), this.value, this.context);
  }
  withValue(e) {
    return new _C(this.whole, this.part, e(this.value), this.context);
  }
  hasOnset() {
    return this.whole != null && this.whole.begin.equals(this.part.begin);
  }
  hasTag(e) {
    var _a2;
    return (_a2 = this.context.tags) == null ? void 0 : _a2.includes(e);
  }
  resolveState(e) {
    if (this.stateful && this.hasOnset()) {
      console.log("stateful");
      const n = this.value, [s, r] = n(e);
      return [s, new _C(this.whole, this.part, r, this.context, false)];
    }
    return [e, this];
  }
  spanEquals(e) {
    return this.whole == null && e.whole == null || this.whole.equals(e.whole);
  }
  equals(e) {
    return this.spanEquals(e) && this.part.equals(e.part) && // TODO would == be better ??
    this.value === e.value;
  }
  show(e = false) {
    const n = typeof this.value == "object" ? e ? JSON.stringify(this.value).slice(1, -1).replaceAll('"', "").replaceAll(",", " ") : JSON.stringify(this.value) : this.value;
    var s = "";
    if (this.whole == null)
      s = "~" + this.part.show;
    else {
      var r = this.whole.begin.equals(this.part.begin) && this.whole.end.equals(this.part.end);
      this.whole.begin.equals(this.part.begin) || (s = this.whole.begin.show() + " ⇜ "), r || (s += "("), s += this.part.show(), r || (s += ")"), this.whole.end.equals(this.part.end) || (s += " ⇝ " + this.whole.end.show());
    }
    return "[ " + s + " | " + n + " ]";
  }
  showWhole(e = false) {
    return `${this.whole == null ? "~" : this.whole.show()}: ${Xt(this.value, e)}`;
  }
  combineContext(e) {
    const n = this;
    return { ...n.context, ...e.context, locations: (n.context.locations || []).concat(e.context.locations || []) };
  }
  setContext(e) {
    return new _C(this.whole, this.part, this.value, e);
  }
  ensureObjectValue() {
    if (typeof this.value != "object")
      throw new Error(
        `expected hap.value to be an object, but got "${this.value}". Hint: append .note() or .s() to the end`,
        "error"
      );
  }
};
var st = class _st {
  constructor(e, n = {}) {
    this.span = e, this.controls = n;
  }
  // Returns new State with different span
  setSpan(e) {
    return new _st(e, this.controls);
  }
  withSpan(e) {
    return this.setSpan(e(this.span));
  }
  // Returns new State with added controls.
  setControls(e) {
    return new _st(this.span, { ...this.controls, ...e });
  }
};
function cn(t, e, n) {
  if ((e == null ? void 0 : e.value) !== void 0 && Object.keys(e).length === 1)
    return E("[warn]: Can't do arithmetic on control pattern."), t;
  const s = Object.keys(t).filter((r) => Object.keys(e).includes(r));
  return Object.assign({}, t, e, Object.fromEntries(s.map((r) => [r, n(t[r], e[r])])));
}
w((t, e) => t * e);
w((t, e) => e.map(t));
function un(t, e = 60) {
  let n = 0, s = h(0), r = [""], o = "";
  for (; r[0].length < e; ) {
    const c = t.queryArc(n, n + 1), u = c.filter((m) => m.hasOnset()).map((m) => m.duration), a = rn(...u), p = a.inverse();
    r = r.map((m) => m + "|"), o += "|";
    for (let m = 0; m < p; m++) {
      const [y, _] = [s, s.add(a)], g = c.filter((q) => q.whole.begin.lte(y) && q.whole.end.gte(_)), k = g.length - r.length;
      k > 0 && (r = r.concat(Array(k).fill(o))), r = r.map((q, M) => {
        const P2 = g[M];
        if (P2) {
          const T = P2.whole.begin.eq(y) ? "" + P2.value : "-";
          return q + T;
        }
        return q + ".";
      }), o += ".", s = s.add(a);
    }
    n++;
  }
  return r.join(`
`);
}
var _t;
var j = true;
var el = function(t) {
  j = !!t;
};
var nl = (t) => _t = t;
var f = class _f2 {
  /**
   * Create a pattern. As an end user, you will most likely not create a Pattern directly.
   *
   * @param {function} query - The function that maps a `State` to an array of `Hap`.
   * @noAutocomplete
   */
  constructor(e, n = void 0) {
    __publicField(this, "polyJoin", function() {
      const e = this;
      return e.fmap((n) => n.extend(e._steps.div(n._steps))).outerJoin();
    });
    this.query = e, this._Pattern = true, this._steps = n;
  }
  get _steps() {
    return this.__steps;
  }
  set _steps(e) {
    this.__steps = e === void 0 ? void 0 : h(e);
  }
  setSteps(e) {
    return this._steps = e, this;
  }
  withSteps(e) {
    return j ? new _f2(this.query, this._steps === void 0 ? void 0 : e(this._steps)) : this;
  }
  get hasSteps() {
    return this._steps !== void 0;
  }
  //////////////////////////////////////////////////////////////////////
  // Haskell-style functor, applicative and monadic operations
  /**
   * Returns a new pattern, with the function applied to the value of
   * each hap. It has the alias `fmap`.
   * @synonyms fmap
   * @param {Function} func to to apply to the value
   * @returns Pattern
   * @example
   * "0 1 2".withValue(v => v + 10).log()
   */
  withValue(e) {
    const n = new _f2((s) => this.query(s).map((r) => r.withValue(e)));
    return n._steps = this._steps, n;
  }
  // runs func on query state
  withState(e) {
    return new _f2((n) => this.query(e(n)));
  }
  /**
   * see `withValue`
   * @noAutocomplete
   */
  fmap(e) {
    return this.withValue(e);
  }
  /**
   * Assumes 'this' is a pattern of functions, and given a function to
   * resolve wholes, applies a given pattern of values to that
   * pattern of functions.
   * @param {Function} whole_func
   * @param {Function} func
   * @noAutocomplete
   * @returns Pattern
   */
  appWhole(e, n) {
    const s = this, r = function(o) {
      const c = s.query(o), u = n.query(o), a = function(p, m) {
        const y = p.part.intersection(m.part);
        if (y != null)
          return new C(
            e(p.whole, m.whole),
            y,
            p.value(m.value),
            m.combineContext(p)
          );
      };
      return D(
        c.map((p) => it(u.map((m) => a(p, m))))
      );
    };
    return new _f2(r);
  }
  /**
   * When this method is called on a pattern of functions, it matches its haps
   * with those in the given pattern of values.  A new pattern is returned, with
   * each matching value applied to the corresponding function.
   *
   * In this `_appBoth` variant, where timespans of the function and value haps
   * are not the same but do intersect, the resulting hap has a timespan of the
   * intersection. This applies to both the part and the whole timespan.
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appBoth(e) {
    const n = this, s = function(o, c) {
      if (!(o == null || c == null))
        return o.intersection_e(c);
    }, r = n.appWhole(s, e);
    return j && (r._steps = U(e._steps, n._steps)), r;
  }
  /**
   * As with `appBoth`, but the `whole` timespan is not the intersection,
   * but the timespan from the function of patterns that this method is called
   * on. In practice, this means that the pattern structure, including onsets,
   * are preserved from the pattern of functions (often referred to as the left
   * hand or inner pattern).
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appLeft(e) {
    const n = this, s = function(o) {
      const c = [];
      for (const u of n.query(o)) {
        const a = e.query(o.setSpan(u.wholeOrPart()));
        for (const p of a) {
          const m = u.whole, y = u.part.intersection(p.part);
          if (y) {
            const _ = u.value(p.value), g = p.combineContext(u), k = new C(m, y, _, g);
            c.push(k);
          }
        }
      }
      return c;
    }, r = new _f2(s);
    return r._steps = this._steps, r;
  }
  /**
   * As with `appLeft`, but `whole` timespans are instead taken from the
   * pattern of values, i.e. structure is preserved from the right hand/outer
   * pattern.
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appRight(e) {
    const n = this, s = function(o) {
      const c = [];
      for (const u of e.query(o)) {
        const a = n.query(o.setSpan(u.wholeOrPart()));
        for (const p of a) {
          const m = u.whole, y = p.part.intersection(u.part);
          if (y) {
            const _ = p.value(u.value), g = u.combineContext(p), k = new C(m, y, _, g);
            c.push(k);
          }
        }
      }
      return c;
    }, r = new _f2(s);
    return r._steps = e._steps, r;
  }
  bindWhole(e, n) {
    const s = this, r = function(o) {
      const c = function(a, p) {
        return new C(
          e(a.whole, p.whole),
          p.part,
          p.value,
          Object.assign({}, a.context, p.context, {
            locations: (a.context.locations || []).concat(p.context.locations || [])
          })
        );
      }, u = function(a) {
        return n(a.value).query(o.setSpan(a.part)).map((p) => c(a, p));
      };
      return D(s.query(o).map((a) => u(a)));
    };
    return new _f2(r);
  }
  bind(e) {
    const n = function(s, r) {
      if (!(s == null || r == null))
        return s.intersection_e(r);
    };
    return this.bindWhole(n, e);
  }
  join() {
    return this.bind(et);
  }
  outerBind(e) {
    return this.bindWhole((n) => n, e).setSteps(this._steps);
  }
  outerJoin() {
    return this.outerBind(et);
  }
  innerBind(e) {
    return this.bindWhole((n, s) => s, e);
  }
  innerJoin() {
    return this.innerBind(et);
  }
  // Flatterns patterns of patterns, by retriggering/resetting inner patterns at onsets of outer pattern haps
  resetJoin(e = false) {
    const n = this;
    return new _f2((s) => n.discreteOnly().query(s).map((r) => r.value.late(e ? r.whole.begin : r.whole.begin.cyclePos()).query(s).map(
      (o) => new C(
        // Supports continuous haps in the inner pattern
        o.whole ? o.whole.intersection(r.whole) : void 0,
        o.part.intersection(r.part),
        o.value
      ).setContext(r.combineContext(o))
    ).filter((o) => o.part)).flat());
  }
  restartJoin() {
    return this.resetJoin(true);
  }
  // Like the other joins above, joins a pattern of patterns of values, into a flatter
  // pattern of values. In this case it takes whole cycles of the inner pattern to fit each event
  // in the outer pattern.
  squeezeJoin() {
    const e = this;
    function n(s) {
      const r = e.discreteOnly().query(s);
      function o(u) {
        const p = u.value._focusSpan(u.wholeOrPart()).query(s.setSpan(u.part));
        function m(y, _) {
          let g;
          if (_.whole && y.whole && (g = _.whole.intersection(y.whole), !g))
            return;
          const k = _.part.intersection(y.part);
          if (!k)
            return;
          const q = _.combineContext(y);
          return new C(g, k, _.value, q);
        }
        return p.map((y) => m(u, y));
      }
      return D(r.map(o)).filter((u) => u);
    }
    return new _f2(n);
  }
  squeezeBind(e) {
    return this.fmap(e).squeezeJoin();
  }
  polyBind(e) {
    return this.fmap(e).polyJoin();
  }
  //////////////////////////////////////////////////////////////////////
  // Utility methods mainly for internal use
  /**
   * Query haps inside the given time span.
   *
   * @param {Fraction | number} begin from time
   * @param {Fraction | number} end to time
   * @returns Hap[]
   * @example
   * const pattern = sequence('a', ['b', 'c'])
   * const haps = pattern.queryArc(0, 1)
   * console.log(haps)
   * silence
   * @noAutocomplete
   */
  queryArc(e, n, s = {}) {
    try {
      return this.query(new st(new x(e, n), s));
    } catch (r) {
      return E(`[query]: ${r.message}`, "error"), [];
    }
  }
  /**
   * Returns a new pattern, with queries split at cycle boundaries. This makes
   * some calculations easier to express, as all haps are then constrained to
   * happen within a cycle.
   * @returns Pattern
   * @noAutocomplete
   */
  splitQueries() {
    const e = this, n = (s) => D(s.span.spanCycles.map((r) => e.query(s.setSpan(r))));
    return new _f2(n);
  }
  /**
   * Returns a new pattern, where the given function is applied to the query
   * timespan before passing it to the original pattern.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withQuerySpan(e) {
    return new _f2((n) => this.query(n.withSpan(e)));
  }
  withQuerySpanMaybe(e) {
    const n = this;
    return new _f2((s) => {
      const r = s.withSpan(e);
      return r.span ? n.query(r) : [];
    });
  }
  /**
   * As with `withQuerySpan`, but the function is applied to both the
   * begin and end time of the query timespan.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withQueryTime(e) {
    return new _f2((n) => this.query(n.withSpan((s) => s.withTime(e))));
  }
  /**
   * Similar to `withQuerySpan`, but the function is applied to the timespans
   * of all haps returned by pattern queries (both `part` timespans, and where
   * present, `whole` timespans).
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHapSpan(e) {
    return new _f2((n) => this.query(n).map((s) => s.withSpan(e)));
  }
  /**
   * As with `withHapSpan`, but the function is applied to both the
   * begin and end time of the hap timespans.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withHapTime(e) {
    return this.withHapSpan((n) => n.withTime(e));
  }
  /**
   * Returns a new pattern with the given function applied to the list of haps returned by every query.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHaps(e) {
    const n = new _f2((s) => e(this.query(s), s));
    return n._steps = this._steps, n;
  }
  /**
   * As with `withHaps`, but applies the function to every hap, rather than every list of haps.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHap(e) {
    return this.withHaps((n) => n.map(e));
  }
  /**
   * Returns a new pattern with the context field set to every hap set to the given value.
   * @param {*} context
   * @returns Pattern
   * @noAutocomplete
   */
  setContext(e) {
    return this.withHap((n) => n.setContext(e));
  }
  /**
   * Returns a new pattern with the given function applied to the context field of every hap.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withContext(e) {
    const n = this.withHap((s) => s.setContext(e(s.context)));
    return this.__pure !== void 0 && (n.__pure = this.__pure, n.__pure_loc = this.__pure_loc), n;
  }
  /**
   * Returns a new pattern with the context field of every hap set to an empty object.
   * @returns Pattern
   * @noAutocomplete
   */
  stripContext() {
    return this.withHap((e) => e.setContext({}));
  }
  /**
   * Returns a new pattern with the given location information added to the
   * context of every hap.
   * @param {Number} start start offset
   * @param {Number} end end offset
   * @returns Pattern
   * @noAutocomplete
   */
  withLoc(e, n) {
    const s = {
      start: e,
      end: n
    }, r = this.withContext((o) => {
      const c = (o.locations || []).concat([s]);
      return { ...o, locations: c };
    });
    return this.__pure && (r.__pure = this.__pure, r.__pure_loc = s), r;
  }
  /**
   * Returns a new Pattern, which only returns haps that meet the given test.
   * @param {Function} hap_test - a function which returns false for haps to be removed from the pattern
   * @returns Pattern
   * @noAutocomplete
   */
  filterHaps(e) {
    return new _f2((n) => this.query(n).filter(e));
  }
  /**
   * As with `filterHaps`, but the function is applied to values
   * inside haps.
   * @param {Function} value_test
   * @returns Pattern
   * @noAutocomplete
   */
  filterValues(e) {
    return new _f2((n) => this.query(n).filter((s) => e(s.value))).setSteps(this._steps);
  }
  /**
   * Returns a new pattern, with haps containing undefined values removed from
   * query results.
   * @returns Pattern
   * @noAutocomplete
   */
  removeUndefineds() {
    return this.filterValues((e) => e != null);
  }
  /**
   * Returns a new pattern, with all haps without onsets filtered out. A hap
   * with an onset is one with a `whole` timespan that begins at the same time
   * as its `part` timespan.
   * @returns Pattern
   * @noAutocomplete
   */
  onsetsOnly() {
    return this.filterHaps((e) => e.hasOnset());
  }
  /**
   * Returns a new pattern, with 'continuous' haps (those without 'whole'
   * timespans) removed from query results.
   * @returns Pattern
   * @noAutocomplete
   */
  discreteOnly() {
    return this.filterHaps((e) => e.whole);
  }
  /**
   * Combines adjacent haps with the same value and whole.  Only
   * intended for use in tests.
   * @noAutocomplete
   */
  defragmentHaps() {
    return this.discreteOnly().withHaps((n) => {
      const s = [];
      for (var r = 0; r < n.length; ++r) {
        for (var o = true, c = n[r]; o; ) {
          const p = JSON.stringify(n[r].value);
          for (var u = false, a = r + 1; a < n.length; a++) {
            const m = n[a];
            if (c.whole.equals(m.whole)) {
              if (c.part.begin.eq(m.part.end)) {
                if (p === JSON.stringify(m.value)) {
                  c = new C(c.whole, new x(m.part.begin, c.part.end), c.value), n.splice(a, 1), u = true;
                  break;
                }
              } else if (m.part.begin.eq(c.part.end) && p == JSON.stringify(m.value)) {
                c = new C(c.whole, new x(c.part.begin, m.part.end), c.value), n.splice(a, 1), u = true;
                break;
              }
            }
          }
          o = u;
        }
        s.push(c);
      }
      return s;
    });
  }
  /**
   * Queries the pattern for the first cycle, returning Haps. Mainly of use when
   * debugging a pattern.
   * @param {Boolean} with_context - set to true, otherwise the context field
   * will be stripped from the resulting haps.
   * @returns [Hap]
   * @noAutocomplete
   */
  firstCycle(e = false) {
    var n = this;
    return e || (n = n.stripContext()), n.query(new st(new x(h(0), h(1))));
  }
  /**
   * Accessor for a list of values returned by querying the first cycle.
   * @noAutocomplete
   */
  get firstCycleValues() {
    return this.firstCycle().map((e) => e.value);
  }
  /**
   * More human-readable version of the `firstCycleValues` accessor.
   * @noAutocomplete
   */
  get showFirstCycle() {
    return this.firstCycle().map(
      (e) => `${e.value}: ${e.whole.begin.toFraction()} - ${e.whole.end.toFraction()}`
    );
  }
  /**
   * Returns a new pattern, which returns haps sorted in temporal order. Mainly
   * of use when comparing two patterns for equality, in tests.
   * @returns Pattern
   * @noAutocomplete
   */
  sortHapsByPart() {
    return this.withHaps(
      (e) => e.sort(
        (n, s) => n.part.begin.sub(s.part.begin).or(n.part.end.sub(s.part.end)).or(n.whole.begin.sub(s.whole.begin).or(n.whole.end.sub(s.whole.end)))
      )
    );
  }
  asNumber() {
    return this.fmap(Qt);
  }
  //////////////////////////////////////////////////////////////////////
  // Operators - see 'make composers' later..
  _opIn(e, n) {
    return this.fmap(n).appLeft(d(e));
  }
  _opOut(e, n) {
    return this.fmap(n).appRight(d(e));
  }
  _opMix(e, n) {
    return this.fmap(n).appBoth(d(e));
  }
  _opSqueeze(e, n) {
    const s = d(e);
    return this.fmap((r) => s.fmap((o) => n(r)(o))).squeezeJoin();
  }
  _opSqueezeOut(e, n) {
    const s = this;
    return d(e).fmap((o) => s.fmap((c) => n(c)(o))).squeezeJoin();
  }
  _opReset(e, n) {
    return d(e).fmap((r) => this.fmap((o) => n(o)(r))).resetJoin();
  }
  _opRestart(e, n) {
    return d(e).fmap((r) => this.fmap((o) => n(o)(r))).restartJoin();
  }
  _opPoly(e, n) {
    const s = d(e);
    return this.fmap((r) => s.fmap((o) => n(o)(r))).polyJoin();
  }
  //////////////////////////////////////////////////////////////////////
  // End-user methods.
  // Those beginning with an underscore (_) are 'patternified',
  // i.e. versions are created without the underscore, that are
  // magically transformed to accept patterns for all their arguments.
  //////////////////////////////////////////////////////////////////////
  // Methods without corresponding toplevel functions
  /**
   * Layers the result of the given function(s). Like `superimpose`, but without the original pattern:
   * @name layer
   * @memberof Pattern
   * @synonyms apply
   * @returns Pattern
   * @example
   * "<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
   *   .layer(x=>x.add("0,2"))
   *   .scale('C minor').note()
   */
  layer(...e) {
    return B(...e.map((n) => n(this)));
  }
  /**
   * Superimposes the result of the given function(s) on top of the original pattern:
   * @name superimpose
   * @memberof Pattern
   * @returns Pattern
   * @example
   * "<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
   *   .superimpose(x=>x.add(2))
   *   .scale('C minor').note()
   */
  superimpose(...e) {
    return this.stack(...e.map((n) => n(this)));
  }
  //////////////////////////////////////////////////////////////////////
  // Multi-pattern functions
  stack(...e) {
    return B(this, ...e);
  }
  sequence(...e) {
    return G(this, ...e);
  }
  seq(...e) {
    return G(this, ...e);
  }
  cat(...e) {
    return at(this, ...e);
  }
  fastcat(...e) {
    return W(this, ...e);
  }
  slowcat(...e) {
    return K(this, ...e);
  }
  //////////////////////////////////////////////////////////////////////
  // Context methods - ones that deal with metadata
  onTrigger(e, n = true) {
    return this.withHap(
      (s) => s.setContext({
        ...s.context,
        onTrigger: (...r) => {
          var _a2, _b;
          (_b = (_a2 = s.context).onTrigger) == null ? void 0 : _b.call(_a2, ...r), e(...r);
        },
        // if dominantTrigger is set to true, the default output (webaudio) will be disabled
        // when using multiple triggers, you cannot flip this flag to false again!
        // example: x.csound('CooLSynth').log() as well as x.log().csound('CooLSynth') should work the same
        dominantTrigger: s.context.dominantTrigger || n
      })
    );
  }
  /**
   * Writes the content of the current event to the console (visible in the side menu).
   * @name log
   * @memberof Pattern
   * @example
   * s("bd sd").log()
   */
  log(e = (s) => `[hap] ${s.showWhole(true)}`, n = (s) => ({ hap: s })) {
    return this.onTrigger((...s) => {
      E(e(...s), void 0, n(...s));
    }, false);
  }
  /**
   * A simplified version of `log` which writes all "values" (various configurable parameters)
   * within the event to the console (visible in the side menu).
   * @name logValues
   * @memberof Pattern
   * @example
   * s("bd sd").gain("0.25 0.5 1").n("2 1 0").logValues()
   */
  logValues(e = (n) => `[hap] ${Xt(n, true)}`) {
    return this.log((n) => e(n.value));
  }
  //////////////////////////////////////////////////////////////////////
  // Visualisation
  drawLine() {
    return console.log(un(this)), this;
  }
  //////////////////////////////////////////////////////////////////////
  // methods relating to breaking patterns into subcycles
  // Breaks a pattern into a pattern of patterns, according to the structure of the given binary pattern.
  unjoin(e, n = et) {
    return e.withHap(
      (s) => s.withValue((r) => r ? n(this.ribbon(s.whole.begin, s.whole.duration)) : this)
    );
  }
  /**
   * Breaks a pattern into pieces according to the structure of a given pattern.
   * True values in the given pattern cause the corresponding subcycle of the
   * source pattern to be looped, and for an (optional) given function to be
   * applied. False values result in the corresponding part of the source pattern
   * to be played unchanged.
   * @name into
   * @memberof Pattern
   * @example
   * sound("bd sd ht lt").into("1 0", hurry(2))
   */
  into(e, n) {
    return this.unjoin(e, n).innerJoin();
  }
};
function an(t, e) {
  let n = [];
  return e.forEach((s) => {
    const r = n.findIndex(([o]) => t(s, o));
    r === -1 ? n.push([s]) : n[r].push(s);
  }), n;
}
var ln = (t, e) => t.spanEquals(e);
f.prototype.collect = function() {
  return this.withHaps(
    (t) => an(ln, t).map((e) => new C(e[0].whole, e[0].part, e, {}))
  );
};
var sl = l("arpWith", (t, e) => e.collect().fmap((n) => d(t(n))).innerJoin().withHap((n) => new C(n.whole, n.part, n.value.value, n.combineContext(n.value))));
var rl = l(
  "arp",
  (t, e) => e.arpWith((n) => d(t).fmap((s) => n[s % n.length])),
  false
);
function ut(t) {
  return !Array.isArray(t) && typeof t == "object" && !on(t);
}
function pn(t, e, n) {
  return ut(t) || ut(e) ? (ut(t) || (t = { value: t }), ut(e) || (e = { value: e }), cn(t, e, n)) : n(t, e);
}
(function() {
  const t = {
    set: [(n, s) => s],
    keep: [(n) => n],
    keepif: [(n, s) => s ? n : void 0],
    // numerical functions
    /**
     *
     * Assumes a pattern of numbers. Adds the given number to each item in the pattern.
     * @name add
     * @memberof Pattern
     * @example
     * // Here, the triad 0, 2, 4 is shifted by different amounts
     * n("0 2 4".add("<0 3 4 0>")).scale("C:major")
     * // Without add, the equivalent would be:
     * // n("<[0 2 4] [3 5 7] [4 6 8] [0 2 4]>").scale("C:major")
     * @example
     * // You can also use add with notes:
     * note("c3 e3 g3".add("<0 5 7 0>"))
     * // Behind the scenes, the notes are converted to midi numbers:
     * // note("48 52 55".add("<0 5 7 0>"))
     */
    add: [$((n, s) => n + s)],
    // support string concatenation
    /**
     *
     * Like add, but the given numbers are subtracted.
     * @name sub
     * @memberof Pattern
     * @example
     * n("0 2 4".sub("<0 1 2 3>")).scale("C4:minor")
     * // See add for more information.
     */
    sub: [$((n, s) => n - s)],
    /**
     *
     * Multiplies each number by the given factor.
     * @name mul
     * @memberof Pattern
     * @example
     * "<1 1.5 [1.66, <2 2.33>]>*4".mul(150).freq()
     */
    mul: [$((n, s) => n * s)],
    /**
     *
     * Divides each number by the given factor.
     * @name div
     * @memberof Pattern
     */
    div: [$((n, s) => n / s)],
    mod: [$(ft)],
    pow: [$(Math.pow)],
    log2: [$(Math.log2)],
    band: [$((n, s) => n & s)],
    bor: [$((n, s) => n | s)],
    bxor: [$((n, s) => n ^ s)],
    blshift: [$((n, s) => n << s)],
    brshift: [$((n, s) => n >> s)],
    // TODO - force numerical comparison if both look like numbers?
    lt: [(n, s) => n < s],
    gt: [(n, s) => n > s],
    lte: [(n, s) => n <= s],
    gte: [(n, s) => n >= s],
    eq: [(n, s) => n == s],
    eqt: [(n, s) => n === s],
    ne: [(n, s) => n != s],
    net: [(n, s) => n !== s],
    and: [(n, s) => n && s],
    or: [(n, s) => n || s],
    //  bitwise ops
    func: [(n, s) => s(n)]
  }, e = ["In", "Out", "Mix", "Squeeze", "SqueezeOut", "Reset", "Restart", "Poly"];
  for (const [n, [s, r]] of Object.entries(t)) {
    f.prototype["_" + n] = function(o) {
      return this.fmap((c) => s(c, o));
    }, Object.defineProperty(f.prototype, n, {
      // a getter that returns a function, so 'pat' can be
      // accessed by closures that are methods of that function..
      get: function() {
        const o = this, c = (...u) => o[n].in(...u);
        for (const u of e)
          c[u.toLowerCase()] = function(...a) {
            var p = o;
            a = G(a), r && (p = r(p), a = r(a));
            var m;
            return n === "keepif" ? (m = p["_op" + u](a, (y) => (_) => s(y, _)), m = m.removeUndefineds()) : m = p["_op" + u](a, (y) => (_) => pn(y, _, s)), m;
          };
        return c.squeezein = c.squeeze, c;
      }
    });
    for (const o of e)
      f.prototype[o.toLowerCase()] = function(...c) {
        return this.set[o.toLowerCase()](c);
      };
  }
  f.prototype.struct = function(...n) {
    return this.keepif.out(...n);
  }, f.prototype.structAll = function(...n) {
    return this.keep.out(...n);
  }, f.prototype.mask = function(...n) {
    return this.keepif.in(...n);
  }, f.prototype.maskAll = function(...n) {
    return this.keep.in(...n);
  }, f.prototype.reset = function(...n) {
    return this.keepif.reset(...n);
  }, f.prototype.resetAll = function(...n) {
    return this.keep.reset(...n);
  }, f.prototype.restart = function(...n) {
    return this.keepif.restart(...n);
  }, f.prototype.restartAll = function(...n) {
    return this.keep.restart(...n);
  };
})();
var ol = B;
var il = B;
var cl = xt;
var ct = (t) => new f(() => [], t);
var v = ct(1);
var R = ct(0);
function z(t) {
  function e(s) {
    return s.span.spanCycles.map((r) => new C(h(r.begin).wholeCycle(), r, t));
  }
  const n = new f(e, 1);
  return n.__pure = t, n;
}
function Yt(t) {
  return t instanceof f || (t == null ? void 0 : t._Pattern);
}
function d(t) {
  return Yt(t) ? t : _t && typeof t == "string" ? _t(t) : z(t);
}
function fn(t) {
  let e = z([]);
  for (const n of t)
    e = e.bind((s) => n.fmap((r) => s.concat([r])));
  return e;
}
function B(...t) {
  t = t.map((s) => Array.isArray(s) ? G(...s) : d(s));
  const e = (s) => D(t.map((r) => r.query(s))), n = new f(e);
  return j && (n._steps = U(...t.map((s) => s._steps))), n;
}
function St(t, e) {
  if (e = e.map((o) => Array.isArray(o) ? G(...o) : d(o)), e.length === 0)
    return v;
  if (e.length === 1)
    return e[0];
  const [n, ...s] = e.map((o) => o._steps), r = j ? n.maximum(...s) : void 0;
  return B(...t(r, e));
}
function hn(...t) {
  return St(
    (e, n) => n.map((s) => s._steps.eq(e) ? s : N(s, ct(e.sub(s._steps)))),
    t
  );
}
function dn(...t) {
  return St(
    (e, n) => n.map((s) => s._steps.eq(e) ? s : N(ct(e.sub(s._steps)), s)),
    t
  );
}
function mn(...t) {
  return St(
    (e, n) => n.map((s) => {
      if (s._steps.eq(e))
        return s;
      const r = ct(e.sub(s._steps).div(2));
      return N(r, s, r);
    }),
    t
  );
}
function ul(t, ...e) {
  const [n, ...s] = e.map((c) => c._steps), r = n.maximum(...s), o = {
    centre: mn,
    left: hn,
    right: dn,
    expand: B,
    repeat: (...c) => xt(...c).steps(r)
  };
  return t.inhabit(o).fmap((c) => c(...e)).innerJoin().setSteps(r);
}
function K(...t) {
  if (t = t.map((s) => Array.isArray(s) ? W(...s) : d(s)), t.length == 1)
    return t[0];
  const e = function(s) {
    const r = s.span, o = ft(r.begin.sam(), t.length), c = t[o];
    if (!c)
      return [];
    const u = r.begin.floor().sub(r.begin.div(t.length).floor());
    return c.withHapTime((a) => a.add(u)).query(s.setSpan(r.withTime((a) => a.sub(u))));
  }, n = j ? U(...t.map((s) => s._steps)) : void 0;
  return new f(e).splitQueries().setSteps(n);
}
function Zt(...t) {
  t = t.map(d);
  const e = function(n) {
    var _a2;
    const s = Math.floor(n.span.begin) % t.length;
    return ((_a2 = t[s]) == null ? void 0 : _a2.query(n)) || [];
  };
  return new f(e).splitQueries();
}
function at(...t) {
  return K(...t);
}
function al(...t) {
  const e = t.reduce((n, [s]) => n + s, 0);
  return t = t.map(([n, s]) => [n, s.fast(n)]), N(...t).slow(e);
}
function ll(...t) {
  let e = h(0);
  for (let n of t)
    n.length == 2 && n.unshift(e), e = n[1];
  return B(
    ...t.map(
      ([n, s, r]) => z(d(r)).compress(h(n).div(e), h(s).div(e))
    )
  ).slow(e).innerJoin();
}
function W(...t) {
  let e = K(...t);
  return t.length > 1 && (e = e._fast(t.length), e._steps = t.length), t.length == 1 && t[0].__steps_source && (t._steps = t[0]._steps), e;
}
function G(...t) {
  return W(...t);
}
function yn(...t) {
  return W(...t);
}
function vt(t) {
  return Array.isArray(t) ? t.length == 0 ? [v, 0] : t.length == 1 ? vt(t[0]) : [W(...t.map((e) => vt(e)[0])), t.length] : [d(t), 1];
}
var pl = w((t, e) => d(e).mask(t));
var fl = w((t, e) => d(e).struct(t));
var hl = w((t, e) => d(e).superimpose(...t));
var dl = w((t, e) => d(e).withValue(t));
var ml = w((t, e) => d(e).bind(t));
var yl = w((t, e) => d(e).innerBind(t));
var wl = w((t, e) => d(e).outerBind(t));
var gl = w((t, e) => d(e).squeezeBind(t));
var bl = w((t, e) => d(e).stepBind(t));
var _l = w((t, e) => d(e).polyBind(t));
var vl = w((t, e) => d(e).set(t));
var kl = w((t, e) => d(e).keep(t));
var ql = w((t, e) => d(e).keepif(t));
var Al = w((t, e) => d(e).add(t));
var Sl = w((t, e) => d(e).sub(t));
var Tl = w((t, e) => d(e).mul(t));
var Cl = w((t, e) => d(e).div(t));
var xl = w((t, e) => d(e).mod(t));
var Bl = w((t, e) => d(e).pow(t));
var Ol = w((t, e) => d(e).band(t));
var zl = w((t, e) => d(e).bor(t));
var El = w((t, e) => d(e).bxor(t));
var Ml = w((t, e) => d(e).blshift(t));
var Pl = w((t, e) => d(e).brshift(t));
var Jl = w((t, e) => d(e).lt(t));
var jl = w((t, e) => d(e).gt(t));
var Nl = w((t, e) => d(e).lte(t));
var Wl = w((t, e) => d(e).gte(t));
var $l = w((t, e) => d(e).eq(t));
var Rl = w((t, e) => d(e).eqt(t));
var Ll = w((t, e) => d(e).ne(t));
var Il = w((t, e) => d(e).net(t));
var Hl = w((t, e) => d(e).and(t));
var Vl = w((t, e) => d(e).or(t));
var Fl = w((t, e) => d(e).func(t));
function l(t, e, n = true, s = false, r = (o) => o.innerJoin()) {
  if (Array.isArray(t)) {
    const u = {};
    for (const a of t)
      u[a] = l(a, e, n, s, r);
    return u;
  }
  const o = e.length;
  var c;
  return n ? c = function(...u) {
    u = u.map(d);
    const a = u[u.length - 1];
    let p;
    if (o === 1)
      p = e(a);
    else {
      const m = u.slice(0, -1);
      if (m.every((y) => y.__pure != null)) {
        const y = m.map((g) => g.__pure), _ = m.filter((g) => g.__pure_loc).map((g) => g.__pure_loc);
        p = e(...y, a), p = p.withContext((g) => {
          const k = (g.locations || []).concat(_);
          return { ...g, locations: k };
        });
      } else {
        const [y, ..._] = m;
        let g = (...k) => e(...k, a);
        g = w(g, null, o - 1), p = r(_.reduce((k, q) => k.appLeft(q), y.fmap(g)));
      }
    }
    return s && (p._steps = a._steps), p;
  } : c = function(...u) {
    u = u.map(d);
    const a = e(...u);
    return s && (a._steps = u[u.length - 1]._steps), a;
  }, f.prototype[t] = function(...u) {
    if (o === 2 && u.length !== 1)
      u = [G(...u)];
    else if (o !== u.length + 1)
      throw new Error(`.${t}() expects ${o - 1} inputs but got ${u.length}.`);
    return u = u.map(d), c(...u, this);
  }, o > 1 && (f.prototype["_" + t] = function(...u) {
    const a = e(...u, this);
    return s && a.setSteps(this._steps), a;
  }), w(c, null, o);
}
function X(t, e, n = true, s = false, r = (o) => o.stepJoin()) {
  return l(t, e, n, s, r);
}
var Dl = l("round", function(t) {
  return t.asNumber().fmap((e) => Math.round(e));
});
var Gl = l("floor", function(t) {
  return t.asNumber().fmap((e) => Math.floor(e));
});
var Ql = l("ceil", function(t) {
  return t.asNumber().fmap((e) => Math.ceil(e));
});
var Ul = l("toBipolar", function(t) {
  return t.fmap((e) => e * 2 - 1);
});
var Kl = l("fromBipolar", function(t) {
  return t.fmap((e) => (e + 1) / 2);
});
var Xl = l("range", function(t, e, n) {
  return n.mul(e - t).add(t);
});
var Yl = l("rangex", function(t, e, n) {
  return n._range(Math.log(t), Math.log(e)).fmap(Math.exp);
});
var Zl = l("range2", function(t, e, n) {
  return n.fromBipolar()._range(t, e);
});
var tp = l(
  "ratio",
  (t) => t.fmap((e) => Array.isArray(e) ? e.slice(1).reduce((n, s) => n / s, e[0]) : e)
);
var ep = l("compress", function(t, e, n) {
  return t = h(t), e = h(e), t.gt(e) || t.gt(1) || e.gt(1) || t.lt(0) || e.lt(0) ? v : n._fastGap(h(1).div(e.sub(t)))._late(t);
});
var { compressSpan: np, compressspan: sp } = l(["compressSpan", "compressspan"], function(t, e) {
  return e._compress(t.begin, t.end);
});
var { fastGap: rp, fastgap: op } = l(["fastGap", "fastgap"], function(t, e) {
  const n = function(r) {
    const o = r.begin.sam(), c = r.begin.sub(o).mul(t).min(1), u = r.end.sub(o).mul(t).min(1);
    if (!(c >= 1))
      return new x(o.add(c), o.add(u));
  }, s = function(r) {
    const o = r.part.begin, c = r.part.end, u = o.sam(), a = o.sub(u).div(t).min(1), p = c.sub(u).div(t).min(1), m = new x(u.add(a), u.add(p)), y = r.whole ? new x(
      m.begin.sub(o.sub(r.whole.begin).div(t)),
      m.end.add(r.whole.end.sub(c).div(t))
    ) : void 0;
    return new C(y, m, r.value, r.context);
  };
  return e.withQuerySpanMaybe(n).withHap(s).splitQueries();
});
var ip = l("focus", function(t, e, n) {
  return t = h(t), e = h(e), n._early(t.sam())._fast(h(1).div(e.sub(t)))._late(t);
});
var { focusSpan: cp, focusspan: up } = l(["focusSpan", "focusspan"], function(t, e) {
  return e._focus(t.begin, t.end);
});
var ap = l("ply", function(t, e) {
  const n = e.fmap((s) => z(s)._fast(t)).squeezeJoin();
  return j && (n._steps = h(t).mulmaybe(e._steps)), n;
});
var { fast: lp, density: pp } = l(
  ["fast", "density"],
  function(t, e) {
    return t === 0 ? v : (t = h(t), e.withQueryTime((s) => s.mul(t)).withHapTime((s) => s.div(t)).setSteps(e._steps));
  },
  true,
  true
);
var fp = l("hurry", function(t, e) {
  return e._fast(t).mul(z({ speed: t }));
});
var { slow: hp, sparsity: dp } = l(["slow", "sparsity"], function(t, e) {
  return t === 0 ? v : e._fast(h(1).div(t));
});
var mp = l("inside", function(t, e, n) {
  return e(n._slow(t))._fast(t);
});
var yp = l("outside", function(t, e, n) {
  return e(n._fast(t))._slow(t);
});
var wp = l("lastOf", function(t, e, n) {
  const s = Array(t - 1).fill(n);
  return s.push(e(n)), Zt(...s);
});
var { firstOf: gp, every: bp } = l(["firstOf", "every"], function(t, e, n) {
  const s = Array(t - 1).fill(n);
  return s.unshift(e(n)), Zt(...s);
});
var _p = l("apply", function(t, e) {
  return t(e);
});
var vp = l("cpm", function(t, e) {
  return e._fast(t / 60 / 1);
});
var kp = l(
  "early",
  function(t, e) {
    return t = h(t), e.withQueryTime((n) => n.add(t)).withHapTime((n) => n.sub(t));
  },
  true,
  true
);
var wn = l(
  "late",
  function(t, e) {
    return t = h(t), e._early(h(0).sub(t));
  },
  true,
  true
);
var qp = l("zoom", function(t, e, n) {
  var _a2;
  if (e = h(e), t = h(t), t.gte(e))
    return R;
  const s = e.sub(t), r = j ? (_a2 = n._steps) == null ? void 0 : _a2.mulmaybe(s) : void 0;
  return n.withQuerySpan((o) => o.withCycle((c) => c.mul(s).add(t))).withHapSpan((o) => o.withCycle((c) => c.sub(t).div(s))).splitQueries().setSteps(r);
});
var { zoomArc: Ap, zoomarc: Sp } = l(["zoomArc", "zoomarc"], function(t, e) {
  return e.zoom(t.begin, t.end);
});
var Tp = l(
  "bite",
  (t, e, n) => e.fmap((s) => (r) => {
    const o = h(s).div(r).mod(1), c = o.add(h(1).div(r));
    return n.zoom(o, c);
  }).appLeft(t).squeezeJoin(),
  false
);
var Cp = l(
  "linger",
  function(t, e) {
    return t == 0 ? v : t < 0 ? e._zoom(t.add(1), 1)._slow(t) : e._zoom(0, t)._slow(t);
  },
  true,
  true
);
var { segment: xp, seg: Bp } = l(["segment", "seg"], function(t, e) {
  return e.struct(z(true)._fast(t)).setSteps(t);
});
var Op = l("swingBy", (t, e, n) => n.inside(e, wn(yn(0, t / 2))));
var zp = l("swing", (t, e) => e.swingBy(1 / 3, t));
var { invert: Ep, inv: Mp } = l(
  ["invert", "inv"],
  function(t) {
    return t.fmap((e) => !e);
  },
  true,
  true
);
var Pp = l("when", function(t, e, n) {
  return t ? e(n) : n;
});
var Jp = l("off", function(t, e, n) {
  return B(n, e(n.late(t)));
});
var jp = l("brak", function(t) {
  return t.when(K(false, true), (e) => W(e, v)._late(0.25));
});
var gn = l(
  "rev",
  function(t) {
    const e = function(n) {
      const s = n.span, r = s.begin.sam(), o = s.begin.nextSam(), c = function(a) {
        const p = a.withTime((y) => r.add(o.sub(y))), m = p.begin;
        return p.begin = p.end, p.end = m, p;
      };
      return t.query(n.setSpan(c(s))).map((a) => a.withSpan(c));
    };
    return new f(e).splitQueries();
  },
  false,
  true
);
var Np = l("pressBy", function(t, e) {
  return e.fmap((n) => z(n).compress(t, 1)).squeezeJoin();
});
var Wp = l("press", function(t) {
  return t._pressBy(0.5);
});
f.prototype.hush = function() {
  return v;
};
var $p = l(
  "palindrome",
  function(t) {
    return t.lastOf(2, gn);
  },
  true,
  true
);
var { juxBy: Rp, juxby: Lp } = l(["juxBy", "juxby"], function(t, e, n) {
  t /= 2;
  const s = function(c, u, a) {
    return u in c ? c[u] : a;
  }, r = n.withValue((c) => Object.assign({}, c, { pan: s(c, "pan", 0.5) - t })), o = e(n.withValue((c) => Object.assign({}, c, { pan: s(c, "pan", 0.5) + t })));
  return B(r, o).setSteps(j ? U(r._steps, o._steps) : void 0);
});
var Ip = l("jux", function(t, e) {
  return e._juxBy(1, t, e);
});
var { echoWith: Hp, echowith: Vp, stutWith: Fp, stutwith: Dp } = l(
  ["echoWith", "echowith", "stutWith", "stutwith"],
  function(t, e, n, s) {
    return B(...ht(0, t - 1).map((r) => n(s.late(h(e).mul(r)), r)));
  }
);
var Gp = l("echo", function(t, e, n, s) {
  return s._echoWith(t, e, (r, o) => r.gain(Math.pow(n, o)));
});
var Qp = l("stut", function(t, e, n, s) {
  return s._echoWith(t, n, (r, o) => r.gain(Math.pow(e, o)));
});
var bn = l("applyN", function(t, e, n) {
  let s = n;
  for (let r = 0; r < t; r++)
    s = e(s);
  return s;
});
var Up = l(["plyWith", "plywith"], function(t, e, n) {
  const s = n.fmap((r) => at(...ht(0, t - 1).map((o) => bn(o, e, r)))._fast(t)).squeezeJoin();
  return j && (s._steps = h(t).mulmaybe(n._steps)), s;
});
var Kp = l(["plyForEach", "plyforeach"], function(t, e, n) {
  const s = n.fmap((r) => at(at(z(r), ...ht(1, t - 1).map((o) => e(z(r), o))))._fast(t)).squeezeJoin();
  return j && (s._steps = h(t).mulmaybe(n._steps)), s;
});
var Tt = function(t, e, n = false) {
  return t = h(t), K(
    ...ht(0, t.sub(1)).map(
      (s) => n ? e.late(h(s).div(t)) : e.early(h(s).div(t))
    )
  );
};
var Xp = l(
  "iter",
  function(t, e) {
    return Tt(t, e, false);
  },
  true,
  true
);
var { iterBack: Yp, iterback: Zp } = l(
  ["iterBack", "iterback"],
  function(t, e) {
    return Tt(t, e, true);
  },
  true,
  true
);
var { repeatCycles: tf } = l(
  "repeatCycles",
  function(t, e) {
    return new f(function(n) {
      const s = n.span.begin.sam(), r = s.div(t).sam(), o = s.sub(r);
      return n = n.withSpan((c) => c.withTime((u) => u.sub(o))), e.query(n).map((c) => c.withSpan((u) => u.withTime((a) => a.add(o))));
    }).splitQueries();
  },
  true,
  true
);
var Ct = function(t, e, n, s = false, r = false) {
  const o = Array(t - 1).fill(false);
  o.unshift(true);
  const c = Tt(t, G(...o), !s);
  return r || (n = n.repeatCycles(t)), n.when(c, e);
};
var { chunk: ef, slowchunk: nf, slowChunk: sf } = l(
  ["chunk", "slowchunk", "slowChunk"],
  function(t, e, n) {
    return Ct(t, e, n, false, false);
  },
  true,
  true
);
var { chunkBack: rf, chunkback: of } = l(
  ["chunkBack", "chunkback"],
  function(t, e, n) {
    return Ct(t, e, n, true);
  },
  true,
  true
);
var { fastchunk: cf, fastChunk: uf } = l(
  ["fastchunk", "fastChunk"],
  function(t, e, n) {
    return Ct(t, e, n, false, true);
  },
  true,
  true
);
var { chunkinto: af, chunkInto: lf } = l(["chunkinto", "chunkInto"], function(t, e, n) {
  return n.into(W(true, ...Array(t - 1).fill(false))._iterback(t), e);
});
var { chunkbackinto: pf, chunkBackInto: ff } = l(["chunkbackinto", "chunkBackInto"], function(t, e, n) {
  return n.into(
    W(true, ...Array(t - 1).fill(false))._iter(t)._early(1),
    e
  );
});
var hf = l(
  "bypass",
  function(t, e) {
    return t = !!parseInt(t), t ? v : e;
  },
  true,
  true
);
var { ribbon: df, rib: mf } = l(
  ["ribbon", "rib"],
  (t, e, n) => n.early(t).restart(z(1).slow(e))
);
var yf = l("hsla", (t, e, n, s, r) => r.color(`hsla(${t}turn,${e * 100}%,${n * 100}%,${s})`));
var wf = l("hsl", (t, e, n, s) => s.color(`hsl(${t}turn,${e * 100}%,${n * 100}%)`));
f.prototype.tag = function(t) {
  return this.withContext((e) => ({ ...e, tags: (e.tags || []).concat([t]) }));
};
var gf = l("filter", (t, e) => e.withHaps((n) => n.filter(t)));
var bf = l("filterWhen", (t, e) => e.filter((n) => t(n.whole.begin)));
var _f = l(
  "within",
  (t, e, n, s) => B(
    n(s.filterWhen((r) => r.cyclePos() >= t && r.cyclePos() <= e)),
    s.filterWhen((r) => r.cyclePos() < t || r.cyclePos() > e)
  )
);
f.prototype.stepJoin = function() {
  const t = this, e = N(...Lt(It(t.queryArc(0, 1))))._steps, n = function(s) {
    const o = t.early(s.span.begin.sam()).query(s.setSpan(new x(h(0), h(1))));
    return N(...Lt(It(o))).query(s);
  };
  return new f(n, e);
};
f.prototype.stepBind = function(t) {
  return this.fmap(t).stepJoin();
};
function Lt(t) {
  const e = t.filter((o, c) => c.hasSteps).reduce((o, c) => o.add(c), h(0)), n = it(t.map((o, c) => c._steps)).reduce(
    (o, c) => o.add(c),
    h(0)
  ), s = e.eq(0) ? void 0 : n.div(e);
  function r(o, c) {
    return c._steps === void 0 ? [o.mulmaybe(s), c] : [c._steps, c];
  }
  return t.map((o) => r(...o));
}
function It(t) {
  const e = D(t.map((r) => [r.part.begin, r.part.end])), n = Ke([h(0), h(1), ...e]);
  return Ie(n).map((r) => [
    r[1].sub(r[0]),
    B(..._n(new x(...r), t).map((o) => o.value.withHap((c) => c.setContext(c.combineContext(o)))))
  ]);
}
function _n(t, e) {
  return it(e.map((n) => vn(t, n)));
}
function vn(t, e) {
  const n = t.intersection(e.part);
  if (n != null)
    return new C(e.whole, n, e.value, e.context);
}
var kn = l("pace", function(t, e) {
  return e._steps === void 0 ? e : e._steps.eq(h(0)) ? R : e._fast(h(t).div(e._steps)).setSteps(t);
});
function qn(t, ...e) {
  const n = e.map((r) => vt(r));
  if (n.length == 0)
    return v;
  t == 0 && (t = n[0][1]);
  const s = [];
  for (const r of n)
    r[1] != 0 && (t == r[1] ? s.push(r[0]) : s.push(r[0]._fast(h(t).div(h(r[1])))));
  return B(...s);
}
function xt(...t) {
  if (Array.isArray(t[0]))
    return qn(0, ...t);
  if (t = t.filter((s) => s.hasSteps), t.length == 0)
    return v;
  const e = U(...t.map((s) => s._steps));
  if (e.eq(h(0)))
    return R;
  const n = B(...t.map((s) => s.pace(e)));
  return n._steps = e, n;
}
function N(...t) {
  if (t.length === 0)
    return R;
  const e = (c) => Array.isArray(c) ? c : [c._steps ?? 1, c];
  if (t = t.map(e), t.find((c) => c[0] === void 0)) {
    const c = t.map((a) => a[0]).filter((a) => a !== void 0);
    if (c.length === 0)
      return W(...t.map((a) => a[1]));
    if (c.length === t.length)
      return R;
    const u = c.reduce((a, p) => a.add(p), h(0)).div(c.length);
    for (let a of t)
      a[0] === void 0 && (a[0] = u);
  }
  if (t.length == 1)
    return d(t[0][1]).withSteps((u) => t[0][0]);
  const n = t.map((c) => c[0]).reduce((c, u) => c.add(u), h(0));
  let s = h(0);
  const r = [];
  for (const [c, u] of t) {
    if (h(c).eq(0))
      continue;
    const a = s.add(c);
    r.push(d(u)._compress(s.div(n), a.div(n))), s = a;
  }
  const o = B(...r);
  return o._steps = n, o;
}
function An(...t) {
  t = t.map((r) => Array.isArray(r) ? r.map(d) : [d(r)]);
  const e = U(...t.map((r) => h(r.length)));
  let n = [];
  for (let r = 0; r < e; ++r)
    n.push(...t.map((o) => o.length == 0 ? v : o[r % o.length]));
  n = n.filter((r) => r.hasSteps && r._steps > 0);
  const s = n.reduce((r, o) => r.add(o._steps), h(0));
  return n = N(...n), n._steps = s, n;
}
var Sn = X("take", function(t, e) {
  if (!e.hasSteps || e._steps.lte(0) || (t = h(t), t.eq(0)))
    return R;
  const n = t < 0;
  n && (t = t.abs());
  const s = t.div(e._steps);
  return s.lte(0) ? R : s.gte(1) ? e : n ? e.zoom(h(1).sub(s), 1) : e.zoom(0, s);
});
var Tn = X("drop", function(t, e) {
  return e.hasSteps ? (t = h(t), t.lt(0) ? e.take(e._steps.add(t)) : e.take(h(0).sub(e._steps.sub(t)))) : R;
});
var Cn = X("extend", function(t, e) {
  return e.fast(t).expand(t);
});
var vf = X("replicate", function(t, e) {
  return e.repeatCycles(t).fast(t).expand(t);
});
var xn = X("expand", function(t, e) {
  return e.withSteps((n) => n.mul(h(t)));
});
var Bn = X("contract", function(t, e) {
  return e.withSteps((n) => n.div(h(t)));
});
f.prototype.shrinklist = function(t) {
  const e = this;
  if (!e.hasSteps)
    return [e];
  let [n, s] = Array.isArray(t) ? t : [t, e._steps];
  if (n = h(n), s === 0 || n === 0)
    return [e];
  const r = n > 0, o = [];
  if (r) {
    const c = h(1).div(e._steps).mul(n);
    for (let u = 0; u < s; ++u) {
      const a = c.mul(u);
      if (a.gt(1))
        break;
      o.push([a, 1]);
    }
  } else {
    n = h(0).sub(n);
    const c = h(1).div(e._steps).mul(n);
    for (let u = 0; u < s; ++u) {
      const a = h(1).sub(c.mul(u));
      if (a.lt(0))
        break;
      o.push([h(0), a]);
    }
  }
  return o.map((c) => e.zoom(...c));
};
var On = (t, e) => e.shrinklist(t);
var zn = l(
  "shrink",
  function(t, e) {
    if (!e.hasSteps)
      return R;
    const n = e.shrinklist(t), s = N(...n);
    return s._steps = n.reduce((r, o) => r.add(o._steps), h(0)), s;
  },
  true,
  false,
  (t) => t.stepJoin()
);
var kf = l(
  "grow",
  function(t, e) {
    if (!e.hasSteps)
      return R;
    const n = e.shrinklist(h(0).sub(t));
    n.reverse();
    const s = N(...n);
    return s._steps = n.reduce((r, o) => r.add(o._steps), h(0)), s;
  },
  true,
  false,
  (t) => t.stepJoin()
);
var En = function(t, ...e) {
  return t.tour(...e);
};
f.prototype.tour = function(...t) {
  return N(
    ...[].concat(
      ...t.map((e, n) => [...t.slice(0, t.length - n), this, ...t.slice(t.length - n)]),
      this,
      ...t
    )
  );
};
var Mn = function(...t) {
  t = t.filter((s) => s.hasSteps);
  const e = K(...t.map((s) => s._slow(s._steps))), n = U(...t.map((s) => s._steps));
  return e._fast(n).setSteps(n);
};
var qf = N;
var Pn = N;
var Af = N;
var Sf = An;
var Tf = xt;
f.prototype.s_polymeter = f.prototype.polymeter;
var Cf = zn;
f.prototype.s_taper = f.prototype.shrink;
var xf = On;
f.prototype.s_taperlist = f.prototype.shrinklist;
var Bf = Sn;
f.prototype.s_add = f.prototype.take;
var Of = Tn;
f.prototype.s_sub = f.prototype.drop;
var zf = xn;
f.prototype.s_expand = f.prototype.expand;
var Ef = Cn;
f.prototype.s_extend = f.prototype.extend;
var Mf = Bn;
f.prototype.s_contract = f.prototype.contract;
var Pf = En;
f.prototype.s_tour = f.prototype.tour;
var Jf = Mn;
f.prototype.s_zip = f.prototype.zip;
var jf = kn;
f.prototype.steps = f.prototype.pace;
var Nf = l("chop", function(t, e) {
  const s = Array.from({ length: t }, (c, u) => u).map((c) => ({ begin: c / t, end: (c + 1) / t })), r = function(c, u) {
    if ("begin" in c && "end" in c && c.begin !== void 0 && c.end !== void 0) {
      const a = c.end - c.begin;
      u = { begin: c.begin + u.begin * a, end: c.begin + u.end * a };
    }
    return Object.assign({}, c, u);
  }, o = function(c) {
    return G(s.map((u) => r(c, u)));
  };
  return e.squeezeBind(o).setSteps(j ? h(t).mulmaybe(e._steps) : void 0);
});
var Wf = l("striate", function(t, e) {
  const s = Array.from({ length: t }, (o, c) => c).map((o) => ({ begin: o / t, end: (o + 1) / t })), r = K(...s);
  return e.set(r)._fast(t).setSteps(j ? h(t).mulmaybe(e._steps) : void 0);
});
var te = function(t, e, n = 0.5) {
  return e.speed(1 / t * n).unit("c").slow(t);
};
var Jn = l(
  "slice",
  function(t, e, n) {
    return t.innerBind(
      (s) => e.outerBind(
        (r) => n.outerBind((o) => {
          o = o instanceof Object ? o : { s: o };
          const c = Array.isArray(s) ? s[r] : r / s, u = Array.isArray(s) ? s[r + 1] : (r + 1) / s;
          return z({ begin: c, end: u, _slices: s, ...o });
        })
      )
    ).setSteps(e._steps);
  },
  false
  // turns off auto-patternification
);
f.prototype.onTriggerTime = function(t) {
  return this.onTrigger((e, n, s, r) => {
    const o = r - n;
    window.setTimeout(() => {
      t(e);
    }, o * 1e3);
  }, false);
};
var $f = l(
  "splice",
  function(t, e, n) {
    const s = Jn(t, e, n);
    return new f((r) => {
      const o = r.controls._cps || 1;
      return s.query(r).map(
        (u) => u.withValue((a) => ({
          speed: o / a._slices / u.whole.duration * (a.speed || 1),
          unit: "c",
          ...a
        }))
      );
    }).setSteps(e._steps);
  },
  false
  // turns off auto-patternification
);
var { loopAt: Rf, loopat: Lf } = l(["loopAt", "loopat"], function(t, e) {
  const n = e._steps ? e._steps.div(t) : void 0;
  return new f((s) => te(t, e, s.controls._cps).query(s), n);
});
var If = l(
  "fit",
  (t) => t.withHaps(
    (e, n) => e.map(
      (s) => s.withValue((r) => {
        const o = ("end" in r ? r.end : 1) - ("begin" in r ? r.begin : 0);
        return {
          ...r,
          speed: (n.controls._cps || 1) / s.whole.duration * o,
          unit: "c"
        };
      })
    )
  )
);
var { loopAtCps: Hf, loopatcps: Vf } = l(["loopAtCps", "loopatcps"], function(t, e, n) {
  return te(t, n, e);
});
var Ff = (t) => z(1).withValue(() => d(t())).innerJoin();
var Ht = (t) => t < 0.5 ? 1 : 1 - (t - 0.5) / 0.5;
var jn = (t, e, n) => {
  e = d(e), t = d(t), n = d(n);
  let s = e.fmap((o) => ({ gain: Ht(o) })), r = e.fmap((o) => ({ gain: Ht(1 - o) }));
  return B(t.mul(s), n.mul(r));
};
f.prototype.xfade = function(t, e) {
  return jn(this, t, e);
};
var Nn = (t) => (e, n, s) => {
  e = h(e).mod(n), n = h(n);
  const r = e.div(n), o = e.add(1).div(n);
  return t(s.fmap((c) => z(c)._compress(r, o)));
};
var { beat: Df } = l(
  ["beat"],
  Nn((t) => t.innerJoin())
);
var ee = (t, e, n) => {
  n = h(n);
  const s = h(1).div(t.length), r = (u) => {
    const a = [];
    for (const [p, m] of u.entries())
      m && a.push([h(p).div(u.length), m]);
    return a;
  }, o = At(
    ([u, a], [p, m]) => {
      const y = n.mul(p - u).add(u), _ = y.add(s);
      return new x(y, _);
    },
    r(t),
    r(e)
  );
  function c(u) {
    const a = u.span.begin.sam(), p = u.span.cycleArc(), m = [];
    for (const y of o) {
      const _ = y.intersection(p);
      _ !== void 0 && m.push(
        new C(
          y.withTime((g) => g.add(a)),
          _.withTime((g) => g.add(a)),
          true
        )
      );
    }
    return m;
  }
  return new f(c).splitQueries();
};
var Gf = (t, e, n) => (t = d(t), e = d(e), n = d(n), t.innerBind((s) => e.innerBind((r) => n.innerBind((o) => ee(s, r, o)))));
var Wn = ["scurve", "soft", "hard", "cubic", "diode", "asym", "fold", "sinefold", "chebyshev"];
for (const t of Wn)
  f.prototype[t] = function(e) {
    const n = d(e).fmap((s) => Array.isArray(s) ? [...s, t] : [s, 1, t]);
    return this.distort(n);
  };
function Bt(t) {
  let e = Array.isArray(t);
  t = e ? t : [t];
  const n = t[0], s = (o) => {
    let c;
    if (typeof o == "object" && o.value !== void 0 && (c = { ...o }, o = o.value, delete c.value), e && Array.isArray(o)) {
      const u = c || {};
      return o.forEach((a, p) => {
        p < t.length && (u[t[p]] = a);
      }), u;
    } else return c ? (c[n] = o, c) : { [n]: o };
  }, r = function(o, c) {
    return c ? typeof o > "u" ? c.fmap(s) : c.set(d(o).withValue(s)) : d(o).withValue(s);
  };
  return f.prototype[n] = function(o) {
    return r(o, this);
  }, r;
}
var rt = /* @__PURE__ */ new Map();
function $n(t) {
  return rt.has(t);
}
function i(t, ...e) {
  const n = Array.isArray(t) ? t[0] : t;
  let s = {};
  return s[n] = Bt(t), rt.set(n, n), e.forEach((r) => {
    s[r] = s[n], rt.set(r, n), f.prototype[r] = f.prototype[n];
  }), s;
}
var { s: Rn, sound: Ln } = i(["s", "n", "gain"], "sound");
var { wt: In, wavetablePosition: Hn } = i("wt", "wavetablePosition");
var { wtenv: Vn } = i("wtenv");
var { wtattack: Fn, wtatt: Dn } = i("wtattack", "wtatt");
var { wtdecay: Gn, wtdec: Qn } = i("wtdecay", "wtdec");
var { wtsustain: Un, wtsus: Kn } = i("wtsustain", "wtsus");
var { wtrelease: Xn, wtrel: Yn } = i("wtrelease", "wtrel");
var { wtrate: Zn } = i("wtrate");
var { wtsync: ts } = i("wtsync");
var { wtdepth: es } = i("wtdepth");
var { wtshape: ns } = i("wtshape");
var { wtdc: ss } = i("wtdc");
var { wtskew: rs } = i("wtskew");
var { warp: os, wavetableWarp: is } = i("warp", "wavetableWarp");
var { warpattack: cs, warpatt: us } = i("warpattack", "warpatt");
var { warpdecay: as, warpdec: ls } = i("warpdecay", "warpdec");
var { warpsustain: ps, warpsus: fs } = i("warpsustain", "warpsus");
var { warprelease: hs, warprel: ds } = i("warprelease", "warprel");
var { warprate: ms } = i("warprate");
var { warpdepth: ys } = i("warpdepth");
var { warpshape: ws } = i("warpshape");
var { warpdc: gs } = i("warpdc");
var { warpskew: bs } = i("warpskew");
var { warpmode: _s, wavetableWarpMode: vs } = i("warpmode", "wavetableWarpMode");
var { wtphaserand: ks, wavetablePhaseRand: qs } = i("wtphaserand", "wavetablePhaseRand");
var { warpenv: As } = i("warpenv");
var { warpsync: Ss } = i("warpsync");
var { source: Ts, src: Cs } = i("source", "src");
var { n: xs } = i("n");
var { note: Bs } = i(["note", "n"]);
var { accelerate: Os } = i("accelerate");
var { velocity: zs } = i("velocity");
var { gain: Es } = i("gain");
var { postgain: Ms } = i("postgain");
var { amp: Ps } = i("amp");
var { attack: Js, att: js } = i("attack", "att");
var { fmh: Ns } = i(["fmh", "fmi"], "fmh");
var { fmi: Ws, fm: $s } = i(["fmi", "fmh"], "fm");
var { fmenv: Rs } = i("fmenv");
var { fmattack: Ls } = i("fmattack");
var { fmwave: Is } = i("fmwave");
var { fmdecay: Hs } = i("fmdecay");
var { fmsustain: Vs } = i("fmsustain");
var { fmrelease: Fs } = i("fmrelease");
var { fmvelocity: Ds } = i("fmvelocity");
var { bank: Gs } = i("bank");
var { chorus: Qs } = i("chorus");
var { analyze: Us } = i("analyze");
var { fft: Ks } = i("fft");
var { decay: Xs, dec: Ys } = i("decay", "dec");
var { sustain: Zs, sus: tr } = i("sustain", "sus");
var { release: er, rel: nr } = i("release", "rel");
var { hold: sr } = i("hold");
var { bandf: rr, bpf: or, bp: ir } = i(["bandf", "bandq", "bpenv"], "bpf", "bp");
var { bandq: cr, bpq: ur } = i("bandq", "bpq");
var { begin: ar } = i("begin");
var { end: lr } = i("end");
var { loop: pr } = i("loop");
var { loopBegin: fr, loopb: hr } = i("loopBegin", "loopb");
var { loopEnd: dr, loope: mr } = i("loopEnd", "loope");
var { crush: yr } = i("crush");
var { coarse: wr } = i("coarse");
var { tremolo: gr } = i(["tremolo", "tremolodepth", "tremoloskew", "tremolophase"], "trem");
var { tremolosync: br } = i(
  ["tremolosync", "tremolodepth", "tremoloskew", "tremolophase"],
  "tremsync"
);
var { tremolodepth: _r } = i("tremolodepth", "tremdepth");
var { tremoloskew: vr } = i("tremoloskew", "tremskew");
var { tremolophase: kr } = i("tremolophase", "tremphase");
var { tremoloshape: qr } = i("tremoloshape", "tremshape");
var { drive: Ar } = i("drive");
var { duck: Sr } = i("duckorbit", "duck");
var { duckdepth: Tr } = i("duckdepth");
var { duckonset: Cr } = i("duckonset", "duckons");
var { duckattack: xr } = i("duckattack", "duckatt");
var { byteBeatExpression: Br, bbexpr: Or } = i("byteBeatExpression", "bbexpr");
var { byteBeatStartTime: zr, bbst: Er } = i("byteBeatStartTime", "bbst");
var { channels: Mr, ch: Pr } = i("channels", "ch");
var { pw: Jr } = i(["pw", "pwrate", "pwsweep"]);
var { pwrate: jr } = i("pwrate");
var { pwsweep: Nr } = i("pwsweep");
var { phaserrate: Wr, ph: $r, phaser: Rr } = i(
  ["phaserrate", "phaserdepth", "phasercenter", "phasersweep"],
  "ph",
  "phaser"
);
var { phasersweep: Lr, phs: Ir } = i("phasersweep", "phs");
var { phasercenter: Hr, phc: Vr } = i("phasercenter", "phc");
var { phaserdepth: Fr, phd: Dr, phasdp: Gr } = i("phaserdepth", "phd", "phasdp");
var { channel: Qr } = i("channel");
var { cut: Ur } = i("cut");
var { cutoff: Kr, ctf: Xr, lpf: Yr, lp: Zr } = i(["cutoff", "resonance", "lpenv"], "ctf", "lpf", "lp");
var { lpenv: to, lpe: eo } = i("lpenv", "lpe");
var { hpenv: no, hpe: so } = i("hpenv", "hpe");
var { bpenv: ro, bpe: oo } = i("bpenv", "bpe");
var { lpattack: io, lpa: co } = i("lpattack", "lpa");
var { hpattack: uo, hpa: ao } = i("hpattack", "hpa");
var { bpattack: lo, bpa: po } = i("bpattack", "bpa");
var { lpdecay: fo, lpd: ho } = i("lpdecay", "lpd");
var { hpdecay: mo, hpd: yo } = i("hpdecay", "hpd");
var { bpdecay: wo, bpd: go } = i("bpdecay", "bpd");
var { lpsustain: bo, lps: _o } = i("lpsustain", "lps");
var { hpsustain: vo, hps: ko } = i("hpsustain", "hps");
var { bpsustain: qo, bps: Ao } = i("bpsustain", "bps");
var { lprelease: So, lpr: To } = i("lprelease", "lpr");
var { hprelease: Co, hpr: xo } = i("hprelease", "hpr");
var { bprelease: Bo, bpr: Oo } = i("bprelease", "bpr");
var { ftype: zo } = i("ftype");
var { fanchor: Eo } = i("fanchor");
var { vib: Mo, vibrato: Po, v: Jo } = i(["vib", "vibmod"], "vibrato", "v");
var { noise: jo } = i("noise");
var { vibmod: No, vmod: Wo } = i(["vibmod", "vib"], "vmod");
var { hcutoff: $o, hpf: Ro, hp: Lo } = i(["hcutoff", "hresonance", "hpenv"], "hpf", "hp");
var { hresonance: Io, hpq: Ho } = i("hresonance", "hpq");
var { resonance: Vo, lpq: Fo } = i("resonance", "lpq");
var { djf: Do } = i("djf");
var { delay: Go } = i(["delay", "delaytime", "delayfeedback"]);
var { delayfeedback: Qo, delayfb: Uo, dfb: Ko } = i("delayfeedback", "delayfb", "dfb");
var { delayspeed: Xo } = i("delayspeed");
var { delaytime: Yo, delayt: Zo, dt: ti } = i("delaytime", "delayt", "dt");
var { delaysync: ei } = i("delaysync");
var { lock: ni } = i("lock");
var { detune: si, det: ri } = i("detune", "det");
var { unison: oi } = i("unison");
var { spread: ii } = i("spread");
var { dry: ci } = i("dry");
var { fadeTime: ui, fadeOutTime: ai } = i("fadeTime", "fadeOutTime");
var { fadeInTime: li } = i("fadeInTime");
var { freq: pi } = i("freq");
var { pattack: fi, patt: hi } = i("pattack", "patt");
var { pdecay: di, pdec: mi } = i("pdecay", "pdec");
var { psustain: yi, psus: wi } = i("psustain", "psus");
var { prelease: gi, prel: bi } = i("prelease", "prel");
var { penv: _i } = i("penv");
var { pcurve: vi } = i("pcurve");
var { panchor: ki } = i("panchor");
var { gate: qi, gat: Ai } = i("gate", "gat");
var { leslie: Si } = i("leslie");
var { lrate: Ti } = i("lrate");
var { lsize: Ci } = i("lsize");
var { activeLabel: xi } = i("activeLabel");
var { label: Bi } = i(["label", "activeLabel"]);
var { degree: Oi } = i("degree");
var { mtranspose: zi } = i("mtranspose");
var { ctranspose: Ei } = i("ctranspose");
var { harmonic: Mi } = i("harmonic");
var { stepsPerOctave: Pi } = i("stepsPerOctave");
var { octaveR: Ji } = i("octaveR");
var { nudge: ji } = i("nudge");
var { octave: Ni } = i("octave");
var { orbit: Wi } = i("orbit");
var { overgain: $i } = i("overgain");
var { overshape: Ri } = i("overshape");
var { pan: Li } = i("pan");
var { panspan: Ii } = i("panspan");
var { pansplay: Hi } = i("pansplay");
var { panwidth: Vi } = i("panwidth");
var { panorient: Fi } = i("panorient");
var { rate: Di } = i("rate");
var { slide: Gi } = i("slide");
var { semitone: Qi } = i("semitone");
var { voice: Ui } = i("voice");
var { chord: Ki } = i("chord");
var { dictionary: Xi, dict: Yi } = i("dictionary", "dict");
var { anchor: Zi } = i("anchor");
var { offset: tc } = i("offset");
var { octaves: ec } = i("octaves");
var { mode: nc } = i(["mode", "anchor"]);
var { room: sc } = i(["room", "size"]);
var { roomlp: rc, rlp: oc } = i("roomlp", "rlp");
var { roomdim: ic, rdim: cc } = i("roomdim", "rdim");
var { roomfade: uc, rfade: ac } = i("roomfade", "rfade");
var { ir: lc, iresponse: pc } = i(["ir", "i"], "iresponse");
var { irspeed: fc } = i("irspeed");
var { irbegin: hc } = i("irbegin");
var { roomsize: dc, size: mc, sz: yc, rsize: wc } = i("roomsize", "size", "sz", "rsize");
var { shape: gc } = i(["shape", "shapevol"]);
var { distort: bc, dist: _c } = i(["distort", "distortvol", "distorttype"], "dist");
var { distortvol: vc } = i("distortvol", "distvol");
var { distorttype: kc } = i("distorttype", "disttype");
var { compressor: qc } = i([
  "compressor",
  "compressorRatio",
  "compressorKnee",
  "compressorAttack",
  "compressorRelease"
]);
var { compressorKnee: Ac } = i("compressorKnee");
var { compressorRatio: Sc } = i("compressorRatio");
var { compressorAttack: Tc } = i("compressorAttack");
var { compressorRelease: Cc } = i("compressorRelease");
var { speed: ne } = i("speed");
var { stretch: xc } = i("stretch");
var { unit: Bc } = i("unit");
var { squiz: Oc } = i("squiz");
var { vowel: zc } = i("vowel");
var { waveloss: Ec } = i("waveloss");
var { density: Mc } = i("density");
var { expression: Pc } = i("expression");
var { sustainpedal: Jc } = i("sustainpedal");
var { fshift: jc } = i("fshift");
var { fshiftnote: Nc } = i("fshiftnote");
var { fshiftphase: Wc } = i("fshiftphase");
var { triode: $c } = i("triode");
var { krush: Rc } = i("krush");
var { kcutoff: Lc } = i("kcutoff");
var { octer: Ic } = i("octer");
var { octersub: Hc } = i("octersub");
var { octersubsub: Vc } = i("octersubsub");
var { ring: Fc } = i("ring");
var { ringf: Dc } = i("ringf");
var { ringdf: Gc } = i("ringdf");
var { freeze: Qc } = i("freeze");
var { xsdelay: Uc } = i("xsdelay");
var { tsdelay: Kc } = i("tsdelay");
var { real: Xc } = i("real");
var { imag: Yc } = i("imag");
var { enhance: Zc } = i("enhance");
var { partials: tu } = i("partials");
var { comb: eu } = i("comb");
var { smear: nu } = i("smear");
var { scram: su } = i("scram");
var { binshift: ru } = i("binshift");
var { hbrick: ou } = i("hbrick");
var { lbrick: iu } = i("lbrick");
var { frameRate: cu } = i("frameRate");
var { frames: uu } = i("frames");
var { hours: au } = i("hours");
var { minutes: lu } = i("minutes");
var { seconds: pu } = i("seconds");
var { songPtr: fu } = i("songPtr");
var { uid: hu } = i("uid");
var { val: du } = i("val");
var { cps: mu } = i("cps");
var { clip: yu, legato: wu } = i("clip", "legato");
var { duration: gu, dur: bu } = i("duration", "dur");
var { zrand: _u } = i("zrand");
var { curve: vu } = i("curve");
var { deltaSlide: ku } = i("deltaSlide");
var { pitchJump: qu } = i("pitchJump");
var { pitchJumpTime: Au } = i("pitchJumpTime");
var { lfo: Su, repeatTime: Tu } = i("lfo", "repeatTime");
var { znoise: Cu } = i("znoise");
var { zmod: xu } = i("zmod");
var { zcrush: Bu } = i("zcrush");
var { zdelay: Ou } = i("zdelay");
var { zzfx: zu } = i("zzfx");
var { color: Eu, colour: Mu } = i(["color", "colour"]);
var Pu = (...t) => t.reduce((e, n) => Object.assign(e, { [n]: Bt(n) }), {});
var Ju = l("adsr", (t, e) => {
  t = Array.isArray(t) ? t : [t];
  const [n, s, r, o] = t;
  return e.set({ attack: n, decay: s, sustain: r, release: o });
});
var ju = l("ad", (t, e) => {
  t = Array.isArray(t) ? t : [t];
  const [n, s = n] = t;
  return e.attack(n).decay(s);
});
var Nu = l("ds", (t, e) => {
  t = Array.isArray(t) ? t : [t];
  const [n, s = 0] = t;
  return e.set({ decay: n, sustain: s });
});
var Wu = l("ar", (t, e) => {
  t = Array.isArray(t) ? t : [t];
  const [n, s = n] = t;
  return e.set({ attack: n, release: s });
});
var { midichan: $u } = i("midichan");
var { midimap: Ru } = i("midimap");
var { midiport: Lu } = i("midiport");
var { midicmd: Iu } = i("midicmd");
var Hu = l("control", (t, e) => {
  if (!Array.isArray(t))
    throw new Error("control expects an array of [ccn, ccv]");
  const [n, s] = t;
  return e.ccn(n).ccv(s);
});
var { ccn: Vu } = i("ccn");
var { ccv: Fu } = i("ccv");
var { ctlNum: Du } = i("ctlNum");
var { nrpnn: Gu } = i("nrpnn");
var { nrpv: Qu } = i("nrpv");
var { progNum: Uu } = i("progNum");
var Ku = l("sysex", (t, e) => {
  if (!Array.isArray(t))
    throw new Error("sysex expects an array of [id, data]");
  const [n, s] = t;
  return e.sysexid(n).sysexdata(s);
});
var { sysexid: Xu } = i("sysexid");
var { sysexdata: Yu } = i("sysexdata");
var { midibend: Zu } = i("midibend");
var { miditouch: ta } = i("miditouch");
var { polyTouch: ea } = i("polyTouch");
var { oschost: na } = i("oschost");
var { oscport: sa } = i("oscport");
var se = (t) => rt.has(t) ? rt.get(t) : t;
var ra = l("as", (t, e) => (t = Array.isArray(t) ? t : [t], e.fmap((n) => (n = Array.isArray(n) ? n : [n], n = Object.fromEntries(t.map((s, r) => [se(s), n[r]])), n))));
var oa = l(
  "scrub",
  (t, e) => t.outerBind((n) => {
    Array.isArray(n) || (n = [n]);
    const [s, r = 1] = n;
    return e.begin(s).mul(ne(r)).clip(1);
  }),
  false
);
var Qf = Object.freeze(Object.defineProperty({
  __proto__: null,
  accelerate: Os,
  activeLabel: xi,
  ad: ju,
  adsr: Ju,
  amp: Ps,
  analyze: Us,
  anchor: Zi,
  ar: Wu,
  as: ra,
  att: js,
  attack: Js,
  bandf: rr,
  bandq: cr,
  bank: Gs,
  bbexpr: Or,
  bbst: Er,
  begin: ar,
  binshift: ru,
  bp: ir,
  bpa: po,
  bpattack: lo,
  bpd: go,
  bpdecay: wo,
  bpe: oo,
  bpenv: ro,
  bpf: or,
  bpq: ur,
  bpr: Oo,
  bprelease: Bo,
  bps: Ao,
  bpsustain: qo,
  byteBeatExpression: Br,
  byteBeatStartTime: zr,
  ccn: Vu,
  ccv: Fu,
  ch: Pr,
  channel: Qr,
  channels: Mr,
  chord: Ki,
  chorus: Qs,
  clip: yu,
  coarse: wr,
  color: Eu,
  colour: Mu,
  comb: eu,
  compressor: qc,
  compressorAttack: Tc,
  compressorKnee: Ac,
  compressorRatio: Sc,
  compressorRelease: Cc,
  control: Hu,
  cps: mu,
  createParam: Bt,
  createParams: Pu,
  crush: yr,
  ctf: Xr,
  ctlNum: Du,
  ctranspose: Ei,
  curve: vu,
  cut: Ur,
  cutoff: Kr,
  dec: Ys,
  decay: Xs,
  degree: Oi,
  delay: Go,
  delayfb: Uo,
  delayfeedback: Qo,
  delayspeed: Xo,
  delaysync: ei,
  delayt: Zo,
  delaytime: Yo,
  deltaSlide: ku,
  density: Mc,
  det: ri,
  detune: si,
  dfb: Ko,
  dict: Yi,
  dictionary: Xi,
  dist: _c,
  distort: bc,
  distorttype: kc,
  distortvol: vc,
  djf: Do,
  drive: Ar,
  dry: ci,
  ds: Nu,
  dt: ti,
  duck: Sr,
  duckattack: xr,
  duckdepth: Tr,
  duckonset: Cr,
  dur: bu,
  duration: gu,
  end: lr,
  enhance: Zc,
  expression: Pc,
  fadeInTime: li,
  fadeOutTime: ai,
  fadeTime: ui,
  fanchor: Eo,
  fft: Ks,
  fm: $s,
  fmattack: Ls,
  fmdecay: Hs,
  fmenv: Rs,
  fmh: Ns,
  fmi: Ws,
  fmrelease: Fs,
  fmsustain: Vs,
  fmvelocity: Ds,
  fmwave: Is,
  frameRate: cu,
  frames: uu,
  freeze: Qc,
  freq: pi,
  fshift: jc,
  fshiftnote: Nc,
  fshiftphase: Wc,
  ftype: zo,
  gain: Es,
  gat: Ai,
  gate: qi,
  getControlName: se,
  harmonic: Mi,
  hbrick: ou,
  hcutoff: $o,
  hold: sr,
  hours: au,
  hp: Lo,
  hpa: ao,
  hpattack: uo,
  hpd: yo,
  hpdecay: mo,
  hpe: so,
  hpenv: no,
  hpf: Ro,
  hpq: Ho,
  hpr: xo,
  hprelease: Co,
  hps: ko,
  hpsustain: vo,
  hresonance: Io,
  imag: Yc,
  ir: lc,
  irbegin: hc,
  iresponse: pc,
  irspeed: fc,
  isControlName: $n,
  kcutoff: Lc,
  krush: Rc,
  label: Bi,
  lbrick: iu,
  legato: wu,
  leslie: Si,
  lfo: Su,
  lock: ni,
  loop: pr,
  loopBegin: fr,
  loopEnd: dr,
  loopb: hr,
  loope: mr,
  lp: Zr,
  lpa: co,
  lpattack: io,
  lpd: ho,
  lpdecay: fo,
  lpe: eo,
  lpenv: to,
  lpf: Yr,
  lpq: Fo,
  lpr: To,
  lprelease: So,
  lps: _o,
  lpsustain: bo,
  lrate: Ti,
  lsize: Ci,
  midibend: Zu,
  midichan: $u,
  midicmd: Iu,
  midimap: Ru,
  midiport: Lu,
  miditouch: ta,
  minutes: lu,
  mode: nc,
  mtranspose: zi,
  n: xs,
  noise: jo,
  note: Bs,
  nrpnn: Gu,
  nrpv: Qu,
  nudge: ji,
  octave: Ni,
  octaveR: Ji,
  octaves: ec,
  octer: Ic,
  octersub: Hc,
  octersubsub: Vc,
  offset: tc,
  orbit: Wi,
  oschost: na,
  oscport: sa,
  overgain: $i,
  overshape: Ri,
  pan: Li,
  panchor: ki,
  panorient: Fi,
  panspan: Ii,
  pansplay: Hi,
  panwidth: Vi,
  partials: tu,
  patt: hi,
  pattack: fi,
  pcurve: vi,
  pdec: mi,
  pdecay: di,
  penv: _i,
  ph: $r,
  phasdp: Gr,
  phaser: Rr,
  phasercenter: Hr,
  phaserdepth: Fr,
  phaserrate: Wr,
  phasersweep: Lr,
  phc: Vr,
  phd: Dr,
  phs: Ir,
  pitchJump: qu,
  pitchJumpTime: Au,
  polyTouch: ea,
  postgain: Ms,
  prel: bi,
  prelease: gi,
  progNum: Uu,
  psus: wi,
  psustain: yi,
  pw: Jr,
  pwrate: jr,
  pwsweep: Nr,
  rate: Di,
  rdim: cc,
  real: Xc,
  registerControl: i,
  rel: nr,
  release: er,
  repeatTime: Tu,
  resonance: Vo,
  rfade: ac,
  ring: Fc,
  ringdf: Gc,
  ringf: Dc,
  rlp: oc,
  room: sc,
  roomdim: ic,
  roomfade: uc,
  roomlp: rc,
  roomsize: dc,
  rsize: wc,
  s: Rn,
  scram: su,
  scrub: oa,
  seconds: pu,
  semitone: Qi,
  shape: gc,
  size: mc,
  slide: Gi,
  smear: nu,
  songPtr: fu,
  sound: Ln,
  source: Ts,
  speed: ne,
  spread: ii,
  squiz: Oc,
  src: Cs,
  stepsPerOctave: Pi,
  stretch: xc,
  sus: tr,
  sustain: Zs,
  sustainpedal: Jc,
  sysex: Ku,
  sysexdata: Yu,
  sysexid: Xu,
  sz: yc,
  tremolo: gr,
  tremolodepth: _r,
  tremolophase: kr,
  tremoloshape: qr,
  tremoloskew: vr,
  tremolosync: br,
  triode: $c,
  tsdelay: Kc,
  uid: hu,
  unison: oi,
  unit: Bc,
  v: Jo,
  val: du,
  velocity: zs,
  vib: Mo,
  vibmod: No,
  vibrato: Po,
  vmod: Wo,
  voice: Ui,
  vowel: zc,
  warp: os,
  warpatt: us,
  warpattack: cs,
  warpdc: gs,
  warpdec: ls,
  warpdecay: as,
  warpdepth: ys,
  warpenv: As,
  warpmode: _s,
  warprate: ms,
  warprel: ds,
  warprelease: hs,
  warpshape: ws,
  warpskew: bs,
  warpsus: fs,
  warpsustain: ps,
  warpsync: Ss,
  waveloss: Ec,
  wavetablePhaseRand: qs,
  wavetablePosition: Hn,
  wavetableWarp: is,
  wavetableWarpMode: vs,
  wt: In,
  wtatt: Dn,
  wtattack: Fn,
  wtdc: ss,
  wtdec: Qn,
  wtdecay: Gn,
  wtdepth: es,
  wtenv: Vn,
  wtphaserand: ks,
  wtrate: Zn,
  wtrel: Yn,
  wtrelease: Xn,
  wtshape: ns,
  wtskew: rs,
  wtsus: Kn,
  wtsustain: Un,
  wtsync: ts,
  xsdelay: Uc,
  zcrush: Bu,
  zdelay: Ou,
  zmod: xu,
  znoise: Cu,
  zrand: _u,
  zzfx: zu
}, Symbol.toStringTag, { value: "Module" }));
var ia = function(t, e) {
  const [n, s] = t, [r, o] = e, [c, u] = Kt(s, r);
  return [
    [s, n - s],
    [At((a, p) => a.concat(p), c, o), u]
  ];
};
var ca = function(t, e) {
  const [n, s] = t, [r, o] = e, [c, u] = Kt(n, o);
  return [
    [n, s - n],
    [At((p, m) => p.concat(m), r, c), u]
  ];
};
var re = function(t, e) {
  const [n, s] = t;
  return Math.min(n, s) <= 1 ? [t, e] : re(...n > s ? ia(t, e) : ca(t, e));
};
var oe = function(t, e) {
  const n = t < 0, s = Math.abs(t), r = e - s, o = Array(s).fill([1]), c = Array(r).fill([0]), u = re([s, r], [o, c]), a = D(u[1][0]).concat(D(u[1][1]));
  return n ? a.map((p) => 1 - p) : a;
};
var dt = function(t, e, n) {
  const s = oe(t, e);
  return n ? $e(s, -n) : s;
};
var Uf = l("euclid", function(t, e, n) {
  return n.struct(dt(t, e, 0));
});
var Kf = l("e", function(t, e) {
  Array.isArray(t) || (t = [t]);
  const [n, s = n, r = 0] = t;
  return e.struct(dt(n, s, r));
});
var { euclidrot: Xf, euclidRot: Yf } = l(["euclidrot", "euclidRot"], function(t, e, n, s) {
  return s.struct(dt(t, e, n));
});
var ie = function(t, e, n, s) {
  if (t < 1)
    return v;
  const o = dt(t, e, 0).join("").split("1").slice(1).map((c) => [c.length + 1, true]);
  return s.struct(Pn(...o)).late(h(n).div(e));
};
var Zf = l(["euclidLegato"], function(t, e, n) {
  return ie(t, e, 0, n);
});
var th = l(["euclidLegatoRot"], function(t, e, n, s) {
  return ie(t, e, n, s);
});
var { euclidish: eh, eish: nh } = l(["euclidish", "eish"], function(t, e, n, s) {
  const r = ee(oe(t, e), new Array(t).fill(1), n);
  return s.struct(r).setSteps(e);
});
function ua(t, e, n = 0.05, s = 0.1, r = 0.1, o = globalThis.setInterval, c = globalThis.clearInterval, u = true) {
  let a = 0, p = 0, m = 10 ** 4, y = 0.01;
  const _ = (J) => n = J(n);
  r = r || s / 2;
  const g = () => {
    const J = t(), Q = J + s + r;
    for (p === 0 && (p = J + y); p < Q; )
      p = u ? Math.round(p * m) / m : p, e(p, n, a, J), p += n, a++;
  };
  let k;
  const q = () => {
    M(), g(), k = o(g, s * 1e3);
  }, M = () => {
    k !== void 0 && c(k), k = void 0;
  };
  return { setDuration: _, start: q, stop: () => {
    a = 0, p = 0, M();
  }, pause: () => M(), duration: n, interval: s, getPhase: () => p, minLatency: y };
}
function sh(t) {
  return new f((e) => [new C(void 0, e.span, t)]);
}
var I = (t) => {
  const e = (n) => [new C(void 0, n.span, t(n.span.begin))];
  return new f(e);
};
var mt = I((t) => t % 1);
var ce = mt.toBipolar();
var Ot = I((t) => 1 - t % 1);
var ue = Ot.toBipolar();
var ae = I((t) => Math.sin(Math.PI * 2 * t));
var aa = ae.fromBipolar();
var rh = aa._early(h(1).div(4));
var oh = ae._early(h(1).div(4));
var la = I((t) => Math.floor(t * 2 % 2));
var ih = la.toBipolar();
var ch = W(mt, Ot);
var uh = W(ce, ue);
var ah = W(Ot, mt);
var lh = W(ue, ce);
var le = I(et);
var zt = 0;
var Et = 0;
typeof window < "u" && document.addEventListener("mousemove", (t) => {
  zt = t.clientY / document.body.clientHeight, Et = t.clientX / document.body.clientWidth;
});
var ph = I(() => zt);
var fh = I(() => zt);
var hh = I(() => Et);
var dh = I(() => Et);
var pe = (t) => {
  const e = t << 13 ^ t, n = e >> 17 ^ e;
  return n << 5 ^ n;
};
var pa = (t) => t - Math.trunc(t);
var fe = (t) => pe(Math.trunc(pa(t / 300) * 536870912));
var he = (t) => t % 536870912 / 536870912;
var ot = (t) => Math.abs(he(fe(t)));
var fa = (t, e) => {
  const n = [];
  for (let s = 0; s < e; ++s)
    n.push(he(t)), t = pe(t);
  return n;
};
var ha = (t, e) => fa(fe(t), e);
var da = (t) => mt.range(0, t).round().segment(t);
var mh = (t) => {
  const e = d(t).log2(0).floor().add(1);
  return ma(t, e);
};
var ma = (t, e = 16) => {
  e = d(e);
  const n = da(e).mul(-1).add(e.sub(1));
  return d(t).segment(e).brshift(n).band(z(1));
};
var ya = (t) => I((e) => {
  const s = ha(e.floor().add(0.5), t).map((o, c) => [o, c]).sort((o, c) => (o[0] > c[0]) - (o[0] < c[0])).map((o) => o[1]), r = e.cyclePos().mul(t).floor() % t;
  return s[r];
})._segment(t);
var de = (t, e, n) => {
  const s = [...Array(e).keys()].map((r) => n.zoom(h(r).div(e), h(r + 1).div(e)));
  return t.fmap((r) => s[r].repeatCycles(e)._fast(e)).innerJoin();
};
var yh = l("shuffle", (t, e) => de(ya(t), t, e));
var wh = l("scramble", (t, e) => de(ye(t)._segment(t), t, e));
var L = I(ot);
var gh = L.toBipolar();
var me = (t) => L.fmap((e) => e < t);
var bh = (t) => d(t).fmap(me).innerJoin();
var _h = me(0.5);
var ye = (t) => L.fmap((e) => Math.trunc(e * t));
var vh = (t) => d(t).fmap(ye).innerJoin();
var we = (t, e) => (e = e.map(d), e.length == 0 ? v : t.range(0, e.length).fmap((n) => {
  const s = Math.min(Math.max(Math.floor(n), 0), e.length - 1);
  return e[s];
}));
var Mt = (t, e) => we(t, e).outerJoin();
var ge = (t, e) => we(t, e).innerJoin();
var wa = (...t) => Mt(L, t);
var kh = (...t) => ge(L, t);
var qh = wa;
f.prototype.choose = function(...t) {
  return Mt(this, t);
};
f.prototype.choose2 = function(...t) {
  return Mt(this.fromBipolar(), t);
};
var ga = (...t) => ge(L.segment(1), t);
var Ah = ga;
var be = function(t, ...e) {
  const n = e.map((u) => d(u[0])), s = [];
  let r = z(0);
  for (const u of e)
    r = r.add(u[1]), s.push(r);
  const o = fn(s), c = function(u) {
    const a = r.mul(u);
    return o.fmap((p) => (m) => n[p.findIndex((y) => y > m, p)]).appLeft(a);
  };
  return t.bind(c);
};
var ba = (...t) => be(...t).outerJoin();
var Sh = (...t) => ba(L, ...t);
var _a = (...t) => be(L.segment(1), ...t).innerJoin();
var Th = _a;
function va(t) {
  let e = Math.floor(t), n = e + 1;
  const s = (c) => 6 * c ** 5 - 15 * c ** 4 + 10 * c ** 3;
  return (/* @__PURE__ */ ((c) => (u) => (a) => u + s(c) * (a - u))(t - e))(ot(e))(ot(n));
}
var ka = (t) => t.fmap(va);
function qa(t) {
  const e = Math.floor(t), n = e + 1, s = ot(e), r = ot(n) + s, o = (t - e) / (n - e);
  return ((u, a, p) => u + (a - u) * p)(s, r, o) / 2;
}
var Aa = (t) => t.fmap(qa);
var Ch = ka(le.fmap((t) => Number(t)));
var xh = Aa(le.fmap((t) => Number(t)));
var Bh = l(
  "degradeByWith",
  (t, e, n) => n.fmap((s) => (r) => s).appLeft(t.filterValues((s) => s > e)),
  true,
  true
);
var Oh = l(
  "degradeBy",
  function(t, e) {
    return e._degradeByWith(L, t);
  },
  true,
  true
);
var zh = l("degrade", (t) => t._degradeBy(0.5), true, true);
var Eh = l(
  "undegradeBy",
  function(t, e) {
    return e._degradeByWith(
      L.fmap((n) => 1 - n),
      t
    );
  },
  true,
  true
);
var Mh = l("undegrade", (t) => t._undegradeBy(0.5), true, true);
var Ph = l("sometimesBy", function(t, e, n) {
  return d(t).fmap((s) => B(n._degradeBy(s), e(n._undegradeBy(1 - s)))).innerJoin();
});
var Jh = l("sometimes", function(t, e) {
  return e._sometimesBy(0.5, t);
});
var jh = l("someCyclesBy", function(t, e, n) {
  return d(t).fmap(
    (s) => B(
      n._degradeByWith(L._segment(1), s),
      e(n._degradeByWith(L.fmap((r) => 1 - r)._segment(1), 1 - s))
    )
  ).innerJoin();
});
var Nh = l("someCycles", function(t, e) {
  return e._someCyclesBy(0.5, t);
});
var Wh = l("often", function(t, e) {
  return e.sometimesBy(0.75, t);
});
var $h = l("rarely", function(t, e) {
  return e.sometimesBy(0.25, t);
});
var Rh = l("almostNever", function(t, e) {
  return e.sometimesBy(0.1, t);
});
var Lh = l("almostAlways", function(t, e) {
  return e.sometimesBy(0.9, t);
});
var Ih = l("never", function(t, e) {
  return e;
});
var Hh = l("always", function(t, e) {
  return t(e);
});
function _e(t) {
  Array.isArray(t) === false && (t = [t]);
  const e = sn();
  return t.every((n) => {
    const s = nn.get(n) ?? n;
    return e[s];
  });
}
var Vh = l("whenKey", function(t, e, n) {
  return n.when(_e(t), e);
});
var Fh = l("keyDown", function(t) {
  return t.fmap(_e);
});
var H = function(t, e, n = true) {
  const s = Array.isArray(t), r = Object.keys(t).length;
  return t = Ze(t, d), r === 0 ? v : e.fmap((o) => {
    let c = o;
    return s && (c = n ? Math.round(c) % r : He(Math.round(c), 0, t.length - 1)), t[c];
  });
};
var Sa = function(t, e) {
  return Array.isArray(e) && ([e, t] = [t, e]), Ta(t, e);
};
var Ta = l("pick", function(t, e) {
  return H(t, e, false).innerJoin();
});
var Ca = l("pickmod", function(t, e) {
  return H(t, e, true).innerJoin();
});
var Dh = l("pickF", function(t, e, n) {
  return n.apply(Sa(t, e));
});
var Gh = l("pickmodF", function(t, e, n) {
  return n.apply(Ca(t, e));
});
var Qh = l("pickOut", function(t, e) {
  return H(t, e, false).outerJoin();
});
var Uh = l("pickmodOut", function(t, e) {
  return H(t, e, true).outerJoin();
});
var Kh = l("pickRestart", function(t, e) {
  return H(t, e, false).restartJoin();
});
var Xh = l("pickmodRestart", function(t, e) {
  return H(t, e, true).restartJoin();
});
var Yh = l("pickReset", function(t, e) {
  return H(t, e, false).resetJoin();
});
var Zh = l("pickmodReset", function(t, e) {
  return H(t, e, true).resetJoin();
});
var { inhabit: td, pickSqueeze: ed } = l(["inhabit", "pickSqueeze"], function(t, e) {
  return H(t, e, false).squeezeJoin();
});
var { inhabitmod: nd, pickmodSqueeze: sd } = l(["inhabitmod", "pickmodSqueeze"], function(t, e) {
  return H(t, e, true).squeezeJoin();
});
var rd = (t, e) => (e = e.map(d), e.length == 0 ? v : t.fmap((n) => {
  const s = ft(Math.round(n), e.length);
  return e[s];
}).squeezeJoin());
var lt;
try {
  lt = window == null ? void 0 : window.speechSynthesis;
} catch {
  console.warn("cannot use window: not in browser?");
}
var Vt = lt == null ? void 0 : lt.getVoices();
function xa(t, e, n) {
  lt.cancel();
  const s = new SpeechSynthesisUtterance(t);
  s.lang = e, Vt = lt.getVoices();
  const r = Vt.filter((o) => o.lang.includes(e));
  typeof n == "number" ? s.voice = r[n % r.length] : typeof n == "string" && (s.voice = r.find((o) => o.name === o)), speechSynthesis.speak(s);
}
var od = l("speak", function(t, e, n) {
  return n.onTrigger((s) => {
    xa(s.value, t, e);
  });
});
var Ba = {};
var Oa = async (...t) => {
  const e = await Promise.allSettled(t), n = e.filter((s) => s.status === "fulfilled").map((s) => s.value);
  return e.forEach((s, r) => {
    s.status === "rejected" && console.warn(`evalScope: module with index ${r} could not be loaded:`, s.reason);
  }), n.forEach((s) => {
    Object.entries(s).forEach(([r, o]) => {
      globalThis[r] = o, Ba[r] = o;
    });
  }), n;
};
function za(t, e = {}) {
  const { wrapExpression: n = true, wrapAsync: s = true } = e;
  n && (t = `{${t}}`), s && (t = `(async ()=>${t})()`);
  const r = `"use strict";return (${t})`;
  return Function(r)();
}
var Ea = async (t, e, n) => {
  let s = {};
  if (e) {
    const c = e(t, n);
    t = c.output, s = c;
  }
  return { mode: "javascript", pattern: await za(t, { wrapExpression: !!e }), meta: s };
};
var Ma = class {
  constructor({ onTrigger: e, onToggle: n, getTime: s }) {
    this.started = false, this.cps = 0.5, this.getTime = s, this.time_at_last_tick_message = 0, this.collator = new tn({ getTargetClockTime: s }), this.onToggle = n, this.latency = 0.1, this.cycle = 0, this.id = Math.round(Date.now() * Math.random()), this.worker = new SharedWorker(new URL(
      /* @vite-ignore */
      "" + new URL("assets/clockworker-ZDiUtESR.js", import.meta.url).href,
      import.meta.url
    )), this.worker.port.start(), this.channel = new BroadcastChannel("strudeltick");
    const r = (c) => {
      const { cps: u, begin: a, end: p, cycle: m, time: y } = c;
      this.cps = u, this.cycle = m;
      const _ = this.collator.calculateOffset(y) + y;
      o(a, p, _), this.time_at_last_tick_message = _;
    }, o = (c, u, a) => {
      if (this.started === false)
        return;
      this.pattern.queryArc(c, u, { _cps: this.cps, cyclist: "neocyclist" }).forEach((m) => {
        if (m.hasOnset()) {
          const _ = Rt(m.whole.begin - this.cycle, this.cps) + a + this.latency, g = Rt(m.duration, this.cps);
          e == null ? void 0 : e(m, 0, g, this.cps, _);
        }
      });
    };
    this.channel.onmessage = (c) => {
      if (!this.started)
        return;
      const { payload: u, type: a } = c.data;
      switch (a) {
        case "tick":
          r(u);
      }
    };
  }
  sendMessage(e, n) {
    this.worker.port.postMessage({ type: e, payload: n, id: this.id });
  }
  now() {
    const e = (this.getTime() - this.time_at_last_tick_message) * this.cps;
    return this.cycle + e;
  }
  setCps(e = 1) {
    this.sendMessage("cpschange", { cps: e });
  }
  setCycle(e) {
    this.sendMessage("setcycle", { cycle: e });
  }
  setStarted(e) {
    var _a2;
    this.sendMessage("toggle", { started: e }), this.started = e, (_a2 = this.onToggle) == null ? void 0 : _a2.call(this, e);
  }
  start() {
    E("[cyclist] start"), this.setStarted(true);
  }
  stop() {
    E("[cyclist] stop"), this.collator.reset(), this.setStarted(false);
  }
  setPattern(e, n = false) {
    this.pattern = e, n && !this.started && this.start();
  }
  log(e, n, s) {
    const r = s.filter((o) => o.hasOnset());
    console.log(`${e.toFixed(4)} - ${n.toFixed(4)} ${Array(r.length).fill("I").join("")}`);
  }
};
var Pa = class {
  constructor({
    interval: e,
    onTrigger: n,
    onToggle: s,
    onError: r,
    getTime: o,
    latency: c = 0.1,
    setInterval: u,
    clearInterval: a,
    beforeStart: p
  }) {
    this.started = false, this.beforeStart = p, this.cps = 0.5, this.num_ticks_since_cps_change = 0, this.lastTick = 0, this.lastBegin = 0, this.lastEnd = 0, this.getTime = o, this.num_cycles_at_cps_change = 0, this.seconds_at_cps_change, this.onToggle = s, this.latency = c, this.clock = ua(
      o,
      // called slightly before each cycle
      (m, y, _, g) => {
        this.num_ticks_since_cps_change === 0 && (this.num_cycles_at_cps_change = this.lastEnd, this.seconds_at_cps_change = m), this.num_ticks_since_cps_change++;
        const q = this.num_ticks_since_cps_change * y * this.cps;
        try {
          const M = this.lastEnd;
          this.lastBegin = M;
          const P2 = this.num_cycles_at_cps_change + q;
          if (this.lastEnd = P2, this.lastTick = m, m < g) {
            console.log("skip query: too late");
            return;
          }
          this.pattern.queryArc(M, P2, { _cps: this.cps, cyclist: "cyclist" }).forEach((T) => {
            if (T.hasOnset()) {
              const J = (T.whole.begin - this.num_cycles_at_cps_change) / this.cps + this.seconds_at_cps_change + c, Q = T.duration / this.cps, V = J - m;
              n == null ? void 0 : n(T, V, Q, this.cps, J), T.value.cps !== void 0 && this.cps != T.value.cps && (this.cps = T.value.cps, this.num_ticks_since_cps_change = 0);
            }
          });
        } catch (M) {
          Gt(M), r == null ? void 0 : r(M);
        }
      },
      e,
      // duration of each cycle
      0.1,
      0.1,
      u,
      a
    );
  }
  now() {
    if (!this.started)
      return 0;
    const e = this.getTime() - this.lastTick - this.clock.duration;
    return this.lastBegin + e * this.cps;
  }
  setStarted(e) {
    var _a2;
    this.started = e, (_a2 = this.onToggle) == null ? void 0 : _a2.call(this, e);
  }
  async start() {
    var _a2;
    if (await ((_a2 = this.beforeStart) == null ? void 0 : _a2.call(this)), this.num_ticks_since_cps_change = 0, this.num_cycles_at_cps_change = 0, !this.pattern)
      throw new Error("Scheduler: no pattern set! call .setPattern first.");
    E("[cyclist] start"), this.clock.start(), this.setStarted(true);
  }
  pause() {
    E("[cyclist] pause"), this.clock.pause(), this.setStarted(false);
  }
  stop() {
    E("[cyclist] stop"), this.clock.stop(), this.lastEnd = 0, this.setStarted(false);
  }
  async setPattern(e, n = false) {
    this.pattern = e, n && !this.started && await this.start();
  }
  setCps(e = 0.5) {
    this.cps !== e && (this.cps = e, this.num_ticks_since_cps_change = 0);
  }
  log(e, n, s) {
    const r = s.filter((o) => o.hasOnset());
    console.log(`${e.toFixed(4)} - ${n.toFixed(4)} ${Array(r.length).fill("I").join("")}`);
  }
};
var kt;
function id() {
  if (!kt)
    throw new Error("no time set! use setTime to define a time source");
  return kt();
}
function Ft(t) {
  kt = t;
}
function cd({
  defaultOutput: t,
  onEvalError: e,
  beforeEval: n,
  beforeStart: s,
  afterEval: r,
  getTime: o,
  transpiler: c,
  onToggle: u,
  editPattern: a,
  onUpdateState: p,
  sync: m = false,
  setInterval: y,
  clearInterval: _,
  id: g,
  mondo: k = false
}) {
  const q = {
    schedulerError: void 0,
    evalError: void 0,
    code: "// LOADING",
    activeCode: "// LOADING",
    pattern: void 0,
    miniLocations: [],
    widgets: [],
    pending: false,
    started: false
  }, M = {
    id: g
  }, P2 = (b) => {
    Object.assign(q, b), q.isDirty = q.code !== q.activeCode, q.error = q.evalError || q.schedulerError, p == null ? void 0 : p(q);
  }, Y = {
    onTrigger: Ja({ defaultOutput: t, getTime: o }),
    getTime: o,
    onToggle: (b) => {
      P2({ started: b }), u == null ? void 0 : u(b);
    },
    setInterval: y,
    clearInterval: _,
    beforeStart: s
  }, T = m && typeof SharedWorker < "u" ? new Ma(Y) : new Pa(Y);
  let J = {}, Q = 0, V;
  const Pt = function() {
    return J = {}, Q = 0, V = void 0, v;
  };
  function Jt(b) {
    return b._Pattern ? b.__pure : b;
  }
  const jt = async (b, A = true) => (b = (a == null ? void 0 : a(b)) || b, await T.setPattern(b, A), b);
  Ft(() => T.now());
  const ve = () => T.stop(), ke = () => T.start(), qe = () => T.pause(), Ae = () => T.toggle(), yt = (b) => (T.setCps(Jt(b)), v), Nt = (b) => (T.setCps(Jt(b) / 60), v);
  let Z = [];
  const Se = function(b) {
    return Z.push(b), v;
  }, Te = function(b) {
    return V = b, v;
  }, Ce = () => {
    f.prototype.p = function(A) {
      return typeof A == "string" && (A.startsWith("_") || A.endsWith("_")) ? v : (A === "$" && (A = `$${Q}`, Q++), J[A] = this, this);
    }, f.prototype.q = function(A) {
      return v;
    };
    try {
      for (let A = 1; A < 10; ++A)
        Object.defineProperty(f.prototype, `d${A}`, {
          get() {
            return this.p(A);
          },
          configurable: true
        }), Object.defineProperty(f.prototype, `p${A}`, {
          get() {
            return this.p(A);
          },
          configurable: true
        }), f.prototype[`q${A}`] = v;
    } catch (A) {
      console.warn("injectPatternMethods: error:", A);
    }
    const b = l("cpm", function(A, wt) {
      return wt._fast(A / 60 / T.cps);
    });
    return Oa({
      all: Se,
      each: Te,
      hush: Pt,
      cpm: b,
      setCps: yt,
      setcps: yt,
      setCpm: Nt,
      setcpm: Nt
    });
  };
  return { scheduler: T, evaluate: async (b, A = true, wt = true) => {
    if (!b)
      throw new Error("no code to evaluate");
    try {
      P2({ code: b, pending: true }), await Ce(), Ft(() => T.now()), await (n == null ? void 0 : n({ code: b })), Z = [], wt && Pt(), k && (b = `mondolang\`${b}\``);
      let { pattern: O, meta: gt } = await Ea(b, c, M);
      if (Object.keys(J).length) {
        let F = [];
        for (const [bt, xe] of Object.entries(J))
          F.push(xe.withState((Be) => Be.setControls({ id: bt })));
        V && (F = F.map((bt) => V(bt))), O = B(...F);
      } else V && (O = V(O));
      if (Z.length)
        for (let F in Z)
          O = Z[F](O);
      if (!Yt(O)) {
        const F = `got "${typeof evaluated}" instead of pattern`;
        throw new Error(F + (typeof evaluated == "function" ? ", did you forget to call a function?" : "."));
      }
      return E("[eval] code updated"), O = await jt(O, A), P2({
        miniLocations: (gt == null ? void 0 : gt.miniLocations) || [],
        widgets: (gt == null ? void 0 : gt.widgets) || [],
        activeCode: b,
        pattern: O,
        evalError: void 0,
        schedulerError: void 0,
        pending: false
      }), r == null ? void 0 : r({ code: b, pattern: O, meta: gt }), O;
    } catch (O) {
      E(`[eval] error: ${O.message}`, "error"), console.error(O), P2({ evalError: O, pending: false }), e == null ? void 0 : e(O);
    }
  }, start: ke, stop: ve, pause: qe, setCps: yt, setPattern: jt, setCode: (b) => P2({ code: b }), toggle: Ae, state: q };
}
var Ja = ({ getTime: t, defaultOutput: e }) => async (n, s, r, o, c) => {
  try {
    (!n.context.onTrigger || !n.context.dominantTrigger) && await e(n, s, r, o, c), n.context.onTrigger && await n.context.onTrigger(n, t(), o, c);
  } catch (u) {
    Gt(u, "getTrigger");
  }
};
var ud = function(t, e = {}) {
  const n = document.getElementById("code"), s = "background-image:url(" + t + ");background-size:contain;";
  n.style = s;
  const { className: r } = n, o = (a, p) => {
    ({
      style: () => n.style = s + ";" + p,
      className: () => n.className = p + " " + r
    })[a]();
  }, c = Object.entries(e).filter(([a, p]) => typeof p == "function");
  Object.entries(e).filter(([a, p]) => typeof p == "string").forEach(([a, p]) => o(a, p)), c.length;
};
var ad = () => {
  const t = document.getElementById("code");
  t && (t.style = "");
};
E("🌀 @strudel/core loaded 🌀");
globalThis._strudelLoaded && console.warn(
  `@strudel/core was loaded more than once...
This might happen when you have multiple versions of strudel installed. 
Please check with "npm ls @strudel/core".`
);
globalThis._strudelLoaded = true;

export {
  Dt,
  Gt,
  E,
  $a,
  qt,
  ze,
  pt,
  nt,
  Pe,
  Ra,
  La,
  Je,
  Ia,
  ft,
  Ne,
  We,
  Ha,
  Va,
  Fa,
  $e,
  Re,
  Da,
  it,
  D,
  et,
  Ga,
  ht,
  w,
  Qt,
  Ut,
  $,
  Le,
  Qa,
  Kt,
  At,
  Ie,
  He,
  Ua,
  Ka,
  Xa,
  Ke,
  Xe,
  Ye,
  Ya,
  Za,
  Ze,
  Rt,
  tn,
  tl,
  nn,
  sn,
  Xt,
  h,
  x,
  C,
  st,
  un,
  el,
  nl,
  f,
  sl,
  rl,
  ol,
  il,
  cl,
  ct,
  v,
  R,
  z,
  Yt,
  d,
  fn,
  B,
  hn,
  dn,
  mn,
  ul,
  K,
  Zt,
  at,
  al,
  ll,
  W,
  G,
  yn,
  pl,
  fl,
  hl,
  dl,
  ml,
  yl,
  wl,
  gl,
  bl,
  _l,
  vl,
  kl,
  ql,
  Al,
  Sl,
  Tl,
  Cl,
  xl,
  Bl,
  Ol,
  zl,
  El,
  Ml,
  Pl,
  Jl,
  jl,
  Nl,
  Wl,
  $l,
  Rl,
  Ll,
  Il,
  Hl,
  Vl,
  Fl,
  l,
  Dl,
  Gl,
  Ql,
  Ul,
  Kl,
  Xl,
  Yl,
  Zl,
  tp,
  ep,
  np,
  sp,
  rp,
  op,
  ip,
  cp,
  up,
  ap,
  lp,
  fp,
  hp,
  dp,
  mp,
  yp,
  wp,
  gp,
  bp,
  _p,
  vp,
  kp,
  wn,
  qp,
  Ap,
  Sp,
  Tp,
  Cp,
  xp,
  Bp,
  Op,
  zp,
  Ep,
  Mp,
  Pp,
  Jp,
  jp,
  gn,
  Np,
  Wp,
  $p,
  Rp,
  Lp,
  Ip,
  Hp,
  Vp,
  Fp,
  Dp,
  Gp,
  Qp,
  bn,
  Up,
  Kp,
  Xp,
  Yp,
  Zp,
  tf,
  ef,
  nf,
  sf,
  rf,
  of,
  cf,
  uf,
  af,
  lf,
  pf,
  ff,
  hf,
  df,
  mf,
  yf,
  wf,
  gf,
  bf,
  _f,
  Lt,
  It,
  _n,
  vn,
  kn,
  qn,
  xt,
  N,
  An,
  Sn,
  Tn,
  Cn,
  vf,
  xn,
  Bn,
  On,
  zn,
  kf,
  En,
  Mn,
  qf,
  Pn,
  Af,
  Sf,
  Tf,
  Cf,
  xf,
  Bf,
  Of,
  zf,
  Ef,
  Mf,
  Pf,
  Jf,
  jf,
  Nf,
  Wf,
  Jn,
  $f,
  Rf,
  Lf,
  If,
  Hf,
  Vf,
  Ff,
  jn,
  Df,
  ee,
  Gf,
  Bt,
  $n,
  i,
  Rn,
  Ln,
  In,
  Hn,
  Vn,
  Fn,
  Dn,
  Gn,
  Qn,
  Un,
  Kn,
  Xn,
  Yn,
  Zn,
  ts,
  es,
  ns,
  ss,
  rs,
  os,
  is,
  cs,
  us,
  as,
  ls,
  ps,
  fs,
  hs,
  ds,
  ms,
  ys,
  ws,
  gs,
  bs,
  _s,
  vs,
  ks,
  qs,
  As,
  Ss,
  Ts,
  Cs,
  xs,
  Bs,
  Os,
  zs,
  Es,
  Ms,
  Ps,
  Js,
  js,
  Ns,
  Ws,
  $s,
  Rs,
  Ls,
  Is,
  Hs,
  Vs,
  Fs,
  Ds,
  Gs,
  Qs,
  Us,
  Ks,
  Xs,
  Ys,
  Zs,
  tr,
  er,
  nr,
  sr,
  rr,
  or,
  ir,
  cr,
  ur,
  ar,
  lr,
  pr,
  fr,
  hr,
  dr,
  mr,
  yr,
  wr,
  gr,
  br,
  _r,
  vr,
  kr,
  qr,
  Ar,
  Sr,
  Tr,
  Cr,
  xr,
  Br,
  Or,
  zr,
  Er,
  Mr,
  Pr,
  Jr,
  jr,
  Nr,
  Wr,
  $r,
  Rr,
  Lr,
  Ir,
  Hr,
  Vr,
  Fr,
  Dr,
  Gr,
  Qr,
  Ur,
  Kr,
  Xr,
  Yr,
  Zr,
  to,
  eo,
  no,
  so,
  ro,
  oo,
  io,
  co,
  uo,
  ao,
  lo,
  po,
  fo,
  ho,
  mo,
  yo,
  wo,
  go,
  bo,
  _o,
  vo,
  ko,
  qo,
  Ao,
  So,
  To,
  Co,
  xo,
  Bo,
  Oo,
  zo,
  Eo,
  Mo,
  Po,
  Jo,
  jo,
  No,
  Wo,
  $o,
  Ro,
  Lo,
  Io,
  Ho,
  Vo,
  Fo,
  Do,
  Go,
  Qo,
  Uo,
  Ko,
  Xo,
  Yo,
  Zo,
  ti,
  ei,
  ni,
  si,
  ri,
  oi,
  ii,
  ci,
  ui,
  ai,
  li,
  pi,
  fi,
  hi,
  di,
  mi,
  yi,
  wi,
  gi,
  bi,
  _i,
  vi,
  ki,
  qi,
  Ai,
  Si,
  Ti,
  Ci,
  xi,
  Bi,
  Oi,
  zi,
  Ei,
  Mi,
  Pi,
  Ji,
  ji,
  Ni,
  Wi,
  $i,
  Ri,
  Li,
  Ii,
  Hi,
  Vi,
  Fi,
  Di,
  Gi,
  Qi,
  Ui,
  Ki,
  Xi,
  Yi,
  Zi,
  tc,
  ec,
  nc,
  sc,
  rc,
  oc,
  ic,
  cc,
  uc,
  ac,
  lc,
  pc,
  fc,
  hc,
  dc,
  mc,
  yc,
  wc,
  gc,
  bc,
  _c,
  vc,
  kc,
  qc,
  Ac,
  Sc,
  Tc,
  Cc,
  ne,
  xc,
  Bc,
  Oc,
  zc,
  Ec,
  Pc,
  Jc,
  jc,
  Nc,
  Wc,
  $c,
  Rc,
  Lc,
  Ic,
  Hc,
  Vc,
  Fc,
  Dc,
  Gc,
  Qc,
  Uc,
  Kc,
  Xc,
  Yc,
  Zc,
  tu,
  eu,
  nu,
  su,
  ru,
  ou,
  iu,
  cu,
  uu,
  au,
  lu,
  pu,
  fu,
  hu,
  du,
  mu,
  yu,
  wu,
  gu,
  bu,
  _u,
  vu,
  ku,
  qu,
  Au,
  Su,
  Tu,
  Cu,
  xu,
  Bu,
  Ou,
  zu,
  Eu,
  Mu,
  Pu,
  Ju,
  ju,
  Nu,
  Wu,
  $u,
  Ru,
  Lu,
  Iu,
  Hu,
  Vu,
  Fu,
  Du,
  Gu,
  Qu,
  Uu,
  Ku,
  Xu,
  Yu,
  Zu,
  ta,
  ea,
  na,
  sa,
  se,
  ra,
  oa,
  Qf,
  oe,
  Uf,
  Kf,
  Xf,
  Yf,
  Zf,
  th,
  eh,
  nh,
  ua,
  sh,
  I,
  mt,
  ce,
  Ot,
  ue,
  ae,
  aa,
  rh,
  oh,
  la,
  ih,
  ch,
  uh,
  ah,
  lh,
  le,
  ph,
  fh,
  hh,
  dh,
  da,
  mh,
  ma,
  ya,
  yh,
  wh,
  L,
  gh,
  me,
  bh,
  _h,
  ye,
  vh,
  we,
  Mt,
  ge,
  wa,
  kh,
  qh,
  ga,
  Ah,
  Sh,
  _a,
  Th,
  ka,
  Aa,
  Ch,
  xh,
  Bh,
  Oh,
  zh,
  Eh,
  Mh,
  Ph,
  Jh,
  jh,
  Nh,
  Wh,
  $h,
  Rh,
  Lh,
  Ih,
  Hh,
  _e,
  Vh,
  Fh,
  Sa,
  Ca,
  Dh,
  Gh,
  Qh,
  Uh,
  Kh,
  Xh,
  Yh,
  Zh,
  td,
  ed,
  nd,
  sd,
  rd,
  od,
  Ba,
  Oa,
  Ea,
  Pa,
  id,
  Ft,
  cd,
  Ja,
  ud,
  ad,
  dist_exports
};
//# sourceMappingURL=chunk-PK2ATFA2.js.map
