import {
  Fa,
  He,
  Pe,
  Pu,
  dist_exports,
  f,
  id,
  l,
  nt,
  pt,
  v,
  z
} from "./chunk-PK2ATFA2.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/nanostores/clean-stores/index.js
var clean = Symbol("clean");

// node_modules/nanostores/atom/index.js
var listenerQueue = [];
var lqIndex = 0;
var QUEUE_ITEMS_PER_LISTENER = 4;
var epoch = 0;
var atom = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
          if (listenerQueue[i] === listener) {
            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners) {
        listenerQueue.push(
          listener,
          $atom.value,
          oldValue,
          changedKey
        );
      }
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        }
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};

// node_modules/nanostores/map/index.js
var map = (initial = {}) => {
  let $map = atom(initial);
  $map.setKey = function(key, value) {
    let oldMap = $map.value;
    if (typeof value === "undefined" && key in $map.value) {
      $map.value = { ...$map.value };
      delete $map.value[key];
      $map.notify(oldMap, key);
    } else if ($map.value[key] !== value) {
      $map.value = {
        ...$map.value,
        [key]: value
      };
      $map.notify(oldMap, key);
    }
  };
  return $map;
};

// node_modules/superdough/dist/index.mjs
if (typeof DelayNode < "u") {
  class t extends DelayNode {
    constructor(n, o, a, c) {
      super(n), o = Math.abs(o), this.delayTime.value = a;
      const s = n.createGain();
      s.gain.value = Math.min(Math.abs(c), 0.995), this.feedback = s.gain;
      const d = n.createGain();
      return d.gain.value = o, this.delayGain = d, this.connect(s), this.connect(d), s.connect(this), this.connect = (l2) => d.connect(l2), this;
    }
    start(n) {
      this.delayGain.gain.setValueAtTime(this.delayGain.gain.value, n + this.delayTime.value);
    }
  }
  AudioContext.prototype.createFeedbackDelay = function(e, n, o) {
    return new t(this, e, n, o);
  };
}
var Pt = {};
Pt.generateReverb = function(t, e) {
  for (var n = t.audioContext || new AudioContext(), o = n.sampleRate, a = t.numChannels || 2, c = t.decayTime * 1.5, s = Math.round(t.decayTime * o), d = Math.round(c * o), l2 = Math.round((t.fadeInTime || 0) * o), i = Math.pow(1 / 1e3, 1 / s), r = n.createBuffer(a, d, o), h = 0; h < a; h++) {
    for (var m = r.getChannelData(h), u = 0; u < d; u++)
      m[u] = an() * Math.pow(i, u);
    for (var u = 0; u < l2; u++)
      m[u] *= u / l2;
  }
  cn(r, t.lpFreqStart || 0, t.lpFreqEnd || 0, t.decayTime, e);
};
Pt.generateGraph = function(t, e, n, o, a) {
  var c = document.createElement("canvas");
  c.width = e, c.height = n;
  var s = c.getContext("2d");
  s.fillStyle = "#000", s.fillRect(0, 0, c.width, c.height), s.fillStyle = "#fff";
  for (var d = e / t.length, l2 = n / (a - o), i = 0; i < t.length; i++)
    s.fillRect(i * d, n - (t[i] - o) * l2, 1, 1);
  return c;
};
var cn = function(t, e, n, o, a) {
  if (e == 0) {
    a(t);
    return;
  }
  var c = sn(t), s = new OfflineAudioContext(t.numberOfChannels, c[0].length, t.sampleRate), d = s.createBufferSource();
  d.buffer = t;
  var l2 = s.createBiquadFilter();
  e = Math.min(e, t.sampleRate / 2), n = Math.min(n, t.sampleRate / 2), l2.type = "lowpass", l2.Q.value = 1e-4, l2.frequency.setValueAtTime(e, 0), l2.frequency.linearRampToValueAtTime(n, o), d.connect(l2), l2.connect(s.destination), d.start(), s.oncomplete = function(i) {
    a(i.renderedBuffer);
  }, s.startRendering(), window.filterNode = l2;
};
var sn = function(t) {
  for (var e = [], n = 0; n < t.numberOfChannels; n++)
    e[n] = t.getChannelData(n);
  return e;
};
var an = function() {
  return Math.random() * 2 - 1;
};
var be = (t) => console.log(t);
function Xe(t, e = "cyclist") {
  J(`[${e}] error: ${t.message}`);
}
var J = (...t) => be(...t);
var so = (t) => {
  be = t;
};
var dn = (t) => {
  var _a;
  if (typeof t != "string")
    return [];
  const [e, n = "", o] = ((_a = t.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)) == null ? void 0 : _a.slice(1)) || [];
  return e ? [e, n, o ? Number(o) : void 0] : [];
};
var ln = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 };
var rn = { "#": 1, b: -1, s: 1, f: -1 };
var Wt = (t, e = 3) => {
  const [n, o, a = e] = dn(t);
  if (!n)
    throw new Error('not a note: "' + t + '"');
  const c = ln[n.toLowerCase()], s = (o == null ? void 0 : o.split("").reduce((d, l2) => d + rn[l2], 0)) || 0;
  return (Number(a) + 1) * 12 + c + s;
};
var ye = (t) => Math.pow(2, (t - 69) / 12) * 440;
var $ = (t, e, n) => Math.min(Math.max(t, e), n);
var un = (t) => 12 * Math.log(t / 440) / Math.LN2 + 69;
var mn = (t, e) => {
  if (typeof t != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: o } = t;
  return typeof n == "number" ? un(n) : typeof o == "string" ? Wt(o) : typeof o == "number" ? o : e;
};
function U(t, e = 0, n) {
  return isNaN(Number(t)) ? (!n && J(`"${t}" is not a number, falling back to ${e}`, "warning"), e) : t;
}
var Ge = (t, e) => (t % e + e) % e;
var re = (t, e) => Ge(Math.round(U(t, 0)), e);
function hn(t, e) {
  return t / e;
}
typeof AudioContext < "u" && (AudioContext.prototype.adjustLength = function(t, e, n = 1, o = 0) {
  const a = Math.floor($(o, 0, 1) * e.length), c = e.sampleRate * t, s = this.createBuffer(e.numberOfChannels, e.length, e.sampleRate);
  for (let d = 0; d < e.numberOfChannels; d++) {
    let l2 = e.getChannelData(d), i = s.getChannelData(d);
    for (let r = 0; r < c; r++) {
      let h = (a + r * Math.abs(n)) % l2.length;
      n < 1 && (h = h * -1), i[r] = l2.at(h) || 0;
    }
  }
  return s;
}, AudioContext.prototype.createReverb = function(t, e, n, o, a, c, s) {
  const d = this.createConvolver();
  return d.generate = (l2 = 2, i = 0.1, r = 15e3, h = 1e3, m, u, p) => {
    d.duration = l2, d.fade = i, d.lp = r, d.dim = h, d.ir = m, d.irspeed = u, d.irbegin = p, m ? d.buffer = this.adjustLength(l2, m, u, p) : Pt.generateReverb(
      {
        audioContext: this,
        numChannels: 2,
        decayTime: l2,
        fadeInTime: i,
        lpFreqStart: r,
        lpFreqEnd: h
      },
      (Z2) => {
        d.buffer = Z2;
      }
    );
  }, d.generate(t, e, n, o, a, c, s), d;
});
var ue = {
  a: { freqs: [660, 1120, 2750, 3e3, 3350], gains: [1, 0.5012, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  e: { freqs: [440, 1800, 2700, 3e3, 3300], gains: [1, 0.1995, 0.1259, 0.1, 0.1], qs: [70, 80, 100, 120, 120] },
  i: { freqs: [270, 1850, 2900, 3350, 3590], gains: [1, 0.0631, 0.0631, 0.0158, 0.0158], qs: [40, 90, 100, 120, 120] },
  o: { freqs: [430, 820, 2700, 3e3, 3300], gains: [1, 0.3162, 0.0501, 0.0794, 0.01995], qs: [40, 80, 100, 120, 120] },
  u: { freqs: [370, 630, 2750, 3e3, 3400], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ae: { freqs: [650, 1515, 2400, 3e3, 3350], gains: [1, 0.5, 0.1008, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  aa: { freqs: [560, 900, 2570, 3e3, 3300], gains: [1, 0.5, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  oe: { freqs: [500, 1430, 2300, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ue: { freqs: [250, 1750, 2150, 3200, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  y: { freqs: [400, 1460, 2400, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  uh: { freqs: [600, 1250, 2100, 3100, 3500], gains: [1, 0.3, 0.0608, 0.0316, 0.01995], qs: [40, 70, 100, 120, 130] },
  un: { freqs: [500, 1240, 2280, 3e3, 3500], gains: [1, 0.1, 0.1708, 0.0216, 0.02995], qs: [40, 60, 100, 120, 120] },
  en: { freqs: [600, 1480, 2450, 3200, 3300], gains: [1, 0.15, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  an: { freqs: [700, 1050, 2500, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  on: { freqs: [500, 1080, 2350, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  get æ() {
    return this.ae;
  },
  get ø() {
    return this.oe;
  },
  get ɑ() {
    return this.aa;
  },
  get å() {
    return this.aa;
  },
  get ö() {
    return this.oe;
  },
  get ü() {
    return this.ue;
  },
  get ı() {
    return this.y;
  }
};
if (typeof GainNode < "u") {
  class t extends GainNode {
    constructor(n, o) {
      if (super(n), !ue[o])
        throw new Error("vowel: unknown vowel " + o);
      const { gains: a, qs: c, freqs: s } = ue[o], d = n.createGain();
      for (let l2 = 0; l2 < 5; l2++) {
        const i = n.createGain();
        i.gain.value = a[l2];
        const r = n.createBiquadFilter();
        r.type = "bandpass", r.Q.value = c[l2], r.frequency.value = s[l2], this.connect(r), r.connect(i), i.connect(d);
      }
      return d.gain.value = 8, this.connect = (l2) => d.connect(l2), this;
    }
  }
  AudioContext.prototype.createVowelFilter = function(e) {
    return new t(this, e);
  };
}
var pn = "data:text/javascript;base64,KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIGd0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuc3RhcnRlZD0hMSx0aGlzLm5iSW5wdXRzPXQubnVtYmVyT2ZJbnB1dHMsdGhpcy5uYk91dHB1dHM9dC5udW1iZXJPZk91dHB1dHMsdGhpcy5ibG9ja1NpemU9dC5wcm9jZXNzb3JPcHRpb25zLmJsb2NrU2l6ZSx0aGlzLmhvcFNpemU9MTI4LHRoaXMubmJPdmVybGFwcz10aGlzLmJsb2NrU2l6ZS90aGlzLmhvcFNpemUsdGhpcy5pbnB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpLHRoaXMuaW5wdXRCdWZmZXJzSGVhZD1uZXcgQXJyYXkodGhpcy5uYklucHV0cyksdGhpcy5pbnB1dEJ1ZmZlcnNUb1NlbmQ9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpO2ZvcihsZXQgZT0wO2U8dGhpcy5uYklucHV0cztlKyspdGhpcy5hbGxvY2F0ZUlucHV0Q2hhbm5lbHMoZSwxKTt0aGlzLm91dHB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJPdXRwdXRzKSx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlPW5ldyBBcnJheSh0aGlzLm5iT3V0cHV0cyk7Zm9yKGxldCBlPTA7ZTx0aGlzLm5iT3V0cHV0cztlKyspdGhpcy5hbGxvY2F0ZU91dHB1dENoYW5uZWxzKGUsMSl9cmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKXtmb3IobGV0IHM9MDtzPHRoaXMubmJJbnB1dHM7cysrKXtsZXQgcj10W3NdLmxlbmd0aDtyIT10aGlzLmlucHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVJbnB1dENoYW5uZWxzKHMscil9Zm9yKGxldCBzPTA7czx0aGlzLm5iT3V0cHV0cztzKyspe2xldCByPWVbc10ubGVuZ3RoO3IhPXRoaXMub3V0cHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVPdXRwdXRDaGFubmVscyhzLHIpfX1hbGxvY2F0ZUlucHV0Q2hhbm5lbHModCxlKXt0aGlzLmlucHV0QnVmZmVyc1t0XT1uZXcgQXJyYXkoZSk7Zm9yKGxldCBzPTA7czxlO3MrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKzEyOCksdGhpcy5pbnB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLmlucHV0QnVmZmVyc0hlYWRbdF09bmV3IEFycmF5KGUpLHRoaXMuaW5wdXRCdWZmZXJzVG9TZW5kW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMuaW5wdXRCdWZmZXJzSGVhZFt0XVtzXT10aGlzLmlucHV0QnVmZmVyc1t0XVtzXS5zdWJhcnJheSgwLHRoaXMuYmxvY2tTaXplKSx0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKX1hbGxvY2F0ZU91dHB1dENoYW5uZWxzKHQsZSl7dGhpcy5vdXRwdXRCdWZmZXJzW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1RvUmV0cmlldmVbdF1bc109bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJsb2NrU2l6ZSksdGhpcy5vdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZVt0XVtzXS5maWxsKDApfXJlYWRJbnB1dHModCl7aWYodFswXS5sZW5ndGgmJnRbMF1bMF0ubGVuZ3RoPT0wKXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5maWxsKDAsdGhpcy5ibG9ja1NpemUpO3JldHVybn1mb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dFtlXVtzXTt0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5zZXQocix0aGlzLmJsb2NrU2l6ZSl9fXdyaXRlT3V0cHV0cyh0KXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dGhpcy5vdXRwdXRCdWZmZXJzW2VdW3NdLnN1YmFycmF5KDAsMTI4KTt0W2VdW3NdLnNldChyKX19c2hpZnRJbnB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KX1zaGlmdE91dHB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJPdXRwdXRzO3QrKylmb3IobGV0IGU9MDtlPHRoaXMub3V0cHV0QnVmZmVyc1t0XS5sZW5ndGg7ZSsrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bZV0uc3ViYXJyYXkodGhpcy5ibG9ja1NpemUtMTI4KS5maWxsKDApfXByZXBhcmVJbnB1dEJ1ZmZlcnNUb1NlbmQoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtlXS5zZXQodGhpcy5pbnB1dEJ1ZmZlcnNIZWFkW3RdW2VdKX1oYW5kbGVPdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5uYk91dHB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5vdXRwdXRCdWZmZXJzW3RdLmxlbmd0aDtlKyspZm9yKGxldCBzPTA7czx0aGlzLmJsb2NrU2l6ZTtzKyspdGhpcy5vdXRwdXRCdWZmZXJzW3RdW2VdW3NdKz10aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdW2VdW3NdL3RoaXMubmJPdmVybGFwc31wcm9jZXNzKHQsZSxzKXtjb25zdCBvPXRbMF1bMF0hPT12b2lkIDA7cmV0dXJuIHRoaXMuc3RhcnRlZCYmIW8/ITE6KHRoaXMuc3RhcnRlZD1vLHRoaXMucmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKSx0aGlzLnJlYWRJbnB1dHModCksdGhpcy5zaGlmdElucHV0QnVmZmVycygpLHRoaXMucHJlcGFyZUlucHV0QnVmZmVyc1RvU2VuZCgpLHRoaXMucHJvY2Vzc09MQSh0aGlzLmlucHV0QnVmZmVyc1RvU2VuZCx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlLHMpLHRoaXMuaGFuZGxlT3V0cHV0QnVmZmVyc1RvUmV0cmlldmUoKSx0aGlzLndyaXRlT3V0cHV0cyhlKSx0aGlzLnNoaWZ0T3V0cHV0QnVmZmVycygpLCEwKX1wcm9jZXNzT0xBKHQsZSxzKXtjb25zb2xlLmFzc2VydCghMSwiTm90IG92ZXJyaWRlbiIpfX1jbGFzcyBJdHtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLnNpemU9dHwwLHRoaXMuc2l6ZTw9MXx8dGhpcy5zaXplJnRoaXMuc2l6ZS0xKXRocm93IG5ldyBFcnJvcigiRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMSIpO3RoaXMuX2NzaXplPXQ8PDE7Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLnNpemUqMikscz0wO3M8ZS5sZW5ndGg7cys9Mil7Y29uc3QgYT1NYXRoLlBJKnMvdGhpcy5zaXplO2Vbc109TWF0aC5jb3MoYSksZVtzKzFdPS1NYXRoLnNpbihhKX10aGlzLnRhYmxlPWU7Zm9yKHZhciByPTAsbz0xO3RoaXMuc2l6ZT5vO288PD0xKXIrKzt0aGlzLl93aWR0aD1yJTI9PT0wP3ItMTpyLHRoaXMuX2JpdHJldj1uZXcgQXJyYXkoMTw8dGhpcy5fd2lkdGgpO2Zvcih2YXIgaT0wO2k8dGhpcy5fYml0cmV2Lmxlbmd0aDtpKyspe3RoaXMuX2JpdHJldltpXT0wO2Zvcih2YXIgdT0wO3U8dGhpcy5fd2lkdGg7dSs9Mil7dmFyIGM9dGhpcy5fd2lkdGgtdS0yO3RoaXMuX2JpdHJldltpXXw9KGk+Pj51JjMpPDxjfX10aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5faW52PTB9ZnJvbUNvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHxuZXcgQXJyYXkodC5sZW5ndGg+Pj4xKSxyPTA7cjx0Lmxlbmd0aDtyKz0yKXNbcj4+PjFdPXRbcl07cmV0dXJuIHN9Y3JlYXRlQ29tcGxleEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fY3NpemUpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09MDtyZXR1cm4gdH10b0NvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHx0aGlzLmNyZWF0ZUNvbXBsZXhBcnJheSgpLHI9MDtyPHMubGVuZ3RoO3IrPTIpc1tyXT10W3I+Pj4xXSxzW3IrMV09MDtyZXR1cm4gc31jb21wbGV0ZVNwZWN0cnVtKHQpe2Zvcih2YXIgZT10aGlzLl9jc2l6ZSxzPWU+Pj4xLHI9MjtyPHM7cis9Mil0W2Utcl09dFtyXSx0W2UtcisxXT0tdFtyKzFdfXRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3RyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9cmVhbFRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3JlYWxUcmFuc2Zvcm00KCksdGhpcy5fb3V0PW51bGwsdGhpcy5fZGF0YT1udWxsfWludmVyc2VUcmFuc2Zvcm0odCxlKXtpZih0PT09ZSl0aHJvdyBuZXcgRXJyb3IoIklucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCIpO3RoaXMuX291dD10LHRoaXMuX2RhdGE9ZSx0aGlzLl9pbnY9MSx0aGlzLl90cmFuc2Zvcm00KCk7Zm9yKHZhciBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXS89dGhpcy5zaXplO3RoaXMuX291dD1udWxsLHRoaXMuX2RhdGE9bnVsbH1fdHJhbnNmb3JtNCgpe3ZhciB0PXRoaXMuX291dCxlPXRoaXMuX2NzaXplLHM9dGhpcy5fd2lkdGgscj0xPDxzLG89ZS9yPDwxLGksdSxjPXRoaXMuX2JpdHJldjtpZihvPT09NClmb3IoaT0wLHU9MDtpPGU7aSs9byx1Kyspe2NvbnN0IGQ9Y1t1XTt0aGlzLl9zaW5nbGVUcmFuc2Zvcm0yKGksZCxyKX1lbHNlIGZvcihpPTAsdT0wO2k8ZTtpKz1vLHUrKyl7Y29uc3QgZD1jW3VdO3RoaXMuX3NpbmdsZVRyYW5zZm9ybTQoaSxkLHIpfXZhciBhPXRoaXMuX2ludj8tMToxLGg9dGhpcy50YWJsZTtmb3Iocj4+PTI7cj49MjtyPj49Mil7bz1lL3I8PDE7dmFyIG09bz4+PjI7Zm9yKGk9MDtpPGU7aSs9bylmb3IodmFyIHA9aSttLGw9aSxmPTA7bDxwO2wrPTIsZis9cil7Y29uc3QgZD1sLHY9ZCttLGc9dittLEk9ZyttLGI9dFtkXSxCPXRbZCsxXSxfPXRbdl0sdz10W3YrMV0sVD10W2ddLFA9dFtnKzFdLHk9dFtJXSxBPXRbSSsxXSx4PWIsVj1CLEY9aFtmXSxNPWEqaFtmKzFdLE89XypGLXcqTSxOPV8qTSt3KkYsWT1oWzIqZl0sTD1hKmhbMipmKzFdLEg9VCpZLVAqTCxVPVQqTCtQKlksSz1oWzMqZl0sWj1hKmhbMypmKzFdLCQ9eSpLLUEqWixHPXkqWitBKkssaj14K0gsaz1WK1Usej14LUgsSj1WLVUsUT1PKyQsRT1OK0csUj1hKihPLSQpLFg9YSooTi1HKSxzdD1qK1EsaXQ9aytFLG90PWotUSxhdD1rLUUsdXQ9eitYLGh0PUotUixjdD16LVgsbHQ9SitSO3RbZF09c3QsdFtkKzFdPWl0LHRbdl09dXQsdFt2KzFdPWh0LHRbZ109b3QsdFtnKzFdPWF0LHRbSV09Y3QsdFtJKzFdPWx0fX19X3NpbmdsZVRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG89dGhpcy5fZGF0YSxpPW9bZV0sdT1vW2UrMV0sYz1vW2Urc10sYT1vW2UrcysxXSxoPWkrYyxtPXUrYSxwPWktYyxsPXUtYTtyW3RdPWgsclt0KzFdPW0sclt0KzJdPXAsclt0KzNdPWx9X3NpbmdsZVRyYW5zZm9ybTQodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG89dGhpcy5fZGF0YSxpPXRoaXMuX2ludj8tMToxLHU9cyoyLGM9cyozLGE9b1tlXSxoPW9bZSsxXSxtPW9bZStzXSxwPW9bZStzKzFdLGw9b1tlK3VdLGY9b1tlK3UrMV0sZD1vW2UrY10sdj1vW2UrYysxXSxnPWErbCxJPWgrZixiPWEtbCxCPWgtZixfPW0rZCx3PXArdixUPWkqKG0tZCksUD1pKihwLXYpLHk9ZytfLEE9SSt3LHg9YitQLFY9Qi1ULEY9Zy1fLE09SS13LE89Yi1QLE49QitUO3JbdF09eSxyW3QrMV09QSxyW3QrMl09eCxyW3QrM109VixyW3QrNF09RixyW3QrNV09TSxyW3QrNl09TyxyW3QrN109Tn1fcmVhbFRyYW5zZm9ybTQoKXt2YXIgdD10aGlzLl9vdXQsZT10aGlzLl9jc2l6ZSxzPXRoaXMuX3dpZHRoLHI9MTw8cyxvPWUvcjw8MSxpLHUsYz10aGlzLl9iaXRyZXY7aWYobz09PTQpZm9yKGk9MCx1PTA7aTxlO2krPW8sdSsrKXtjb25zdCBmdD1jW3VdO3RoaXMuX3NpbmdsZVJlYWxUcmFuc2Zvcm0yKGksZnQ+Pj4xLHI+Pj4xKX1lbHNlIGZvcihpPTAsdT0wO2k8ZTtpKz1vLHUrKyl7Y29uc3QgZnQ9Y1t1XTt0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtNChpLGZ0Pj4+MSxyPj4+MSl9dmFyIGE9dGhpcy5faW52Py0xOjEsaD10aGlzLnRhYmxlO2ZvcihyPj49MjtyPj0yO3I+Pj0yKXtvPWUvcjw8MTt2YXIgbT1vPj4+MSxwPW0+Pj4xLGw9cD4+PjE7Zm9yKGk9MDtpPGU7aSs9bylmb3IodmFyIGY9MCxkPTA7Zjw9bDtmKz0yLGQrPXIpe3ZhciB2PWkrZixnPXYrcCxJPWcrcCxiPUkrcCxCPXRbdl0sXz10W3YrMV0sdz10W2ddLFQ9dFtnKzFdLFA9dFtJXSx5PXRbSSsxXSxBPXRbYl0seD10W2IrMV0sVj1CLEY9XyxNPWhbZF0sTz1hKmhbZCsxXSxOPXcqTS1UKk8sWT13Kk8rVCpNLEw9aFsyKmRdLEg9YSpoWzIqZCsxXSxVPVAqTC15KkgsSz1QKkgreSpMLFo9aFszKmRdLCQ9YSpoWzMqZCsxXSxHPUEqWi14KiQsaj1BKiQreCpaLGs9VitVLHo9RitLLEo9Vi1VLFE9Ri1LLEU9TitHLFI9WStqLFg9YSooTi1HKSxzdD1hKihZLWopLGl0PWsrRSxvdD16K1IsYXQ9SitzdCx1dD1RLVg7aWYodFt2XT1pdCx0W3YrMV09b3QsdFtnXT1hdCx0W2crMV09dXQsZj09PTApe3ZhciBodD1rLUUsY3Q9ei1SO3RbSV09aHQsdFtJKzFdPWN0O2NvbnRpbnVlfWlmKGYhPT1sKXt2YXIgbHQ9SixFdD0tUSxSdD1rLER0PS16LHF0PS1hKnN0LFd0PS1hKlgsWXQ9LWEqUixMdD0tYSpFLEh0PWx0K3F0LFV0PUV0K1d0LEt0PVJ0K0x0LFp0PUR0LVl0LG10PWkrcC1mLHZ0PWkrbS1mO3RbbXRdPUh0LHRbbXQrMV09VXQsdFt2dF09S3QsdFt2dCsxXT1adH19fX1fc2luZ2xlUmVhbFRyYW5zZm9ybTIodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG89dGhpcy5fZGF0YSxpPW9bZV0sdT1vW2Urc10sYz1pK3UsYT1pLXU7clt0XT1jLHJbdCsxXT0wLHJbdCsyXT1hLHJbdCszXT0wfV9zaW5nbGVSZWFsVHJhbnNmb3JtNCh0LGUscyl7Y29uc3Qgcj10aGlzLl9vdXQsbz10aGlzLl9kYXRhLGk9dGhpcy5faW52Py0xOjEsdT1zKjIsYz1zKjMsYT1vW2VdLGg9b1tlK3NdLG09b1tlK3VdLHA9b1tlK2NdLGw9YSttLGY9YS1tLGQ9aCtwLHY9aSooaC1wKSxnPWwrZCxJPWYsYj0tdixCPWwtZCxfPWYsdz12O3JbdF09ZyxyW3QrMV09MCxyW3QrMl09SSxyW3QrM109YixyW3QrNF09QixyW3QrNV09MCxyW3QrNl09XyxyW3QrN109d319Y29uc3QgQz0obix0LGUpPT5NYXRoLm1pbihNYXRoLm1heChuLHQpLGUpLHB0PShuLHQpPT4obiV0K3QpJXQ7ZnVuY3Rpb24gYnQobix0PTEpe3JldHVybiBuPj10P24tPXQ6bjwwJiYobis9dCksbn1jb25zdCBEPTEyODtmdW5jdGlvbiBCdChuLHQpe3JldHVybiB0PU1hdGgubWluKHQsMS10KSxuPHQ/KG4vPXQsbituLW4qbi0xKTpuPjEtdD8obj0obi0xKS90LG4qbituK24rMSk6MH1jb25zdCBydD17dHJpKG4sdD0uNSl7Y29uc3QgZT0xLXQ7cmV0dXJuIG4+PXQ/MS9lLW4vZTpuL3R9LHNpbmUobil7cmV0dXJuIE1hdGguc2luKE1hdGguUEkqMipuKSouNSsuNX0scmFtcChuKXtyZXR1cm4gbn0sc2F3KG4pe3JldHVybiAxLW59LHNxdWFyZShuLHQ9LjUpe3JldHVybiBuPj10PzA6MX0sY3VzdG9tKG4sdD1bMCwxXSl7Y29uc3QgZT10Lmxlbmd0aC0xLHM9TWF0aC5mbG9vcihuKmUpLHI9MS9lLG89Qyh0W3NdLDAsMSksdT1DKHRbcysxXSwwLDEpLGM9byxhPTAsaD1yO3JldHVybih1LWMpLyhoLWEpKihuLXIqcykrb30sc2F3YmxlcChuLHQpe3JldHVybiAyKm4tMS1CdChuLHQpfX07ZnVuY3Rpb24gcShuLHQpe3JldHVybiB0Lmxlbmd0aD4xP3Rbbl06dFswXX1jb25zdCBfdD1PYmplY3Qua2V5cyhydCk7Y2xhc3Mgd3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiYmVnaW4iLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToidGltZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJlbmQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6LjV9LHtuYW1lOiJza2V3IixkZWZhdWx0VmFsdWU6LjV9LHtuYW1lOiJkZXB0aCIsZGVmYXVsdFZhbHVlOjF9LHtuYW1lOiJwaGFzZW9mZnNldCIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJzaGFwZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJjdXJ2ZSIsZGVmYXVsdFZhbHVlOjF9LHtuYW1lOiJkY29mZnNldCIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJtaW4iLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToibWF4IixkZWZhdWx0VmFsdWU6MX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBoYXNlfWluY3JlbWVudFBoYXNlKHQpe3RoaXMucGhhc2UrPXQsdGhpcy5waGFzZT4xJiYodGhpcy5waGFzZT10aGlzLnBoYXNlLTEpfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9cy5iZWdpblswXTtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7aWYoY3VycmVudFRpbWU8PXIpcmV0dXJuITA7Y29uc3Qgbz1lWzBdLGk9cy5mcmVxdWVuY3lbMF0sdT1zLnRpbWVbMF0sYz1zLmRlcHRoWzBdLGE9cy5za2V3WzBdLGg9cy5waGFzZW9mZnNldFswXSxtPXMuY3VydmVbMF0scD1zLmRjb2Zmc2V0WzBdLGw9cy5taW5bMF0sZj1zLm1heFswXSxkPV90W3Muc2hhcGVbMF1dLHY9b1swXS5sZW5ndGg/PzA7dGhpcy5waGFzZT09bnVsbCYmKHRoaXMucGhhc2U9cHQodSppK2gsMSkpO2NvbnN0IGc9aS9zYW1wbGVSYXRlO2ZvcihsZXQgST0wO0k8djtJKyspe2ZvcihsZXQgYj0wO2I8by5sZW5ndGg7YisrKXtsZXQgQj0ocnRbZF0odGhpcy5waGFzZSxhKStwKSpjO0I9TWF0aC5wb3coQixtKSxvW2JdW0ldPUMoQixsLGYpfXRoaXMuaW5jcmVtZW50UGhhc2UoZyl9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJsZm8tcHJvY2Vzc29yIix3dCk7Y2xhc3MgU3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiY29hcnNlIixkZWZhdWx0VmFsdWU6MX1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITF9cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLG89ZVswXSxpPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhaSlyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9aTtsZXQgdT1zLmNvYXJzZVswXT8/MDt1PU1hdGgubWF4KDEsdSk7Zm9yKGxldCBjPTA7YzxEO2MrKylmb3IobGV0IGE9MDthPHIubGVuZ3RoO2ErKylvW2FdW2NdPWMldT09PTA/clthXVtjXTpvW2FdW2MtMV07cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJjb2Fyc2UtcHJvY2Vzc29yIixTdCk7Y2xhc3MgVHQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiY3J1c2giLGRlZmF1bHRWYWx1ZTowfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbz1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2xldCB1PXMuY3J1c2hbMF0/Pzg7dT1NYXRoLm1heCgxLHUpO2ZvcihsZXQgYz0wO2M8RDtjKyspZm9yKGxldCBhPTA7YTxyLmxlbmd0aDthKyspe2NvbnN0IGg9TWF0aC5wb3coMix1LTEpO29bYV1bY109TWF0aC5yb3VuZChyW2FdW2NdKmgpL2h9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJjcnVzaC1wcm9jZXNzb3IiLFR0KTtjbGFzcyBQdCBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvcntzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJzaGFwZSIsZGVmYXVsdFZhbHVlOjB9LHtuYW1lOiJwb3N0Z2FpbiIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxvPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7bGV0IHU9cy5zaGFwZVswXTt1PXU8MT91OjEtNGUtMTAsdT0yKnUvKDEtdSk7Y29uc3QgYz1NYXRoLm1heCguMDAxLE1hdGgubWluKDEscy5wb3N0Z2FpblswXSkpO2ZvcihsZXQgYT0wO2E8RDthKyspZm9yKGxldCBoPTA7aDxyLmxlbmd0aDtoKyspb1toXVthXT0oMSt1KSpyW2hdW2FdLygxK3UqTWF0aC5hYnMocltoXVthXSkpKmM7cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJzaGFwZS1wcm9jZXNzb3IiLFB0KTtmdW5jdGlvbiBTKG4pe2NvbnN0IHQ9bipuO3JldHVybiBuKigyNyt0KS8oMjcrOSp0KX1jb25zdCBkdD0zLjE0MTU5MjY1MzU5O2NsYXNzIHl0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOjUwMH0se25hbWU6InEiLGRlZmF1bHRWYWx1ZToxfSx7bmFtZToiZHJpdmUiLGRlZmF1bHRWYWx1ZTouNjl9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExLHRoaXMucDA9WzAsMF0sdGhpcy5wMT1bMCwwXSx0aGlzLnAyPVswLDBdLHRoaXMucDM9WzAsMF0sdGhpcy5wMzI9WzAsMF0sdGhpcy5wMzM9WzAsMF0sdGhpcy5wMzQ9WzAsMF19cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLG89ZVswXSxpPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhaSlyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9aTtjb25zdCB1PXMucVswXSxjPUMoTWF0aC5leHAocy5kcml2ZVswXSksLjEsMmUzKTtsZXQgYT1zLmZyZXF1ZW5jeVswXTthPWEqMipkdC9zYW1wbGVSYXRlLGE9YT4xPzE6YTtjb25zdCBoPU1hdGgubWluKDgsdSouMTMpO2xldCBtPTEvYypNYXRoLm1pbigxLjc1LDEraCk7Zm9yKGxldCBwPTA7cDxEO3ArKylmb3IobGV0IGw9MDtsPHIubGVuZ3RoO2wrKyl7Y29uc3QgZj10aGlzLnAzW2xdKi4zNjA4OTErdGhpcy5wMzJbbF0qLjQxNzI5K3RoaXMucDMzW2xdKi4xNzc4OTYrdGhpcy5wMzRbbF0qLjA0Mzk3MjU7dGhpcy5wMzRbbF09dGhpcy5wMzNbbF0sdGhpcy5wMzNbbF09dGhpcy5wMzJbbF0sdGhpcy5wMzJbbF09dGhpcy5wM1tsXSx0aGlzLnAwW2xdKz0oUyhyW2xdW3BdKmMtaCpmKS1TKHRoaXMucDBbbF0pKSphLHRoaXMucDFbbF0rPShTKHRoaXMucDBbbF0pLVModGhpcy5wMVtsXSkpKmEsdGhpcy5wMltsXSs9KFModGhpcy5wMVtsXSktUyh0aGlzLnAyW2xdKSkqYSx0aGlzLnAzW2xdKz0oUyh0aGlzLnAyW2xdKS1TKHRoaXMucDNbbF0pKSphLG9bbF1bcF09ZiptfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigibGFkZGVyLXByb2Nlc3NvciIseXQpO2NsYXNzIEF0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImRpc3RvcnQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToicG9zdGdhaW4iLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbz1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2NvbnN0IHU9TWF0aC5leHBtMShzLmRpc3RvcnRbMF0pLGM9TWF0aC5tYXgoLjAwMSxNYXRoLm1pbigxLHMucG9zdGdhaW5bMF0pKTtmb3IobGV0IGE9MDthPEQ7YSsrKWZvcihsZXQgaD0wO2g8ci5sZW5ndGg7aCsrKW9baF1bYV09KDErdSkqcltoXVthXS8oMSt1Kk1hdGguYWJzKHJbaF1bYV0pKSpjO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiZGlzdG9ydC1wcm9jZXNzb3IiLEF0KTtmdW5jdGlvbiB4dChuLHQsZSl7cmV0dXJuIGUqKHQtbikrbn1mdW5jdGlvbiBWdChuLHQsZSl7cmV0dXJuIG48Mj8wOnh0KC10Ki41LHQqLjUsZS8obi0xKSl9ZnVuY3Rpb24gdHQobix0KXtyZXR1cm4gbipNYXRoLnBvdygyLHQvMTIpfWNsYXNzIEZ0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBoYXNlPVtdfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6InBhbnNwcmVhZCIsZGVmYXVsdFZhbHVlOi40LG1pbjowLG1heDoxfSx7bmFtZToiZnJlcXNwcmVhZCIsZGVmYXVsdFZhbHVlOi4yLG1pbjowfSx7bmFtZToiZGV0dW5lIixkZWZhdWx0VmFsdWU6MCxtaW46MH0se25hbWU6InZvaWNlcyIsZGVmYXVsdFZhbHVlOjUsbWluOjF9XX1wcm9jZXNzKHQsZSxzKXtpZihjdXJyZW50VGltZTw9cy5iZWdpblswXSlyZXR1cm4hMDtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7Y29uc3Qgcj1lWzBdLG89cy52b2ljZXNbMF0saT1zLmZyZXFzcHJlYWRbMF0sdT1zLnBhbnNwcmVhZFswXSouNSsuNSxjPU1hdGguc3FydCgxLXUpLGE9TWF0aC5zcXJ0KHUpO2ZvcihsZXQgaD0wO2g8bztoKyspe2NvbnN0IG09KGgmMSk9PTE7bGV0IHA9YyxsPWE7bSYmKHA9YSxsPWMpO2ZvcihsZXQgZj0wO2Y8clswXS5sZW5ndGg7ZisrKXtsZXQgZD10dChzLmZyZXF1ZW5jeVtmXT8/cy5mcmVxdWVuY3lbMF0scy5kZXR1bmVbMF0vMTAwKTtkPXR0KGQsVnQobyxpLGgpKTtjb25zdCB2PXB0KGQvc2FtcGxlUmF0ZSwxKTt0aGlzLnBoYXNlW2hdPXRoaXMucGhhc2VbaF0/P01hdGgucmFuZG9tKCk7Y29uc3QgZz1ydC5zYXdibGVwKHRoaXMucGhhc2VbaF0sdik7clswXVtmXT1yWzBdW2ZdK2cqcCxyWzFdW2ZdPXJbMV1bZl0rZypsLHRoaXMucGhhc2VbaF09YnQodGhpcy5waGFzZVtoXSt2KX19cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJzdXBlcnNhdy1vc2NpbGxhdG9yIixGdCk7Y29uc3QgTXQ9MjA0ODtmdW5jdGlvbiBPdChuKXtsZXQgdD1uZXcgRmxvYXQzMkFycmF5KG4pO2Zvcih2YXIgZT0wO2U8bjtlKyspdFtlXT0uNSooMS1NYXRoLmNvcygyKk1hdGguUEkqZS9uKSk7cmV0dXJuIHR9Y2xhc3MgTnQgZXh0ZW5kcyBndHtzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJwaXRjaEZhY3RvciIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcih0KXt0LnByb2Nlc3Nvck9wdGlvbnM9e2Jsb2NrU2l6ZTpNdH0sc3VwZXIodCksdGhpcy5mZnRTaXplPXRoaXMuYmxvY2tTaXplLHRoaXMudGltZUN1cnNvcj0wLHRoaXMuaGFubldpbmRvdz1PdCh0aGlzLmJsb2NrU2l6ZSksdGhpcy5mZnQ9bmV3IEl0KHRoaXMuZmZ0U2l6ZSksdGhpcy5mcmVxQ29tcGxleEJ1ZmZlcj10aGlzLmZmdC5jcmVhdGVDb21wbGV4QXJyYXkoKSx0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZD10aGlzLmZmdC5jcmVhdGVDb21wbGV4QXJyYXkoKSx0aGlzLnRpbWVDb21wbGV4QnVmZmVyPXRoaXMuZmZ0LmNyZWF0ZUNvbXBsZXhBcnJheSgpLHRoaXMubWFnbml0dWRlcz1uZXcgRmxvYXQzMkFycmF5KHRoaXMuZmZ0U2l6ZS8yKzEpLHRoaXMucGVha0luZGV4ZXM9bmV3IEludDMyQXJyYXkodGhpcy5tYWduaXR1ZGVzLmxlbmd0aCksdGhpcy5uYlBlYWtzPTB9cHJvY2Vzc09MQSh0LGUscyl7bGV0IHI9cy5waXRjaEZhY3RvcltzLnBpdGNoRmFjdG9yLmxlbmd0aC0xXTtyPDAmJihyPXIqLjI1KSxyPU1hdGgubWF4KDAscisxKTtmb3IodmFyIG89MDtvPHRoaXMubmJJbnB1dHM7bysrKWZvcih2YXIgaT0wO2k8dFtvXS5sZW5ndGg7aSsrKXt2YXIgdT10W29dW2ldLGM9ZVtvXVtpXTt0aGlzLmFwcGx5SGFubldpbmRvdyh1KSx0aGlzLmZmdC5yZWFsVHJhbnNmb3JtKHRoaXMuZnJlcUNvbXBsZXhCdWZmZXIsdSksdGhpcy5jb21wdXRlTWFnbml0dWRlcygpLHRoaXMuZmluZFBlYWtzKCksdGhpcy5zaGlmdFBlYWtzKHIpLHRoaXMuZmZ0LmNvbXBsZXRlU3BlY3RydW0odGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQpLHRoaXMuZmZ0LmludmVyc2VUcmFuc2Zvcm0odGhpcy50aW1lQ29tcGxleEJ1ZmZlcix0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZCksdGhpcy5mZnQuZnJvbUNvbXBsZXhBcnJheSh0aGlzLnRpbWVDb21wbGV4QnVmZmVyLGMpLHRoaXMuYXBwbHlIYW5uV2luZG93KGMpfXRoaXMudGltZUN1cnNvcis9dGhpcy5ob3BTaXplfWFwcGx5SGFubldpbmRvdyh0KXtmb3IodmFyIGU9MDtlPHRoaXMuYmxvY2tTaXplO2UrKyl0W2VdPXRbZV0qdGhpcy5oYW5uV2luZG93W2VdKjEuNjJ9Y29tcHV0ZU1hZ25pdHVkZXMoKXtmb3IodmFyIHQ9MCxlPTA7dDx0aGlzLm1hZ25pdHVkZXMubGVuZ3RoOyl7bGV0IHM9dGhpcy5mcmVxQ29tcGxleEJ1ZmZlcltlXSxyPXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbZSsxXTt0aGlzLm1hZ25pdHVkZXNbdF09cyoqMityKioyLHQrPTEsZSs9Mn19ZmluZFBlYWtzKCl7dGhpcy5uYlBlYWtzPTA7dmFyIHQ9MjtsZXQgZT10aGlzLm1hZ25pdHVkZXMubGVuZ3RoLTI7Zm9yKDt0PGU7KXtsZXQgcz10aGlzLm1hZ25pdHVkZXNbdF07aWYodGhpcy5tYWduaXR1ZGVzW3QtMV0+PXN8fHRoaXMubWFnbml0dWRlc1t0LTJdPj1zKXt0Kys7Y29udGludWV9aWYodGhpcy5tYWduaXR1ZGVzW3QrMV0+PXN8fHRoaXMubWFnbml0dWRlc1t0KzJdPj1zKXt0Kys7Y29udGludWV9dGhpcy5wZWFrSW5kZXhlc1t0aGlzLm5iUGVha3NdPXQsdGhpcy5uYlBlYWtzKyssdCs9Mn19c2hpZnRQZWFrcyh0KXt0aGlzLmZyZXFDb21wbGV4QnVmZmVyU2hpZnRlZC5maWxsKDApO2Zvcih2YXIgZT0wO2U8dGhpcy5uYlBlYWtzO2UrKyl7bGV0IGk9dGhpcy5wZWFrSW5kZXhlc1tlXSx1PU1hdGgucm91bmQoaSp0KTtpZih1PnRoaXMubWFnbml0dWRlcy5sZW5ndGgpYnJlYWs7dmFyIHM9MCxyPXRoaXMuZmZ0U2l6ZTtpZihlPjApe2xldCBoPXRoaXMucGVha0luZGV4ZXNbZS0xXTtzPWktTWF0aC5mbG9vcigoaS1oKS8yKX1pZihlPHRoaXMubmJQZWFrcy0xKXtsZXQgaD10aGlzLnBlYWtJbmRleGVzW2UrMV07cj1pK01hdGguY2VpbCgoaC1pKS8yKX1sZXQgYz1zLWksYT1yLWk7Zm9yKHZhciBvPWM7bzxhO28rKyl7bGV0IGg9aStvLG09dStvO2lmKG0+PXRoaXMubWFnbml0dWRlcy5sZW5ndGgpYnJlYWs7bGV0IHA9MipNYXRoLlBJKihtLWgpL3RoaXMuZmZ0U2l6ZSxsPU1hdGguY29zKHAqdGhpcy50aW1lQ3Vyc29yKSxmPU1hdGguc2luKHAqdGhpcy50aW1lQ3Vyc29yKSxkPWgqMix2PWQrMSxnPXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbZF0sST10aGlzLmZyZXFDb21wbGV4QnVmZmVyW3ZdLGI9ZypsLUkqZixCPWcqZitJKmwsXz1tKjIsdz1fKzE7dGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWRbX10rPWIsdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWRbd10rPUJ9fX19cmVnaXN0ZXJQcm9jZXNzb3IoInBoYXNlLXZvY29kZXItcHJvY2Vzc29yIixOdCk7Y2xhc3MgQ3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucGk9ZHQsdGhpcy5waGk9LXRoaXMucGksdGhpcy5ZMD0wLHRoaXMuWTE9MCx0aGlzLlBXPXRoaXMucGksdGhpcy5CPTIuMyx0aGlzLmRwaGlmPTAsdGhpcy5lbnZmPTB9c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToiYmVnaW4iLGRlZmF1bHRWYWx1ZTowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWluOjB9LHtuYW1lOiJlbmQiLGRlZmF1bHRWYWx1ZTowLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWluOjB9LHtuYW1lOiJmcmVxdWVuY3kiLGRlZmF1bHRWYWx1ZTo0NDAsbWluOk51bWJlci5FUFNJTE9OfSx7bmFtZToiZGV0dW5lIixkZWZhdWx0VmFsdWU6MCxtaW46TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLG1heDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9LHtuYW1lOiJwdWxzZXdpZHRoIixkZWZhdWx0VmFsdWU6MSxtaW46MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfV19cHJvY2Vzcyh0LGUscyl7aWYodGhpcy5kaXNjb25uZWN0ZWQpcmV0dXJuITE7aWYoY3VycmVudFRpbWU8PXMuYmVnaW5bMF0pcmV0dXJuITA7aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO2NvbnN0IHI9ZVswXTtsZXQgbz0xLGk7Zm9yKGxldCB1PTA7dTwoclswXS5sZW5ndGg/PzApO3UrKyl7Y29uc3QgYz0oMS1DKHEodSxzLnB1bHNld2lkdGgpLC0uOTksLjk5KSkqdGhpcy5waSxhPXEodSxzLmRldHVuZSksaD10dChxKHUscy5mcmVxdWVuY3kpLGEvMTAwKTtpPWgqKHRoaXMucGkvKHNhbXBsZVJhdGUqLjUpKSx0aGlzLmRwaGlmKz0uMSooaS10aGlzLmRwaGlmKSxvKj0uOTk5OCx0aGlzLmVudmYrPS4xKihvLXRoaXMuZW52ZiksdGhpcy5CPTIuMyooMS0xZS00KmgpLHRoaXMuQjwwJiYodGhpcy5CPTApLHRoaXMucGhpKz10aGlzLmRwaGlmLHRoaXMucGhpPj10aGlzLnBpJiYodGhpcy5waGktPTIqdGhpcy5waSk7bGV0IG09TWF0aC5jb3ModGhpcy5waGkrdGhpcy5CKnRoaXMuWTApO3RoaXMuWTA9LjUqKG0rdGhpcy5ZMCk7bGV0IHA9TWF0aC5jb3ModGhpcy5waGkrdGhpcy5CKnRoaXMuWTErYyk7dGhpcy5ZMT0uNSoocCt0aGlzLlkxKTtmb3IobGV0IGw9MDtsPHIubGVuZ3RoO2wrKylyW2xdW3VdPS4xNSoobS1wKSp0aGlzLmVudmZ9cmV0dXJuITB9fXJlZ2lzdGVyUHJvY2Vzc29yKCJwdWxzZS1vc2NpbGxhdG9yIixDdCk7Y29uc3QgbnQ9e2JpdEM6ZnVuY3Rpb24obix0LGUpe3JldHVybiBuJnQ/ZTowfSxicjpmdW5jdGlvbihuLHQ9OCl7aWYodD4zMil0aHJvdyBuZXcgRXJyb3IoImJyKCkgU2l6ZSBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIDMyIik7e2xldCBlPTA7Zm9yKGxldCBzPTA7czx0LTA7cysrKWUrPW50LmJpdEMobiwyKipzLDIqKih0LShzKzEpKSk7cmV0dXJuIGV9fSxzaW5mOmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLnNpbihuLygxMjgvTWF0aC5QSSkpfSxjb3NmOmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLmNvcyhuLygxMjgvTWF0aC5QSSkpfSx0YW5mOmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLnRhbihuLygxMjgvTWF0aC5QSSkpfSxyZWdHOmZ1bmN0aW9uKG4sdCl7cmV0dXJuIHQudGVzdChuLnRvU3RyaW5nKDIpKX19O2xldCBXLGV0O2Z1bmN0aW9uIGt0KG4pe2lmKChXfHxldCk9PW51bGwpe1c9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWF0aCksZXQ9Vy5tYXAocz0+TWF0aFtzXSk7Y29uc3QgdD1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhudCksZT10Lm1hcChzPT5udFtzXSk7Vy5wdXNoKCJpbnQiLCJ3aW5kb3ciLC4uLnQpLGV0LnB1c2goTWF0aC5mbG9vcixnbG9iYWxUaGlzLC4uLmUpfXJldHVybiBuZXcgRnVuY3Rpb24oLi4uVywidCIsYHJldHVybiAwLAoke258fDB9O2ApLmJpbmQoZ2xvYmFsVGhpcywuLi5ldCl9Y2xhc3MgenQgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucG9ydC5vbm1lc3NhZ2U9dD0+e2xldHtjb2RlVGV4dDplfT10LmRhdGE7Y29uc3R7Ynl0ZUJlYXRTdGFydFRpbWU6c309dC5kYXRhO3MhPW51bGwmJih0aGlzLnQ9MCx0aGlzLmluaXRpYWxPZmZzZXQ9TWF0aC5mbG9vcihzKSksZT1lLnRyaW0oKS5yZXBsYWNlKC9eZXZhbFwodW5lc2NhcGVcKGVzY2FwZSg/OmB8XCgnfFwoInxcKGApKC4qPykoPzpgfCdcKXwiXCl8YFwpKS5yZXBsYWNlXChcL3VcKFwuXC5cKVwvZyxbIidgXVwkMSVbIidgXVwpXClcKSQvLChyLG8pPT51bmVzY2FwZShlc2NhcGUobykucmVwbGFjZSgvdSguLikvZywiJDElIikpKSx0aGlzLmZ1bmM9a3QoZSl9LHRoaXMuaW5pdGlhbE9mZnNldD1udWxsLHRoaXMudD1udWxsLHRoaXMuZnVuYz1udWxsfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6ImRldHVuZSIsZGVmYXVsdFZhbHVlOjAsbWluOk51bWJlci5ORUdBVElWRV9JTkZJTklUWSxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfV19cHJvY2Vzcyh0LGUscyl7aWYodGhpcy5kaXNjb25uZWN0ZWQpcmV0dXJuITE7aWYoY3VycmVudFRpbWU8PXMuYmVnaW5bMF0pcmV0dXJuITA7aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO3RoaXMudD09bnVsbCYmKHRoaXMudD1zLmJlZ2luWzBdKnNhbXBsZVJhdGUpO2NvbnN0IHI9ZVswXTtmb3IobGV0IG89MDtvPHJbMF0ubGVuZ3RoO28rKyl7Y29uc3QgaT1xKG8scy5kZXR1bmUpLHU9dHQocShvLHMuZnJlcXVlbmN5KSxpLzEwMCk7bGV0IGM9dGhpcy50LyhzYW1wbGVSYXRlLzI1NikqdSt0aGlzLmluaXRpYWxPZmZzZXQ7Y29uc3QgbT0oKHRoaXMuZnVuYyhjKSYyNTUpLzEyNy41LTEpKi4yO2ZvcihsZXQgcD0wO3A8ci5sZW5ndGg7cCsrKXJbcF1bb109QyhtLC0uNCwuNCk7dGhpcy50PXRoaXMudCsxfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiYnl0ZS1iZWF0LXByb2Nlc3NvciIsenQpfSkoKTsK";
var Yt = {};
function Ve(t, e) {
  const n = W();
  if (Yt[t])
    return Yt[t];
  const o = 2 * n.sampleRate, a = n.createBuffer(1, o, n.sampleRate), c = a.getChannelData(0);
  let s = 0, d, l2, i, r, h, m, u;
  d = l2 = i = r = h = m = u = 0;
  for (let p = 0; p < o; p++)
    if (t === "white")
      c[p] = Math.random() * 2 - 1;
    else if (t === "brown") {
      let Z2 = Math.random() * 2 - 1;
      c[p] = (s + 0.02 * Z2) / 1.02, s = c[p];
    } else if (t === "pink") {
      let Z2 = Math.random() * 2 - 1;
      d = 0.99886 * d + Z2 * 0.0555179, l2 = 0.99332 * l2 + Z2 * 0.0750759, i = 0.969 * i + Z2 * 0.153852, r = 0.8665 * r + Z2 * 0.3104856, h = 0.55 * h + Z2 * 0.5329522, m = -0.7616 * m - Z2 * 0.016898, c[p] = d + l2 + i + r + h + m + u + Z2 * 0.5362, c[p] *= 0.11, u = Z2 * 0.115926;
    } else if (t === "crackle") {
      const Z2 = e * 0.01;
      Math.random() < Z2 ? c[p] = Math.random() * 2 - 1 : c[p] = 0;
    }
  return t !== "crackle" && (Yt[t] = a), a;
}
function Jt(t = "white", e, n = 0.02) {
  const a = W().createBufferSource();
  return a.buffer = Ve(t, n), a.loop = true, a.start(e), {
    node: a,
    stop: (c) => a.stop(c)
  };
}
function Zn(t, e, n) {
  const o = Jt("pink", n);
  return {
    node: Xn(t, o.node, e),
    stop: (c) => o == null ? void 0 : o.stop(c)
  };
}
var fe = ["pink", "white", "brown", "crackle"];
function H(t) {
  const e = W().createGain();
  return e.gain.value = t, e;
}
var me = (t, e, n, o) => o - n === 0 ? 0 : (e - t) / (o - n);
function I(t, e, n, o) {
  const a = new AudioWorkletNode(t, e, o);
  return Object.entries(n).forEach(([c, s]) => {
    a.parameters.get(c).value = s;
  }), a;
}
var Q = (t, e, n, o, a, c, s, d, l2, i = "exponential") => {
  e = U(e), n = U(n), o = U(o), a = U(a);
  const r = i === "exponential" ? "exponentialRampToValueAtTime" : "linearRampToValueAtTime";
  i === "exponential" && (c = c === 0 ? 1e-3 : c, s = s === 0 ? 1e-3 : s);
  const h = s - c, m = s, u = c + o * h, p = l2 - d, Z2 = (X) => {
    let y;
    if (e > X) {
      let b = me(c, m, 0, e);
      y = X * b + (c > m ? c : 0);
    } else
      y = (X - e) * me(m, u, 0, n) + m;
    return i === "exponential" && (y = y || 1e-3), y;
  };
  t.setValueAtTime(c, d), e > p ? t[r](Z2(p), l2) : e + n > p ? (t[r](Z2(e), d + e), t[r](Z2(p), l2)) : (t[r](Z2(e), d + e), t[r](Z2(e + n), d + e + n), t.setValueAtTime(u, l2)), t[r](c, l2 + a);
};
function bn(t, e, n, o, a, c) {
  const s = {
    threshold: e ?? -3,
    ratio: n ?? 10,
    knee: o ?? 10,
    attack: a ?? 5e-3,
    release: c ?? 0.05
  };
  return new DynamicsCompressorNode(t, s);
}
var B = (t, e = "linear", n) => {
  const [s, d, l2, i] = t;
  if (s == null && d == null && l2 == null && i == null)
    return n ?? [1e-3, 1e-3, 1, 0.01];
  const r = l2 ?? (s != null && d == null || s == null && d == null ? 1 : 1e-3);
  return [Math.max(s ?? 0, 1e-3), Math.max(d ?? 0, 1e-3), Math.min(r, 1), Math.max(i ?? 0, 0.01)];
};
function St(t, e, n, o, a, c, s, d, l2, i, r, h, m, u) {
  const p = "exponential", [Z2, X, y, b] = B([a, c, s, d], p, [5e-3, 0.14, 0, 0.1]);
  let V2, g;
  if (m === "ladder" ? (V2 = I(t, "ladder-processor", { frequency: n, q: o, drive: u }), g = V2.parameters.get("frequency")) : (V2 = t.createBiquadFilter(), V2.type = e, V2.Q.value = o, V2.frequency.value = n, g = V2.frequency), (a ?? c ?? s ?? d ?? l2) !== void 0) {
    l2 = U(l2, 1, true), h = U(h, 0, true);
    const M = Math.abs(l2), w = M * h;
    let Y = $(2 ** -w * n, 0, 2e4), F2 = $(2 ** (M - w) * n, 0, 2e4);
    return l2 < 0 && ([Y, F2] = [F2, Y]), Q(g, Z2, X, y, b, Y, F2, i, r, p), V2;
  }
  return V2;
}
var he = (t) => t < 0.5 ? 1 : 1 - (t - 0.5) / 0.5;
function Xn(t, e, n = 0) {
  const o = W();
  if (!n)
    return t;
  let a = o.createGain(), c = o.createGain();
  t.connect(a), e.connect(c), a.gain.value = he(n), c.gain.value = he(1 - n);
  let s = o.createGain();
  return a.connect(s), c.connect(s), s;
}
var yn = ["linear", "exponential"];
function Xt(t, e, n, o) {
  if (!(e.pattack ?? e.pdecay ?? e.psustain ?? e.prelease ?? e.penv))
    return;
  const c = U(e.penv, 1, true), s = yn[e.pcurve ?? 0];
  let [d, l2, i, r] = B(
    [e.pattack, e.pdecay, e.psustain, e.prelease],
    s,
    [0.2, 1e-3, 1, 1e-3]
  ), h = e.panchor ?? i;
  const m = c * 100, u = 0 - m * h, p = m - m * h;
  Q(t, d, l2, i, r, u, p, n, o, s);
}
function yt(t, e, n) {
  const { vibmod: o = 0.5, vib: a } = e;
  let c;
  if (a > 0) {
    c = W().createOscillator(), c.frequency.value = a;
    const s = W().createGain();
    return s.gain.value = o * 100, c.connect(s), s.connect(t), c.start(n), c;
  }
}
function bt(t, e, n, o) {
  const a = new ConstantSourceNode(t), c = H(0);
  return c.connect(t.destination), a.connect(c), a.onended = () => {
    try {
      c.disconnect();
    } catch {
    }
    try {
      a.disconnect();
    } catch {
    }
    e();
  }, a.start(n), a.stop(o), a;
}
var Gn = (t, e = 1, n = "sine") => {
  const o = W();
  let a;
  fe.includes(n) ? (a = o.createBufferSource(), a.buffer = Ve(n, 2), a.loop = true) : (a = o.createOscillator(), a.type = n, a.frequency.value = t), a.start();
  const c = new GainNode(o, { gain: e });
  return a.connect(c), { node: c, stop: (s) => a.stop(s) };
};
var Vn = (t, e, n, o = "sine") => {
  const c = t.value * e, s = c * n;
  return Gn(c, s, o);
};
function Nt(t, e, n) {
  const {
    fmh: o = 1,
    fmi: a,
    fmenv: c = "exp",
    fmattack: s,
    fmdecay: d,
    fmsustain: l2,
    fmrelease: i,
    fmvelocity: r,
    fmwave: h = "sine",
    duration: m
  } = e;
  let u, p = () => {
  };
  if (a) {
    const X = W().createGain(), y = Vn(t, o, a, h);
    if (u = y.node, p = y.stop, ![s, d, l2, i, r].some((b) => b !== void 0))
      u.connect(t);
    else {
      const [b, V2, g, f2] = B([s, d, l2, i]), M = n + m;
      Q(
        X.gain,
        b,
        V2,
        g,
        f2,
        0,
        1,
        n,
        M,
        c === "exp" ? "exponential" : "linear"
      ), u.connect(X), X.connect(t);
    }
  }
  return { stop: p };
}
var It = {};
var Ft = {};
var ao = (t) => It[t];
function fn(t, e) {
  var n = 1024;
  if (t < n) return t + " B";
  var o = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], a = -1;
  do
    t /= n, ++a;
  while (t >= n);
  return t.toFixed(1) + " " + o[a];
}
function Wn(t, e) {
  const { s: n, n: o = 0, speed: a = 1 } = t;
  let c = mn(t, 36), s = c - 36, d, l2 = 0;
  if (Array.isArray(e))
    l2 = re(o, e.length), d = e[l2];
  else {
    const h = (u) => Wt(u) - c, m = Object.keys(e).filter((u) => !u.startsWith("_")).reduce(
      (u, p, Z2) => !u || Math.abs(h(p)) < Math.abs(h(u)) ? p : u,
      null
    );
    s = -h(m), l2 = re(o, e[m].length), d = e[m][l2];
  }
  const i = `${n}:${l2}`;
  let r = Math.abs(a) * Math.pow(2, s / 12);
  return { transpose: s, sampleUrl: d, index: l2, midi: c, label: i, playbackRate: r };
}
var xn = async (t, e, n) => {
  let { sampleUrl: o, label: a, playbackRate: c } = Wn(t, e);
  n && (o = await n(o));
  const s = W(), d = await We(o, s, a);
  return t.unit === "c" && (c = c * d.duration), { buffer: d, playbackRate: c };
};
var gn = async (t, e, n) => {
  let { buffer: o, playbackRate: a } = await xn(t, e, n);
  t.speed < 0 && (o = Mn(o));
  const s = W().createBufferSource();
  s.buffer = o, s.playbackRate.value = a;
  const { s: d, loopBegin: l2 = 0, loopEnd: i = 1, begin: r = 0, end: h = 1 } = t, m = r * s.buffer.duration;
  (d.startsWith("wt_") ? 1 : t.loop) && (s.loop = true, s.loopStart = l2 * s.buffer.duration - m, s.loopEnd = i * s.buffer.duration - m);
  const p = s.buffer.duration / s.playbackRate.value, Z2 = (h - r) * p;
  return { bufferSource: s, offset: m, bufferDuration: p, sliceDuration: Z2 };
};
var We = (t, e, n, o = 0) => {
  const a = n ? `sound "${n}:${o}"` : "sample";
  if (t = t.replace("#", "%23"), !Ft[t]) {
    J(`[sampler] load ${a}..`, "load-sample", { url: t });
    const c = Date.now();
    Ft[t] = fetch(t).then((s) => s.arrayBuffer()).then(async (s) => {
      const d = Date.now() - c, l2 = fn(s.byteLength);
      J(`[sampler] load ${a}... done! loaded ${l2} in ${d}ms`, "loaded-sample", { url: t });
      const i = await e.decodeAudioData(s);
      return It[t] = i, i;
    });
  }
  return Ft[t];
};
function Mn(t) {
  const e = W(), n = e.createBuffer(t.numberOfChannels, t.length, e.sampleRate);
  for (let o = 0; o < t.numberOfChannels; o++)
    n.copyToChannel(t.getChannelData(o).slice().reverse(), o, o);
  return n;
}
var lo = (t) => It[t];
function xe(t) {
  if (t.startsWith("bubo:")) {
    const [e, n] = t.split(":");
    t = `github:Bubobubobubobubo/dough-${n}`;
  }
  return t;
}
function ge(t, e = "") {
  if (!t.startsWith("github:"))
    throw new Error('expected "github:" at the start of pseudoUrl');
  let [n, o] = t.split("github:");
  return o = o.endsWith("/") ? o.slice(0, -1) : o, o.split("/").length === 2 && (o += "/main"), `https://raw.githubusercontent.com/${o}/${e}`;
}
var Rn = (t, e, n = t._base || "") => Object.entries(t).forEach(([o, a]) => {
  if (typeof a == "string" && (a = [a]), typeof a != "object")
    throw new Error("wrong sample map format for " + o);
  n = a._base || n, n = xe(n), n.startsWith("github:") && (n = ge(n, ""));
  const c = (s) => n + s;
  Array.isArray(a) ? a = a.map(c) : a = Object.fromEntries(
    Object.entries(a).map(([s, d]) => [s, (typeof d == "string" ? [d] : d).map(c)])
  ), e(o, a);
});
var Me = {};
function io(t, e) {
  Me[t] = e;
}
function zn(t) {
  const e = Object.entries(Me).find(([n]) => t.startsWith(n));
  if (e)
    return e[1];
}
var Ln = async (t, e = t._base || "", n = {}) => {
  if (typeof t == "string") {
    const c = zn(t);
    if (c)
      return c(t);
    if (t = xe(t), t.startsWith("github:") && (t = ge(t, "strudel.json")), t.startsWith("local:") && (t = "http://localhost:5432"), t.startsWith("shabda:")) {
      let [d, l2] = t.split("shabda:");
      t = `https://shabda.ndre.gr/${l2}.json?strudel=1`;
    }
    if (t.startsWith("shabda/speech")) {
      let [d, l2] = t.split("shabda/speech");
      l2 = l2.startsWith("/") ? l2.substring(1) : l2;
      let [i, r] = l2.split(":"), h = "f", m = "en-GB";
      i && ([m, h] = i.split("/")), t = `https://shabda.ndre.gr/speech/${r}.json?gender=${h}&language=${m}&strudel=1'`;
    }
    if (typeof fetch != "function")
      return;
    const s = t.split("/").slice(0, -1).join("/");
    return typeof fetch > "u" ? void 0 : fetch(t).then((d) => d.json()).then((d) => Ln(d, e || d._base || s, n)).catch((d) => {
      throw console.error(d), new Error(`error loading "${t}"`);
    });
  }
  const { prebake: o, tag: a } = n;
  Rn(
    t,
    (c, s) => q(c, (d, l2, i) => Yn(d, l2, i, s), {
      type: "sample",
      samples: s,
      baseUrl: e,
      prebake: o,
      tag: a
    }),
    e
  );
};
var pe = [];
async function Yn(t, e, n, o, a) {
  let {
    s: c,
    nudge: s = 0,
    // TODO: is this in seconds?
    cut: d,
    loop: l2,
    clip: i = void 0,
    // if set, samples will be cut off when the hap ends
    n: r = 0,
    speed: h = 1,
    // sample playback speed
    duration: m
  } = e;
  if (h === 0)
    return;
  const u = W();
  let [p, Z2, X, y] = B([e.attack, e.decay, e.sustain, e.release]);
  const { bufferSource: b, sliceDuration: V2, offset: g } = await gn(e, o, a);
  if (u.currentTime > t) {
    J(`[sampler] still loading sound "${c}:${r}"`, "highlight");
    return;
  }
  if (!b) {
    J(`[sampler] could not load "${c}:${r}"`, "error");
    return;
  }
  let f2 = yt(b.detune, e, t);
  const M = t + s;
  b.start(M, g);
  const w = u.createGain(), Y = b.connect(w);
  i == null && l2 == null && e.release == null && (m = V2);
  let F2 = t + m;
  Q(Y.gain, p, Z2, X, y, 0, 1, t, F2, "linear"), Xt(b.detune, e, t, F2);
  const S2 = u.createGain();
  Y.connect(S2), b.onended = function() {
    b.disconnect(), f2 == null ? void 0 : f2.stop(), Y.disconnect(), S2.disconnect(), n();
  };
  let O2 = F2 + y + 0.01;
  b.stop(O2);
  const T2 = { node: S2, bufferSource: b, stop: (k) => {
    b.stop(k);
  } };
  if (d !== void 0) {
    const k = pe[d];
    k && (k.node.gain.setValueAtTime(1, M), k.node.gain.linearRampToValueAtTime(0, M + 0.01)), pe[d] = T2;
  }
  return T2;
}
var Re = 128;
var Ct = "System Standard";
var ze = Re;
function Sn(t) {
  ze = parseInt(t) ?? Re;
}
var Le = false;
function Fn(t) {
  Le = t == true;
}
function Tn(t) {
  return typeof t == "number" ? t % 5 : { tri: 0, triangle: 0, sine: 1, ramp: 2, saw: 3, square: 4 }[t] ?? 0;
}
var j = map();
function q(t, e, n = {}) {
  t = t.toLowerCase().replace(/\s+/g, "_"), j.setKey(t, { onTrigger: e, data: n });
}
var Ye = (t) => t;
function A(t) {
  return Ye(t);
}
function ro(t) {
  Ye = t;
}
function vt(t) {
  for (const n in t)
    t[n.toLowerCase()] = t[n];
  const e = j.get();
  for (const n in e) {
    const [o, a] = n.split("_");
    if (!a) continue;
    const c = t[o];
    if (c) {
      if (typeof c == "string")
        e[`${c}_${a}`.toLowerCase()] = e[n];
      else if (Array.isArray(c))
        for (const s of c)
          e[`${s}_${a}`.toLowerCase()] = e[n];
    }
  }
  j.set({ ...e });
}
async function Hn(t) {
  const n = await (await fetch(t)).json();
  vt(n);
}
async function uo(...t) {
  switch (t.length) {
    case 1:
      return typeof t[0] == "string" ? Hn(t[0]) : vt(t[0]);
    case 2:
      return vt({ [t[0]]: t[1] });
    default:
      throw new Error("aliasMap expects 1 or 2 arguments, received " + t.length);
  }
}
function Tt(t) {
  return typeof t != "string" ? (console.warn(`getSound: expected string got "${t}". fall back to triangle`), j.get().triangle) : j.get()[t.toLowerCase()];
}
var wn = async () => {
  await navigator.mediaDevices.getUserMedia({ audio: true });
  let t = await navigator.mediaDevices.enumerateDevices();
  t = t.filter((n) => n.kind === "audiooutput" && n.deviceId !== "default");
  const e = /* @__PURE__ */ new Map();
  return e.set(Ct, ""), t.forEach((n) => {
    e.set(n.label, n.deviceId);
  }), e;
};
var lt = {
  s: "triangle",
  gain: 0.8,
  postgain: 1,
  density: ".03",
  ftype: "12db",
  fanchor: 0,
  resonance: 1,
  hresonance: 1,
  bandq: 1,
  channels: [1, 2],
  phaserdepth: 0.75,
  shapevol: 1,
  distortvol: 1,
  delay: 0,
  byteBeatExpression: "0",
  delayfeedback: 0.5,
  delaysync: 3 / 16,
  orbit: 1,
  i: 1,
  velocity: 1,
  fft: 8
};
var Kn = Object.freeze({ ...lt });
function mo(t, e) {
  lt[t] = e;
}
function ho() {
  lt = { ...Kn };
}
var kt = new Map(Object.entries(lt));
function Se(t, e) {
  kt.set(t, e);
}
function L(t) {
  return kt.get(t);
}
function po(t) {
  Object.keys(t).forEach((e) => {
    Se(e, t[e]);
  });
}
function Jn() {
  kt = new Map(Object.entries(lt));
}
function Zo(t) {
  Jn(), t === "1.0" && Se("fanchor", 0.5);
}
var bo = () => j.set({});
var Gt;
var Nn = () => (Gt = new AudioContext(), Gt);
var W = () => Gt || Nn();
function Xo() {
  return W().currentTime;
}
var Ht;
function Cn() {
  return Ht || (Ht = W().audioWorklet.addModule(pn)), Ht;
}
async function vn(t = {}) {
  const {
    disableWorklets: e = false,
    maxPolyphony: n,
    audioDeviceName: o = Ct,
    multiChannelOrbits: a = false
  } = t;
  if (Sn(n), Fn(a), typeof window > "u")
    return;
  const c = W();
  if (o != null && o != Ct)
    try {
      const d = (await wn()).get(o), l2 = (d ?? "").length > 0;
      c.sinkId !== d && l2 && await c.setSinkId(d), J(
        `[superdough] Audio Device set to ${o}, it might take a few seconds before audio plays on all output channels`
      );
    } catch {
      J("[superdough] failed to set audio interface", "warning");
    }
  if (await c.resume(), e) {
    J("[superdough]: AudioWorklets disabled with disableWorklets");
    return;
  }
  try {
    await Cn(), J("[superdough] AudioWorklets loaded");
  } catch (s) {
    console.warn("could not load AudioWorklet effects", s);
  }
  J("[superdough] ready");
}
var wt;
async function yo(t) {
  return wt || (wt = new Promise((e) => {
    document.addEventListener("click", async function n() {
      document.removeEventListener("click", n), await vn(t), e();
    });
  })), wt;
}
var Vt;
var nt2;
function Pn() {
  const t = W(), e = t.destination.maxChannelCount;
  t.destination.channelCount = e, Vt = new ChannelMergerNode(t, { numberOfInputs: t.destination.channelCount }), nt2 = new GainNode(t), Vt.connect(nt2), nt2.connect(t.destination);
}
var In = (t, e = [0, 1]) => {
  const n = W();
  Vt == null && Pn();
  const o = new StereoPannerNode(n);
  t.connect(o);
  const a = new ChannelSplitterNode(n, {
    numberOfOutputs: o.channelCount
  });
  o.connect(a), e.forEach((c, s) => {
    a.connect(Vt, s % o.channelCount, c % n.destination.channelCount);
  });
};
var Go = () => {
  nt2 != null && (nt2.gain.linearRampToValueAtTime(0, W().currentTime + 0.01), nt2 = null);
};
function kn(t, e, n, o) {
  var _a;
  if (n = $(n, 0, 0.98), !x[t].delayNode) {
    const c = W().createFeedbackDelay(1, e, n);
    (_a = c.start) == null ? void 0 : _a.call(c, o), ft(c, t), x[t].delayNode = c;
  }
  return x[t].delayNode.delayTime.value !== e && x[t].delayNode.delayTime.setValueAtTime(e, o), x[t].delayNode.feedback.value !== n && x[t].delayNode.feedback.setValueAtTime(n, o), x[t].delayNode;
}
function Qt(t, e, n, o = {}) {
  const { shape: a = 0, ...c } = o, { dcoffset: s = -0.5, depth: d = 1 } = o, l2 = {
    frequency: 1,
    depth: d,
    skew: 0.5,
    phaseoffset: 0,
    time: e,
    begin: e,
    end: n,
    shape: Tn(a),
    dcoffset: s,
    min: s * d,
    max: s * d + d,
    curve: 1,
    ...c
  };
  return I(t, "lfo-processor", l2);
}
function Qn(t, e, n = 1, o = 0.5, a = 1e3, c = 2e3) {
  const s = W(), d = Qt(s, t, e, { frequency: n, depth: c * 2 }), l2 = 2;
  let i = 0;
  const r = [];
  for (let h = 0; h < l2; h++) {
    const m = s.createBiquadFilter();
    m.type = "notch", m.gain.value = 1, m.frequency.value = a + i, m.Q.value = 2 - Math.min(Math.max(o * 2, 0), 1.9), d.connect(m.detune), i += 282, h > 0 && r[h - 1].connect(m), r.push(m);
  }
  return r[r.length - 1];
}
function Bn(t) {
  t = t ?? 0;
  const e = ["12db", "ladder", "24db"];
  return typeof t == "number" ? e[Math.floor(Ge(t, e.length))] : t;
}
var x = {};
function ft(t, e) {
  x[e] == null && Xe(new Error("target orbit does not exist"), "superdough"), t.connect(x[e].gain);
}
function Un(t, e, n) {
  x[e] == null && (x[e] = {
    gain: new GainNode(t, { gain: 1, channelCount: 2, channelCountMode: "explicit" })
  }, In(x[e].gain, n));
}
function jn(t, e, n, o = 0.1, a = 1) {
  [e].flat().forEach((s) => {
    if (x[s] == null) {
      Xe(new Error(`duck target orbit ${s} does not exist`), "superdough");
      return;
    }
    bt(
      t,
      () => {
        x[s].gain.gain.cancelScheduledValues(n);
        const d = x[s].gain.gain.value;
        x[s].gain.gain.linearRampToValueAtTime($(1 - Math.pow(a, 0.5), 0.01, d), n), x[s].gain.gain.exponentialRampToValueAtTime(1, n + Math.max(2e-3, o));
      },
      0,
      n - 0.01
    );
  });
}
var et = (t, e) => t !== void 0 && t !== e;
function On(t, e, n, o, a, c, s, d) {
  if (!x[t].reverbNode) {
    const i = W().createReverb(e, n, o, a, c, s, d);
    ft(i, t), x[t].reverbNode = i;
  }
  return (et(e, x[t].reverbNode.duration) || et(n, x[t].reverbNode.fade) || et(o, x[t].reverbNode.lp) || et(a, x[t].reverbNode.dim) || et(s, x[t].reverbNode.irspeed) || et(d, x[t].reverbNode.irbegin) || x[t].reverbNode.ir !== c) && x[t].reverbNode.generate(e, n, o, a, c, s, d), x[t].reverbNode;
}
var P = {};
var ot = {};
function Dn(t, e = 1024, n = 0.5) {
  if (!P[t]) {
    const o = W().createAnalyser();
    o.fftSize = e, o.smoothingTimeConstant = n, P[t] = o, ot[t] = new Float32Array(P[t].frequencyBinCount);
  }
  return P[t].fftSize !== e && (P[t].fftSize = e, ot[t] = new Float32Array(P[t].frequencyBinCount)), P[t];
}
function Vo(t = "time", e = 1) {
  const n = {
    time: () => {
      var _a;
      return (_a = P[e]) == null ? void 0 : _a.getFloatTimeDomainData(ot[e]);
    },
    frequency: () => {
      var _a;
      return (_a = P[e]) == null ? void 0 : _a.getFloatFrequencyData(ot[e]);
    }
  }[t];
  if (!n)
    throw new Error(`getAnalyzerData: ${t} not supported. use one of ${Object.keys(n).join(", ")}`);
  return n(), ot[e];
}
function Kt(t, e, n) {
  const o = H(n);
  return t.connect(o), o.connect(e), o;
}
function fo() {
  x = {}, P = {}, ot = {};
}
var at = /* @__PURE__ */ new Map();
function Ze(t) {
  return (Array.isArray(t) ? t : [t]).map((e) => e - 1);
}
var En = async (t, e, n, o = 0.5, a = 0.5) => {
  var _a, _b, _c;
  const c = W();
  let { stretch: s } = t;
  if (s != null && (e = e - 0.04), typeof t != "object")
    throw new Error(
      `expected hap.value to be an object, but got "${t}". Hint: append .note() or .s() to the end`,
      "error"
    );
  if (t.duration = n, e < c.currentTime) {
    console.warn(
      `[superdough]: cannot schedule sounds in the past (target: ${e.toFixed(2)}, now: ${c.currentTime.toFixed(2)})`
    );
    return;
  }
  let {
    tremolo: d,
    tremolosync: l2,
    tremolodepth: i = 1,
    tremoloskew: r,
    tremolophase: h = 0,
    tremoloshape: m,
    s: u = L("s"),
    bank: p,
    source: Z2,
    gain: X = L("gain"),
    postgain: y = L("postgain"),
    density: b = L("density"),
    duckorbit: V2,
    duckattack: g,
    duckdepth: f2,
    // filters
    fanchor: M = L("fanchor"),
    drive: w = 0.69,
    release: Y = 0,
    // low pass
    cutoff: F2,
    lpenv: S2,
    lpattack: O2,
    lpdecay: z2,
    lpsustain: T2,
    lprelease: k,
    resonance: xt = L("resonance"),
    // high pass
    hpenv: C2,
    hcutoff: _,
    hpattack: D,
    hpdecay: gt,
    hpsustain: Te,
    hprelease: He2,
    hresonance: we2 = L("hresonance"),
    // band pass
    bpenv: Ke,
    bandf: Bt,
    bpattack: Je,
    bpdecay: Ne,
    bpsustain: Ce,
    bprelease: ve2,
    bandq: Pe2 = L("bandq"),
    //phaser
    phaserrate: Ut,
    phaserdepth: jt = L("phaserdepth"),
    phasersweep: Ie,
    phasercenter: ke,
    //
    coarse: Ot,
    crush: Dt,
    dry: it2,
    shape: Et,
    shapevol: Mt = L("shapevol"),
    distort: At,
    distortvol: Rt = L("distortvol"),
    pan: qt,
    vowel: $t,
    delay: rt2 = L("delay"),
    delayfeedback: _t = L("delayfeedback"),
    delaysync: Qe = L("delaysync"),
    delaytime: ut,
    orbit: E = L("orbit"),
    room: te,
    roomfade: Be2,
    roomlp: Ue,
    roomdim: je2,
    roomsize: Oe,
    ir: zt,
    irspeed: De,
    irbegin: Ee,
    i: ee2 = L("i"),
    velocity: Lt = L("velocity"),
    analyze: ne,
    // analyser wet
    fft: Ae = L("fft"),
    // fftSize 0 - 10
    compressor: oe,
    compressorRatio: qe,
    compressorKnee: $e,
    compressorAttack: _e,
    compressorRelease: tn
  } = t;
  ut = ut ?? hn(Qe, o);
  const en = Ze(
    Le && E > 0 ? [E * 2 - 1, E * 2] : L("channels")
  ), nn = t.channels != null ? Ze(t.channels) : en;
  Un(c, E, nn), V2 != null && jn(c, V2, e, g, f2), X = A(U(X, 1)), y = A(y), Mt = A(Mt), Rt = A(Rt), rt2 = A(rt2), Lt = A(Lt), i = A(i), X *= Lt;
  const mt = e + n, ce = mt + Y, se = Math.round(Math.random() * 1e6);
  for (let G2 = 0; G2 <= at.size - ze; G2++) {
    const v2 = at.entries().next(), K = v2.value[1], N = v2.value[0], ie = e + 0.25;
    (_b = (_a = K == null ? void 0 : K.node) == null ? void 0 : _a.gain) == null ? void 0 : _b.linearRampToValueAtTime(0, ie), (_c = K == null ? void 0 : K.stop) == null ? void 0 : _c.call(K, ie), at.delete(N);
  }
  let tt2 = [];
  if (["-", "~", "_"].includes(u))
    return;
  p && u && (u = `${p}_${u}`, t.s = u);
  let ht;
  if (Z2)
    ht = Z2(e, t, n, o);
  else if (Tt(u)) {
    const { onTrigger: G2 } = Tt(u), K = await G2(e, t, () => {
      tt2.forEach((N) => N == null ? void 0 : N.disconnect()), at.delete(se);
    });
    K && (ht = K.node, at.set(se, K));
  } else
    throw new Error(`sound ${u} not found! Is it loaded?`);
  if (!ht)
    return;
  if (c.currentTime > e) {
    J("[webaudio] skip hap: still loading", c.currentTime - e);
    return;
  }
  const R2 = [];
  R2.push(ht), s !== void 0 && R2.push(I(c, "phase-vocoder-processor", { pitchFactor: s })), R2.push(H(X));
  const pt2 = Bn(t.ftype);
  if (F2 !== void 0) {
    let G2 = () => St(
      c,
      "lowpass",
      F2,
      xt,
      O2,
      z2,
      T2,
      k,
      S2,
      e,
      mt,
      M,
      pt2,
      w
    );
    R2.push(G2()), pt2 === "24db" && R2.push(G2());
  }
  if (_ !== void 0) {
    let G2 = () => St(
      c,
      "highpass",
      _,
      we2,
      D,
      gt,
      Te,
      He2,
      C2,
      e,
      mt,
      M
    );
    R2.push(G2()), pt2 === "24db" && R2.push(G2());
  }
  if (Bt !== void 0) {
    let G2 = () => St(c, "bandpass", Bt, Pe2, Je, Ne, Ce, ve2, Ke, e, mt, M);
    R2.push(G2()), pt2 === "24db" && R2.push(G2());
  }
  if ($t !== void 0) {
    const G2 = c.createVowelFilter($t);
    R2.push(G2);
  }
  if (Ot !== void 0 && R2.push(I(c, "coarse-processor", { coarse: Ot })), Dt !== void 0 && R2.push(I(c, "crush-processor", { crush: Dt })), Et !== void 0 && R2.push(I(c, "shape-processor", { shape: Et, postgain: Mt })), At !== void 0 && R2.push(I(c, "distort-processor", { distort: At, postgain: Rt })), l2 != null && (d = o * l2), d !== void 0) {
    const G2 = Math.max(1 - i, 0), v2 = new GainNode(c, { gain: G2 }), K = a / o;
    Qt(c, e, ce, {
      skew: r ?? (m != null ? 0.5 : 1),
      frequency: d,
      depth: i,
      time: K,
      dcoffset: 0,
      shape: m,
      phaseoffset: h,
      min: 0,
      max: 1,
      curve: 1.5
    }).connect(v2.gain), R2.push(v2);
  }
  if (oe !== void 0 && R2.push(
    bn(c, oe, qe, $e, _e, tn)
  ), qt !== void 0) {
    const G2 = c.createStereoPanner();
    G2.pan.value = 2 * qt - 1, R2.push(G2);
  }
  if (Ut !== void 0 && jt > 0) {
    const G2 = Qn(e, ce, Ut, jt, ke, Ie);
    R2.push(G2);
  }
  const st2 = new GainNode(c, { gain: y });
  R2.push(st2);
  let ae;
  if (rt2 > 0 && ut > 0 && _t > 0) {
    const G2 = kn(E, ut, _t, e);
    ae = Kt(st2, G2, rt2), tt2.push(ae);
  }
  let de;
  if (te > 0) {
    let G2;
    if (zt !== void 0) {
      let K, N = Tt(zt);
      Array.isArray(N) ? K = N.data.samples[ee2 % N.data.samples.length] : typeof N == "object" && (K = Object.values(N.data.samples).flat()[ee2 % Object.values(N.data.samples).length]), G2 = await We(K, c, zt, 0);
    }
    const v2 = On(E, Oe, Be2, Ue, je2, G2, De, Ee);
    de = Kt(st2, v2, te), tt2.push(de);
  }
  let le;
  if (ne) {
    const G2 = Dn(ne, 2 ** (Ae + 5));
    le = Kt(st2, G2, 1), tt2.push(le);
  }
  if (it2 != null) {
    it2 = A(it2);
    const G2 = new GainNode(c, { gain: it2 });
    R2.push(G2), ft(G2, E);
  } else
    ft(st2, E);
  R2.slice(1).reduce((G2, v2) => G2.connect(v2), R2[0]), tt2 = tt2.concat(R2);
};
var Wo = (t, e, n, o) => {
  En(e, t - n, e.duration / o, o);
};
var dt = (t, e = 36) => {
  let { note: n, freq: o } = t;
  return n = n || e, typeof n == "string" && (n = Wt(n)), !o && typeof n == "number" && (o = ye(n)), Number(o);
};
function Zt(t) {
  var _a;
  t != null && (t.disconnect(), (_a = t.parameters.get("end")) == null ? void 0 : _a.setValueAtTime(0, 0));
}
var An = ["triangle", "square", "sawtooth", "sine"];
var qn = [
  ["tri", "triangle"],
  ["sqr", "square"],
  ["saw", "sawtooth"],
  ["sin", "sine"]
];
function $n(t, e) {
  const n = t, o = new Float32Array(e);
  for (let a = 0; a < e; a++) {
    const c = a * 2 / e - 1;
    o[a] = Math.tanh(c * n);
  }
  return o;
}
function xo() {
  [...An].forEach((t) => {
    q(
      t,
      (e, n, o) => {
        const [a, c, s, d] = B(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let l2 = to(t, e, n), { node: i, stop: r, triggerRelease: h } = l2;
        const m = H(0.3), { duration: u } = n;
        i.onended = () => {
          i.disconnect(), m.disconnect(), o();
        };
        const p = H(1);
        let Z2 = i.connect(m).connect(p);
        const X = e + u;
        Q(Z2.gain, a, c, s, d, 0, 1, e, X, "linear");
        const y = X + d + 0.01;
        return h == null ? void 0 : h(y), r(y), {
          node: Z2,
          stop: (b) => {
            r(b);
          }
        };
      },
      { type: "synth", prebake: true }
    );
  }), q(
    "sbd",
    (t, e, n) => {
      const { duration: o, decay: a = 0.5, pdecay: c = 0.5, penv: s = 36, clip: d } = e, l2 = W(), i = 0.02, r = 1.2, h = 0.025, m = 1, u = l2.createOscillator();
      u.type = "triangle", u.frequency.value = dt(e, 29), u.detune.setValueAtTime(s * 100, 0), u.detune.setValueAtTime(s * 100, t), u.detune.exponentialRampToValueAtTime(1e-3, t + c);
      const p = H(1);
      p.gain.setValueAtTime(1, t + i), p.gain.exponentialRampToValueAtTime(1e-3, t + i + a), u.start(t);
      const Z2 = Jt("brown", t, 2), X = H(1);
      X.gain.setValueAtTime(r, t), X.gain.exponentialRampToValueAtTime(1e-3, t + h);
      const y = new WaveShaperNode(l2);
      y.curve = $n(2, l2.sampleRate);
      const b = H(m);
      u.onended = () => {
        u.disconnect(), p.disconnect(), y.disconnect(), Z2.node.disconnect(), X.disconnect(), b.disconnect(), n();
      };
      const V2 = u.connect(y).connect(p).connect(b);
      Z2.node.connect(X).connect(b);
      let f2 = t + a + 0.01;
      return d != null && (f2 = Math.min(t + d * o, f2)), b.gain.setValueAtTime(m, f2 - 0.01), b.gain.linearRampToValueAtTime(0, f2), u.stop(f2), Z2.stop(f2), {
        node: V2,
        stop: (M) => {
          u.stop(M);
        }
      };
    },
    { type: "synth", prebake: true }
  ), q(
    "supersaw",
    (t, e, n) => {
      const o = W();
      let { duration: a, n: c, unison: s = 5, spread: d = 0.6, detune: l2 } = e;
      l2 = l2 ?? c ?? 0.18;
      const i = dt(e), [r, h, m, u] = B(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), p = t + a, Z2 = p + u + 0.01, X = $(s, 1, 100);
      let y = X > 1 ? $(d, 0, 1) : 0, b = I(
        o,
        "supersaw-oscillator",
        {
          frequency: i,
          begin: t,
          end: Z2,
          freqspread: l2,
          voices: X,
          panspread: y
        },
        {
          outputChannelCount: [2]
        }
      );
      const V2 = 1 / Math.sqrt(X);
      Xt(b.parameters.get("detune"), e, t, p);
      const g = yt(b.parameters.get("detune"), e, t), f2 = Nt(b.parameters.get("frequency"), e, t);
      let M = H(1);
      M = b.connect(M), Q(M.gain, r, h, m, u, 0, 0.3 * V2, t, p, "linear");
      let w = bt(
        o,
        () => {
          Zt(b), M.disconnect(), n(), f2 == null ? void 0 : f2.stop(), g == null ? void 0 : g.stop();
        },
        t,
        Z2
      );
      return {
        node: M,
        stop: (Y) => {
          w.stop(Y);
        }
      };
    },
    { prebake: true, type: "synth" }
  ), q(
    "bytebeat",
    (t, e, n) => {
      const o = [
        "(t%255 >= t/255%255)*255",
        "(t*(t*8%60 <= 300)|(-t)*(t*4%512 < 256))+t/400",
        "t",
        "t*(t >> 10^t)",
        "t&128",
        "t&t>>8",
        "((t%255+t%128+t%64+t%32+t%16+t%127.8+t%64.8+t%32.8+t%16.8)/3)",
        "((t%64+t%63.8+t%64.15+t%64.35+t%63.5)/1.25)",
        "(t&(t>>7)-t)",
        "(sin(t*PI/128)*127+127)",
        "((t^t/2+t+64*(sin((t*PI/64)+(t*PI/32768))+64))%128*2)",
        "((t^t/2+t+64*(cos >> 0))%127.85*2)",
        "((t^t/2+t+64)%128*2)",
        "(((t * .25)^(t * .25)/100+(t * .25))%128)*2",
        "((t^t/2+t+64)%7 * 24)"
      ], { n: a = 0 } = e, c = dt(e), { byteBeatExpression: s = o[a % o.length], byteBeatStartTime: d } = e, l2 = W();
      let { duration: i } = e;
      const [r, h, m, u] = B(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), p = t + i, Z2 = p + u + 0.01;
      let X = I(
        l2,
        "byte-beat-processor",
        {
          frequency: c,
          begin: t,
          end: Z2
        },
        {
          outputChannelCount: [2]
        }
      );
      X.port.postMessage({ codeText: s, byteBeatStartTime: d, frequency: c });
      let y = H(1);
      y = X.connect(y), Q(y.gain, r, h, m, u, 0, 1, t, p, "linear");
      let b = bt(
        l2,
        () => {
          Zt(X), y.disconnect(), n();
        },
        t,
        Z2
      );
      return {
        node: y,
        stop: (V2) => {
          b.stop(V2);
        }
      };
    },
    { prebake: true, type: "synth" }
  ), q(
    "pulse",
    (t, e, n) => {
      const o = W();
      let { pwrate: a, pwsweep: c } = e;
      c == null && (a != null ? c = 0.3 : c = 0), a == null && c != null && (a = 1);
      let { duration: s, pw: d = 0.5 } = e;
      const l2 = dt(e), [i, r, h, m] = B(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), u = t + s, p = u + m + 0.01;
      let Z2 = I(
        o,
        "pulse-oscillator",
        {
          frequency: l2,
          begin: t,
          end: p,
          pulsewidth: d
        },
        {
          outputChannelCount: [2]
        }
      );
      Xt(Z2.parameters.get("detune"), e, t, u);
      const X = yt(Z2.parameters.get("detune"), e, t), y = Nt(Z2.parameters.get("frequency"), e, t);
      let b = H(1);
      b = Z2.connect(b), Q(b.gain, i, r, h, m, 0, 1, t, u, "linear");
      let V2;
      c != 0 && (V2 = Qt(o, t, p, { frequency: a, depth: c }), V2.connect(Z2.parameters.get("pulsewidth")));
      let g = bt(
        o,
        () => {
          Zt(Z2), Zt(V2), b.disconnect(), n(), y == null ? void 0 : y.stop(), X == null ? void 0 : X.stop();
        },
        t,
        p
      );
      return {
        node: b,
        stop: (f2) => {
          g.stop(f2);
        }
      };
    },
    { prebake: true, type: "synth" }
  ), [...fe].forEach((t) => {
    q(
      t,
      (e, n, o) => {
        const [a, c, s, d] = B(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let l2, { density: i } = n;
        l2 = Jt(t, e, i);
        let { node: r, stop: h, triggerRelease: m } = l2;
        const u = H(0.3), { duration: p } = n;
        r.onended = () => {
          r.disconnect(), u.disconnect(), o();
        };
        const Z2 = H(1);
        let X = r.connect(u).connect(Z2);
        const y = e + p;
        Q(X.gain, a, c, s, d, 0, 1, e, y, "linear");
        const b = y + d + 0.01;
        return m == null ? void 0 : m(b), h(b), {
          node: X,
          stop: (V2) => {
            h(V2);
          }
        };
      },
      { type: "synth", prebake: true }
    );
  }), qn.forEach(([t, e]) => j.set({ ...j.get(), [t]: j.get()[e] }));
}
function _n(t, e) {
  const n = new Float32Array(t + 1), o = new Float32Array(t + 1), a = W(), c = a.createOscillator(), s = {
    sawtooth: (i) => [0, -1 / i],
    square: (i) => [0, i % 2 === 0 ? 0 : 1 / i],
    triangle: (i) => [i % 2 === 0 ? 0 : 1 / (i * i), 0]
  };
  if (!s[e])
    throw new Error(`unknown wave type ${e}`);
  n[0] = 0, o[0] = 0;
  let d = 1;
  for (; d <= t; ) {
    const [i, r] = s[e](d);
    n[d] = i, o[d] = r, d++;
  }
  const l2 = a.createPeriodicWave(n, o);
  return c.setPeriodicWave(l2), c;
}
function to(t, e, n) {
  let { n: o, duration: a, noise: c = 0 } = n, s;
  !o || t === "sine" ? (s = W().createOscillator(), s.type = t || "triangle") : s = _n(o, t), s.frequency.value = dt(n), s.start(e);
  let d = yt(s.detune, n, e);
  Xt(s.detune, n, e, e + a);
  const l2 = Nt(s.frequency, n, e);
  let i;
  return c && (i = Zn(s, c, e)), {
    node: (i == null ? void 0 : i.node) || s,
    stop: (r) => {
      l2.stop(r), d == null ? void 0 : d.stop(r), i == null ? void 0 : i.stop(r), s.stop(r);
    },
    triggerRelease: (r) => {
    }
  };
}
function eo(t = 1, e = 0.05, n = 220, o = 0, a = 0, c = 0.1, s = 0, d = 1, l2 = 0, i = 0, r = 0, h = 0, m = 0, u = 0, p = 0, Z2 = 0, X = 0, y = 1, b = 0, V2 = 0) {
  let g = Math.PI * 2, f2 = W().sampleRate, M = (gt) => gt > 0 ? 1 : -1, w = l2 *= 500 * g / f2 / f2, Y = n *= (1 + e * 2 * Math.random() - e) * g / f2, F2 = [], S2 = 0, O2 = 0, z2 = 0, T2 = 1, k = 0, xt = 0, C2 = 0, _, D;
  for (o = o * f2 + 9, b *= f2, a *= f2, c *= f2, X *= f2, i *= 500 * g / f2 ** 3, p *= g / f2, r *= g / f2, h *= f2, m = m * f2 | 0, D = o + b + a + c + X | 0; z2 < D; F2[z2++] = C2)
    ++xt % (Z2 * 100 | 0) || (C2 = s ? s > 1 ? s > 2 ? s > 3 ? Math.sin((S2 % g) ** 3) : Math.max(Math.min(Math.tan(S2), 1), -1) : 1 - (2 * S2 / g % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(S2 / g) - S2 / g) : Math.sin(S2), C2 = (m ? 1 - V2 + V2 * Math.sin(g * z2 / m) : 1) * M(C2) * Math.abs(C2) ** d * // curve 0=square, 2=pointy
    t * 1 * // envelope
    (z2 < o ? z2 / o : z2 < o + b ? 1 - (z2 - o) / b * (1 - y) : z2 < o + b + a ? y : z2 < D - X ? (D - z2 - X) / c * // release falloff
    y : 0), C2 = X ? C2 / 2 + (X > z2 ? 0 : (z2 < D - X ? 1 : (D - z2) / X) * // release delay
    F2[z2 - X | 0] / 2) : C2), _ = (n += l2 += i) * // frequency
    Math.cos(p * O2++), S2 += _ - _ * u * (1 - (Math.sin(z2) + 1) * 1e9 % 2), T2 && ++T2 > h && (n += r, Y += r, T2 = 0), m && !(++k % m) && (n = Y, l2 = w, T2 || (T2 = 1));
  return F2;
}
var no = (t, e) => {
  let {
    s: n,
    note: o = 36,
    freq: a,
    //
    zrand: c = 0,
    attack: s = 0,
    decay: d = 0,
    sustain: l2 = 0.8,
    release: i = 0.1,
    curve: r = 1,
    slide: h = 0,
    deltaSlide: m = 0,
    pitchJump: u = 0,
    pitchJumpTime: p = 0,
    lfo: Z2 = 0,
    znoise: X = 0,
    zmod: y = 0,
    zcrush: b = 0,
    zdelay: V2 = 0,
    tremolo: g = 0,
    duration: f2 = 0.2,
    zzfx: M
  } = t;
  const w = Math.max(f2 - s - d, 0);
  typeof o == "string" && (o = Wt(o)), !a && typeof o == "number" && (a = ye(o)), n = n.replace("z_", "");
  const Y = ["sine", "triangle", "sawtooth", "tan", "noise"].indexOf(n) || 0;
  r = n === "square" ? 0 : r;
  const S2 = (
    /* ZZFX. */
    eo(...M || [
      0.25,
      // volume
      c,
      a,
      s,
      w,
      i,
      Y,
      r,
      h,
      m,
      u,
      p,
      Z2,
      X,
      y,
      b,
      V2,
      l2,
      // sustain volume!
      d,
      g
    ])
  ), O2 = W(), z2 = O2.createBuffer(1, S2.length, O2.sampleRate);
  z2.getChannelData(0).set(S2);
  const T2 = W().createBufferSource();
  return T2.buffer = z2, T2.start(e), {
    node: T2
  };
};
function go() {
  ["zzfx", "z_sine", "z_sawtooth", "z_triangle", "z_square", "z_tan", "z_noise"].forEach((t) => {
    q(
      t,
      (e, n, o) => {
        const { node: a } = no({ s: t, ...n }, e);
        return a.onended = () => {
          a.disconnect(), o();
        }, {
          node: a,
          stop: () => {
          }
        };
      },
      { type: "synth", prebake: true }
    );
  });
}
var ct;
async function oo(t, e) {
  const n = `dsp-worklet-${Date.now()}`, o = `${e}
let __q = []; // trigger queue
class MyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.t = 0;
    this.stopped = false;
    this.port.onmessage = (e) => {
      if(e.data==='stop') {
        this.stopped = true;
      } else if(e.data?.dough) {
        __q.push(e.data)
      } else {
        msg?.(e.data)
      }
    };
  }
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    if(__q.length) {
      for(let i=0;i<__q.length;++i) {
        const deadline = __q[i].time-currentTime;
        if(deadline<=0) {
          trigger(__q[i].dough)
          __q.splice(i,1)
        }
      }
    }
    for (let i = 0; i < output[0].length; i++) {
      const out = dsp(this.t / sampleRate);
      output.forEach((channel) => {
        channel[i] = out;
      });
      this.t++;
    }
  return !this.stopped;
  }
}
registerProcessor('${n}', MyProcessor);
`, c = `data:text/javascript;base64,${btoa(o)}`;
  await t.audioWorklet.addModule(c);
  const s = new AudioWorkletNode(t, n);
  return { node: s, stop: () => s.port.postMessage("stop") };
}
var Fe = () => {
  var _a;
  ct && (ct == null ? void 0 : ct.stop(), (_a = ct == null ? void 0 : ct.node) == null ? void 0 : _a.disconnect());
};
typeof window < "u" && window.addEventListener("message", (t) => {
  var _a;
  t.data === "strudel-stop" ? Fe() : ((_a = t.data) == null ? void 0 : _a.dough) && (ct == null ? void 0 : ct.node.port.postMessage(t.data));
});
var Mo = async (t) => {
  const e = W();
  Fe(), ct = await oo(e, t), ct.node.connect(e.destination);
};
function Ro(t, e, n, o) {
  window.postMessage({ time: o, dough: t.value, currentTime: e, duration: t.duration, cps: n });
}

// node_modules/@strudel/draw/dist/index.mjs
var Z = (t = "test-canvas", e) => {
  let { contextType: n = "2d", pixelated: o = false, pixelRatio: a = window.devicePixelRatio } = e || {}, r = document.querySelector("#" + t);
  if (!r) {
    r = document.createElement("canvas"), r.id = t, r.width = window.innerWidth * a, r.height = window.innerHeight * a, r.style = "pointer-events:none;width:100%;height:100%;position:fixed;top:0;left:0", o && (r.style.imageRendering = "pixelated"), document.body.prepend(r);
    let l2;
    window.addEventListener("resize", () => {
      l2 && clearTimeout(l2), l2 = setTimeout(() => {
        r.width = window.innerWidth * a, r.height = window.innerHeight * a;
      }, 200);
    });
  }
  return r.getContext(n, { willReadFrequently: true });
};
var $2 = {};
function pe2(t) {
  $2[t] !== void 0 && (cancelAnimationFrame($2[t]), delete $2[t]);
}
var R = {};
f.prototype.draw = function(t, e) {
  if (typeof window > "u")
    return this;
  let { id: n = 1, lookbehind: o = 0, lookahead: a = 0 } = e, r = Math.max(id(), 0);
  pe2(n), o = Math.abs(o), R[n] = (R[n] || []).filter((g) => !g.isInFuture(r));
  let l2 = this.queryArc(r, r + a).filter((g) => g.hasOnset());
  R[n] = R[n].concat(l2);
  let f2;
  const i = () => {
    const g = id(), u = g + a;
    R[n] = R[n].filter((d) => d.isInNearPast(o, g));
    let c = Math.max(f2 || u, u - 1 / 10);
    const b = this.queryArc(c, u).filter((d) => d.hasOnset());
    R[n] = R[n].concat(b), f2 = u, t(R[n], g, u, this), $2[n] = requestAnimationFrame(i);
  };
  return $2[n] = requestAnimationFrame(i), this;
};
f.prototype.onPaint = function(t) {
  return this.withState((e) => {
    e.controls.painters || (e.controls.painters = []), e.controls.painters.push(t);
  });
};
f.prototype.getPainters = function() {
  let t = [];
  return this.queryArc(0, 0, { painters: t }), t;
};
var ye2 = {
  background: "#222",
  foreground: "#75baff",
  caret: "#ffcc00",
  selection: "rgba(128, 203, 196, 0.5)",
  selectionMatch: "#036dd626",
  lineHighlight: "#00000050",
  gutterBackground: "transparent",
  gutterForeground: "#8a919966"
};
function W2() {
  return ye2;
}
var fe2 = "#22222210";
f.prototype.animate = function({ callback: t, sync: e = false, smear: n = 0.5 } = {}) {
  window.frame && cancelAnimationFrame(window.frame);
  const o = Z();
  let { clientWidth: a, clientHeight: r } = o.canvas;
  a *= window.devicePixelRatio, r *= window.devicePixelRatio;
  let l2 = n === 0 ? "99" : Number((1 - n) * 100).toFixed(0);
  l2 = l2.length === 1 ? `0${l2}` : l2, fe2 = `#200010${l2}`;
  const f2 = (i) => {
    let g;
    i = Math.round(i), g = this.slow(1e3).queryArc(i, i), o.fillStyle = fe2, o.fillRect(0, 0, a, r), g.forEach((u) => {
      let { x: c, y: b, w: d, h: w, s: p, r: k, angle: h = 0, fill: S2 = "darkseagreen" } = u.value;
      if (d *= a, w *= r, k !== void 0 && h !== void 0) {
        const v2 = h * 2 * Math.PI, [y, P2] = [(a - d) / 2, (r - w) / 2];
        c = y + Math.cos(v2) * k * y, b = P2 + Math.sin(v2) * k * P2;
      } else
        c *= a - d, b *= r - w;
      const A2 = { ...u.value, x: c, y: b, w: d, h: w };
      o.fillStyle = S2, p === "rect" ? o.fillRect(c, b, d, w) : p === "ellipse" && (o.beginPath(), o.ellipse(c + d / 2, b + w / 2, d / 2, w / 2, 0, 0, 2 * Math.PI), o.fill()), t && t(o, A2, u);
    }), window.frame = requestAnimationFrame(f2);
  };
  return window.frame = requestAnimationFrame(f2), v;
};
var { x: we, y: xe2, w: et2, h: tt, angle: nt3, r: rt, fill: at2, smear: ot2 } = Pu("x", "y", "w", "h", "angle", "r", "fill", "smear");
var it = l("rescale", function(t, e) {
  return e.mul(we(t).w(t).y(t).h(t));
});
var lt2 = l("moveXY", function(t, e, n) {
  return n.add(we(t).y(e));
});
var st = l("zoomIn", function(t, e) {
  const n = z(1).sub(t).div(2);
  return e.rescale(t).move(n, n);
});
var G = (t, e, n) => t * (n - e) + e;
var he2 = (t) => {
  let { value: e } = t;
  typeof t.value != "object" && (e = { value: e });
  let { note: n, n: o, freq: a, s: r } = e;
  if (a)
    return Pe(a);
  if (n = n ?? o, typeof n == "string")
    try {
      return pt(n);
    } catch {
      return 0;
    }
  return typeof n == "number" ? n : r ? "_" + r : e;
};
f.prototype.pianoroll = function(t = {}) {
  let { cycles: e = 4, playhead: n = 0.5, overscan: o = 0, hideNegative: a = false, ctx: r = Z(), id: l2 = 1 } = t, f2 = -e * n, i = e * (1 - n);
  const g = (u, c) => (!a || u.whole.begin >= 0) && u.isWithinTime(c + f2, c + i);
  return this.draw(
    (u, c) => {
      ee({
        ...t,
        time: c,
        ctx: r,
        haps: u.filter((b) => g(b, c))
      });
    },
    {
      lookbehind: f2 - o,
      lookahead: i + o,
      id: l2
    }
  ), this;
};
function ee({
  time: t,
  haps: e,
  cycles: n = 4,
  playhead: o = 0.5,
  flipTime: a = 0,
  flipValues: r = 0,
  hideNegative: l2 = false,
  inactive: f2 = W2().foreground,
  active: i = W2().foreground,
  background: g = "transparent",
  smear: u = 0,
  playheadColor: c = W2().foreground,
  minMidi: b = 10,
  maxMidi: d = 90,
  autorange: w = 0,
  timeframe: p,
  fold: k = 1,
  vertical: h = 0,
  labels: S2 = false,
  fill: A2 = 1,
  fillActive: v2 = false,
  strokeActive: y = true,
  stroke: P2,
  hideInactive: H3 = 0,
  colorizeInactive: q2 = 1,
  fontFamily: C2,
  ctx: s,
  id: _
} = {}) {
  const T2 = s.canvas.width, I2 = s.canvas.height;
  let z2 = -n * o, j3 = n * (1 - o);
  _ && (e = e.filter((m) => m.hasTag(_))), p && (console.warn("timeframe is deprecated! use from/to instead"), z2 = 0, j3 = p);
  const N = h ? I2 : T2, E = h ? T2 : I2;
  let L3 = h ? [N, 0] : [0, N];
  const J2 = j3 - z2, te = h ? [0, E] : [E, 0];
  let K = d - b + 1, D = E / K, Q2 = [];
  a && L3.reverse(), r && te.reverse();
  const { min: ke, max: Pe2, values: Te } = e.reduce(
    ({ min: m, max: F2, values: X }, Y) => {
      const M = he2(Y);
      return {
        min: M < m ? M : m,
        max: M > F2 ? M : F2,
        values: X.includes(M) ? X : [...X, M]
      };
    },
    { min: 1 / 0, max: -1 / 0, values: [] }
  );
  w && (b = ke, d = Pe2, K = d - b + 1), Q2 = Te.sort(
    (m, F2) => typeof m == "number" && typeof F2 == "number" ? m - F2 : typeof m == "number" ? 1 : String(m).localeCompare(String(F2))
  ), D = k ? E / Q2.length : E / K, s.fillStyle = g, s.globalAlpha = 1, u || (s.clearRect(0, 0, T2, I2), s.fillRect(0, 0, T2, I2)), e.forEach((m) => {
    var _a;
    const F2 = m.whole.begin <= t && m.endClipped > t;
    let X = P2 ?? (y && F2), Y = !F2 && A2 || F2 && v2;
    if (H3 && !F2)
      return;
    let M = (_a = m.value) == null ? void 0 : _a.color;
    i = M || i, f2 = q2 && M || f2, M = F2 ? i : f2, s.fillStyle = Y ? M : "transparent", s.strokeStyle = M;
    const { velocity: Ae = 1, gain: qe = 1 } = m.value || {};
    s.globalAlpha = Ae * qe;
    const Fe2 = (m.whole.begin - (a ? j3 : z2)) / J2, ne = G(Fe2, ...L3);
    let B3 = G(m.duration / J2, 0, N);
    const re2 = he2(m), Me2 = k ? Q2.indexOf(re2) / Q2.length : (Number(re2) - b) / K, ae = G(Me2, ...te);
    let oe = 0;
    const ie = G(t / J2, ...L3);
    let V2;
    if (h ? V2 = [
      ae + 1 - (r ? D : 0),
      // x
      N - ie + ne + oe + 1 - (a ? 0 : B3),
      // y
      D - 2,
      // width
      B3 - 2
      // height
    ] : V2 = [
      ne - ie + oe + 1 - (a ? B3 : 0),
      // x
      ae + 1 - (r ? 0 : D),
      // y
      B3 - 2,
      // widith
      D - 2
      // height
    ], X && s.strokeRect(...V2), Y && s.fillRect(...V2), S2) {
      const Se2 = m.value.note ?? m.value.s + (m.value.n ? `:${m.value.n}` : ""), { label: le, activeLabel: Ce } = m.value, He2 = (F2 && Ce || le) ?? Se2;
      let Ie = h ? B3 : D * 0.75;
      s.font = `${Ie}px ${C2 || "monospace"}`, s.fillStyle = /* isActive &&  */
      Y ? "black" : M, s.textBaseline = "top", s.fillText(He2, ...V2);
    }
  }), s.globalAlpha = 1;
  const U2 = G(-z2 / J2, ...L3);
  return s.strokeStyle = c, s.beginPath(), h ? (s.moveTo(0, U2), s.lineTo(E, U2)) : (s.moveTo(U2, 0), s.lineTo(U2, E)), s.stroke(), this;
}
function ve(t, e = {}) {
  let [n, o] = t;
  n = Math.abs(n);
  const a = o + n, r = a !== 0 ? n / a : 0;
  return { fold: 1, ...e, cycles: a, playhead: r };
}
var je = (t = {}) => (e, n, o, a) => ee({ ctx: e, time: n, haps: o, ...ve(a, t) });
f.prototype.punchcard = function(t) {
  return this.onPaint(je(t));
};
f.prototype.wordfall = function(t) {
  return this.punchcard({ vertical: 1, labels: 1, stroke: 0, fillActive: 1, active: "white", ...t });
};
function Xe2(t, e, n, o) {
  const a = (t - 90) * Math.PI / 180;
  return [n + Math.cos(a) * e, o + Math.sin(a) * e];
}
var ue2 = (t, e, n, o, a = 0) => Xe2((t + a) * 360, e * t, n, o);
function me2(t) {
  let {
    ctx: e,
    from: n = 0,
    to: o = 3,
    margin: a = 50,
    cx: r = 100,
    cy: l2 = 100,
    rotate: f2 = 0,
    thickness: i = a / 2,
    color: g = W2().foreground,
    cap: u = "round",
    stretch: c = 1,
    fromOpacity: b = 1,
    toOpacity: d = 1
  } = t;
  n *= c, o *= c, f2 *= c, e.lineWidth = i, e.lineCap = u, e.strokeStyle = g, e.globalAlpha = b, e.beginPath();
  let [w, p] = ue2(n, a, r, l2, f2);
  e.moveTo(w, p);
  const k = 1 / 60;
  let h = n;
  for (; h <= o; ) {
    const [S2, A2] = ue2(h, a, r, l2, f2);
    e.globalAlpha = (h - n) / (o - n) * d, e.lineTo(S2, A2), h += k;
  }
  e.stroke();
}
function Ye2(t) {
  let {
    stretch: e = 1,
    size: n = 80,
    thickness: o = n / 2,
    cap: a = "butt",
    // round butt squar,
    inset: r = 3,
    // start angl,
    playheadColor: l2 = "#ffffff",
    playheadLength: f2 = 0.02,
    playheadThickness: i = o,
    padding: g = 0,
    steady: u = 1,
    activeColor: c = W2().foreground,
    inactiveColor: b = W2().gutterForeground,
    colorizeInactive: d = 0,
    fade: w = true,
    // logSpiral = true,
    ctx: p,
    time: k,
    haps: h,
    drawTime: S2,
    id: A2
  } = t;
  A2 && (h = h.filter((T2) => T2.hasTag(A2)));
  const [v2, y] = [p.canvas.width, p.canvas.height];
  p.clearRect(0, 0, v2 * 2, y * 2);
  const [P2, H3] = [v2 / 2, y / 2], q2 = {
    margin: n / e,
    cx: P2,
    cy: H3,
    stretch: e,
    cap: a,
    thickness: o
  }, C2 = {
    ...q2,
    thickness: i,
    from: r - f2,
    to: r,
    color: l2
  }, [s] = S2, _ = u * k;
  h.forEach((T2) => {
    var _a;
    const I2 = T2.whole.begin <= k && T2.endClipped > k, z2 = T2.whole.begin - k + r, j3 = T2.endClipped - k + r - g, N = ((_a = T2.value) == null ? void 0 : _a.color) || c, E = d || I2 ? N : b, L3 = w ? 1 - Math.abs((T2.whole.begin - k) / s) : 1;
    me2({
      ctx: p,
      ...q2,
      from: z2,
      to: j3,
      rotate: _,
      color: E,
      fromOpacity: L3,
      toOpacity: L3
    });
  }), me2({
    ctx: p,
    ...C2,
    rotate: _
  });
}
f.prototype.spiral = function(t = {}) {
  return this.onPaint((e, n, o, a) => Ye2({ ctx: e, time: n, haps: o, drawTime: a, ...t }));
};
var Be = nt(36);
var ge2 = (t, e, n, o) => {
  o = o * Math.PI * 2;
  const a = Math.sin(o) * n + t, r = Math.cos(o) * n + e;
  return [a, r];
};
var be2 = (t, e) => 0.5 - Math.log2(t / e) % 1;
function Ve2({
  haps: t,
  ctx: e,
  id: n,
  hapcircles: o = 1,
  circle: a = 0,
  edo: r = 12,
  root: l2 = Be,
  thickness: f2 = 3,
  hapRadius: i = 6,
  mode: g = "flake",
  margin: u = 10
} = {}) {
  const c = g === "polygon", b = g === "flake", d = e.canvas.width, w = e.canvas.height;
  e.clearRect(0, 0, d, w);
  const p = W2().foreground, h = Math.min(d, w) / 2 - f2 / 2 - i - u, S2 = d / 2, A2 = w / 2;
  n && (t = t.filter((y) => y.hasTag(n))), e.strokeStyle = p, e.fillStyle = p, e.globalAlpha = 1, e.lineWidth = f2, a && (e.beginPath(), e.arc(S2, A2, h, 0, 2 * Math.PI), e.stroke()), r && (Array.from({ length: r }, (y, P2) => {
    const H3 = be2(l2 * Math.pow(2, P2 / r), l2), [q2, C2] = ge2(S2, A2, h, H3);
    e.beginPath(), e.arc(q2, C2, i, 0, 2 * Math.PI), e.fill();
  }), e.stroke());
  let v2 = [];
  e.lineWidth = i, t.forEach((y) => {
    let P2;
    try {
      P2 = Fa(y);
    } catch {
      return;
    }
    const H3 = be2(P2, l2), [q2, C2] = ge2(S2, A2, h, H3), s = y.value.color || p;
    e.strokeStyle = s, e.fillStyle = s;
    const { velocity: _ = 1, gain: T2 = 1 } = y.value || {}, I2 = _ * T2;
    e.globalAlpha = I2, v2.push([q2, C2, H3, s, I2]), e.beginPath(), o && (e.moveTo(q2 + i, C2), e.arc(q2, C2, i, 0, 2 * Math.PI), e.fill()), b && (e.moveTo(S2, A2), e.lineTo(q2, C2)), e.stroke();
  }), e.strokeStyle = p, e.globalAlpha = 1, c && v2.length && (v2 = v2.sort((y, P2) => y[2] - P2[2]), e.beginPath(), e.moveTo(v2[0][0], v2[0][1]), v2.forEach(([y, P2, H3, q2, C2]) => {
    e.strokeStyle = q2, e.globalAlpha = C2, e.lineTo(y, P2);
  }), e.lineTo(v2[0][0], v2[0][1]), e.stroke());
}
f.prototype.pitchwheel = function(t = {}) {
  let { ctx: e = Z(), id: n = 1 } = t;
  return this.tag(n).onPaint(
    (o, a, r) => Ve2({
      ...t,
      time: a,
      ctx: e,
      haps: r.filter((l2) => l2.isActive(a)),
      id: n
    })
  );
};

// node_modules/@strudel/webaudio/dist/index.mjs
var { Pattern: O, logger: W3, repl: $3 } = dist_exports;
so(W3);
var B2 = (e) => (e.ensureObjectValue(), e.value);
var F = (e, t, o, s, f2) => {
  var _a;
  return En(B2(e), f2, o, s, (_a = e.whole) == null ? void 0 : _a.begin.valueOf());
};
function H2(e = {}) {
  return e = {
    getTime: () => W().currentTime,
    defaultOutput: F,
    ...e
  }, $3(e);
}
O.prototype.dough = function() {
  return this.onTrigger(Ro, 1);
};
function j2(e, {
  align: t = true,
  color: o = "white",
  thickness: s = 3,
  scale: f2 = 0.25,
  pos: a = 0.75,
  trigger: u = 0,
  ctx: r = Z(),
  id: y = 1
} = {}) {
  r.lineWidth = s, r.strokeStyle = o;
  let c = r.canvas;
  if (!e) {
    r.beginPath();
    let l2 = a * c.height;
    r.moveTo(0, l2), r.lineTo(c.width, l2), r.stroke();
    return;
  }
  const n = Vo("time", y);
  r.beginPath();
  const p = e.frequencyBinCount;
  let h = t ? Array.from(n).findIndex((l2, d, g) => d && g[d - 1] > -u && l2 <= -u) : 0;
  h = Math.max(h, 0);
  const w = c.width * 1 / p;
  let i = 0;
  for (let l2 = h; l2 < p; l2++) {
    const d = n[l2] + 1, g = (a - f2 * (d - 1)) * c.height;
    l2 === 0 ? r.moveTo(i, g) : r.lineTo(i, g), i += w;
  }
  r.stroke();
}
function L2(e, { color: t = "white", scale: o = 0.25, pos: s = 0.75, lean: f2 = 0.5, min: a = -150, max: u = 0, ctx: r = Z(), id: y = 1 } = {}) {
  if (!e) {
    r.beginPath();
    let i = s * n.height;
    r.moveTo(0, i), r.lineTo(n.width, i), r.stroke();
    return;
  }
  const c = Vo("frequency", y), n = r.canvas;
  r.fillStyle = t;
  const p = e.frequencyBinCount, h = n.width * 1 / p;
  let w = 0;
  for (let i = 0; i < p; i++) {
    const d = He((c[i] - a) / (u - a), 0, 1) * o, g = d * n.height, D = (s - d * f2) * n.height;
    r.fillRect(w, D, Math.max(h, 1), g), w += h;
  }
}
function C(e = 0, t = "0,0,0", o = Z()) {
  e ? (o.fillStyle = `rgba(${t},${1 - e})`, o.fillRect(0, 0, o.canvas.width, o.canvas.height)) : o.clearRect(0, 0, o.canvas.width, o.canvas.height);
}
f.prototype.fscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    () => {
      C(e.smear, "0,0,0", e.ctx), P[t] && L2(P[t], e);
    },
    { id: t }
  );
};
f.prototype.tscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (o) => {
      var _a, _b;
      e.color = ((_b = (_a = o[0]) == null ? void 0 : _a.value) == null ? void 0 : _b.color) || W2().foreground, e.color, C(e.smear, "0,0,0", e.ctx), j2(P[t], e);
    },
    { id: t }
  );
};
f.prototype.scope = f.prototype.tscope;
var T = {};
f.prototype.spectrum = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (o) => {
      var _a, _b;
      e.color = ((_b = (_a = o[0]) == null ? void 0 : _a.value) == null ? void 0 : _b.color) || T[t] || W2().foreground, T[t] = e.color, V(P[t], e);
    },
    { id: t }
  );
};
f.prototype.scope = f.prototype.tscope;
var S = /* @__PURE__ */ new Map();
function V(e, { thickness: t = 3, speed: o = 1, min: s = -80, max: f2 = 0, ctx: a = Z(), id: u = 1, color: r } = {}) {
  if (a.lineWidth = t, a.strokeStyle = r, !e)
    return;
  const y = o, c = Vo("frequency", u), n = a.canvas;
  a.fillStyle = r;
  const p = e.frequencyBinCount;
  let h = S.get(u) || a.getImageData(0, 0, n.width, n.height);
  S.set(u, h), a.clearRect(0, 0, a.canvas.width, a.canvas.height), a.putImageData(h, -y, 0);
  let w = n.width - o;
  for (let i = 0; i < p; i++) {
    const l2 = He((c[i] - s) / (f2 - s), 0, 1);
    a.globalAlpha = l2;
    const d = Math.log(i + 1) / Math.log(p) * n.height;
    a.fillRect(w, n.height - d, y, 2);
  }
  S.set(u, a.getImageData(0, 0, n.width, n.height));
}
export {
  Re as DEFAULT_MAX_POLYPHONY,
  uo as aliasBank,
  P as analysers,
  ot as analysersData,
  Nt as applyFM,
  A as applyGainCurve,
  In as connectToDestination,
  St as createFilter,
  Mo as dough,
  Ro as doughTrigger,
  L2 as drawFrequencyScope,
  j2 as drawTimeScope,
  Xn as drywet,
  oo as dspWorklet,
  Xe as errorLogger,
  H as gainNode,
  B as getADSRValues,
  Dn as getAnalyserById,
  Vo as getAnalyzerData,
  W as getAudioContext,
  Xo as getAudioContextCurrentTime,
  wn as getAudioDevices,
  ao as getCachedBuffer,
  bn as getCompressor,
  L as getDefaultValue,
  Qt as getLfo,
  lo as getLoadedBuffer,
  to as getOscillator,
  Q as getParamADSR,
  Xt as getPitchEnvelope,
  xn as getSampleBuffer,
  gn as getSampleBufferSource,
  Wn as getSampleInfo,
  Tt as getSound,
  yt as getVibratoOscillator,
  I as getWorklet,
  no as getZZFX,
  vn as initAudio,
  yo as initAudioOnFirstClick,
  Pn as initializeAudioOutput,
  We as loadBuffer,
  J as logger,
  fe as noises,
  Yn as onTriggerSample,
  Go as panic,
  Rn as processSampleMap,
  io as registerSamplesPrefix,
  q as registerSound,
  xo as registerSynthSounds,
  go as registerZZFXSounds,
  Jn as resetDefaultValues,
  ho as resetDefaults,
  fo as resetGlobalEffects,
  bo as resetLoadedSounds,
  Mn as reverseBuffer,
  Ln as samples,
  mo as setDefault,
  Nn as setDefaultAudioContext,
  Se as setDefaultValue,
  po as setDefaultValues,
  ro as setGainCurve,
  so as setLogger,
  Sn as setMaxPolyphony,
  Fn as setMultiChannelOrbits,
  Zo as setVersionDefaults,
  j as soundMap,
  En as superdough,
  Wo as superdoughTrigger,
  _n as waveformN,
  bt as webAudioTimeout,
  F as webaudioOutput,
  H2 as webaudioRepl
};
//# sourceMappingURL=@strudel_webaudio.js.map
